\documentclass{article}

\title{PVI Memory Safety}

\begin{document}

\section{Why Memory Safety?}

\section{How Memory Safety?}

The core of the PVI policy is the {\it provenance color}, represented
by a nat. We will describe the tag rules and their control points in
terms of when tags are generated and when they are checked.

\[T ::= \mathit{glob} ~ id  \mathit{dyn} ~ \color \in \mathbb{N}\]

\paragraph*{Color generators}

New colors are generated when objects are allocated. When exactly that occurs
depends on where the object lives. Global variables are allocated during program
initialization (technically, before execution begins.) Stack-allocated locals
are allocated at the start of a function call. Heap objects are the most interesting:
they are allocated via calls to malloc.

GLOBALALLOC PSEUDO CONTROL POINT

globals ((x,ty)::xs) env m = globals xs env[x |-> base,bound,glob ~ x] m[base ... bound |-> 0@X@glob ~ x]
globals ((x,ty)::xs) env m =
pt,lts <- GLOBALT(x,ty);
base,bound <- alloc(size(ty));
globals xs env[x |-> base,bound,pt] m[base ... bound |-> 0@X@glob ~ x]

STACKALLOC CONTROL POINT

In Tagged C, malloc is modeled as an external call. This is tricky to write a control
point for. It is clear what the malloc control point would be if malloc were a 
statement. But an external call might be implemented by arbitrary code that has
its own tagging scheme.

Importantly, while the typical source construct has local effects (with at most
one level of indirection), an external call might manipulate portions of
the state that are not reachable from its parameters. So in general an external
call cannot have a normal control point. But, specific external calls have clear
specifications: malloc takes a size and returns a pointer to an object of that size,
whatever else it may do to other parts of the state. So we can give it a control point
that establishes how those outputs should be tagged given the tags on the inputs.

MALLOC CONTROL POINT

\paragraph*{Color Checking}

LOAD CONTROL POINT

\trule{\vt}{\loadt{}{}{}{}}

\assignop{op}{\loc{addr}{pt}}{\val} \longrightarrow \assign{\loc{addr}{pt}}{\binop{op}{\val}}

\postinc{op}{\loc{addr}{pt}}{\val} \longrightarrow \assign{\loc{addr}{pt}}{\unop{op}{\val}}

STORE CONTROL POINT

\paragraph*{Color Propagation}

BINOP CONTROL POINT

UNOP CONTROL POINT

\section{Validation}

\paragraph*{Examples}

\paragraph*{Specification}

The PVI Memory Safety policy is specified by the PVI semantics from Memarian et al.
Their semantics are two-sided (is this the right term?) meaning that they both give
the semantics of a defined program and also define exactly when a program has
undefined behavior. In contrast, the CompCert C semantics give semantics to some,
but not all, undefined behavior.

We define correctness simply: for any program, if it is run in both the PVI semantics
and in Tagged C with our PVI policy, it either produces identical output, or it is both
undefined in the PVI semantics and failstops in Tagged C.

Note that the formal semantics given by Memarian et al. are not quite shaped the same
as our CompCert-based semantics. So we must define an intermediate semantics that is
shaped the same as ours, and sketch a proof that they are equivalent.
Then we prove the intermediate semantics to be correct.

\paragraph*{Proof Sketch}

\end{document}
