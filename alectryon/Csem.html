<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.20.1: https://docutils.sourceforge.io/" />
<title>Tagged C Semantics</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.15.0+0.15.4. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tagged-c-semantics">
<h1 class="title">Tagged C Semantics</h1>
<h2 class="subtitle" id="expression-reductions">Expression Reductions</h2>

<div class="section" id="left-hand-reductions">
<h1>Left-hand reductions</h1>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">lred</span> : expr -&gt; control_tag -&gt; tenv -&gt; mem -&gt;
                     expr -&gt; tenv -&gt; mem -&gt;
                     pstate -&gt; pstate -&gt; <span class="kt">Prop</span> :=
    | red_var_tmp: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">ty</span> <span class="nv">pct</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        e!x = Some (PRIV ty) -&gt;
        lred (Evar x ty) pct te m
             (Eloc (Ltmp x) ty) te m ps ps
    | red_var_local: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">pct</span> <span class="nv">base</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        e!x = Some (PUB base pt ty) -&gt;
        lred (Evar x ty) pct te m
             (Eloc (Lmem base pt Full) ty) te m ps ps
    | red_var_global: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">ty</span> <span class="nv">pct</span> <span class="nv">base</span> <span class="nv">bound</span> <span class="nv">pt</span> <span class="nv">gv</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        e!x = None -&gt;
        Genv.find_symbol ge x = Some (SymGlob base bound pt gv) -&gt;
        lred (Evar x ty) pct te m
             (Eloc (Lmem base pt Full) ty) te m ps ps
    | red_func: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">pct</span> <span class="nv">b</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        e!x = None -&gt;
        Genv.find_symbol ge x = Some (SymIFun _ b pt) -&gt;
        lred (Evar x ty) pct te m
             (Eloc (Lifun b pt) ty) te m ps ps
    | red_ext_func: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">pct</span> <span class="nv">ef</span> <span class="nv">tyargs</span> <span class="nv">tyres</span> <span class="nv">cc</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        e!x = None -&gt;
        Genv.find_symbol ge x = Some (SymEFun _ ef tyargs tyres cc pt) -&gt;
        lred (Evar x ty) pct te m
             (Eloc (Lefun ef tyargs tyres cc pt) ty) te m ps ps
    | red_builtin: <span class="kr">forall</span> <span class="nv">ef</span> <span class="nv">tyargs</span> <span class="nv">cc</span> <span class="nv">ty</span> <span class="nv">pct</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        lred (Ebuiltin ef tyargs cc ty) pct te m
             (Eloc (Lefun ef tyargs Tany64 cc def_tag) ty) te m ps ps
    | red_deref: <span class="kr">forall</span> <span class="nv">v</span> <span class="nv">p</span> <span class="nv">vt</span> <span class="nv">ty1</span> <span class="nv">ty</span> <span class="nv">pct</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        sem_cast v ty1 ty1 tt = Some (Vptr p) -&gt;
        lred (Ederef (<span class="kn">Eval</span> (v,vt) ty1) ty) pct te m
             (Eloc (Lmem p vt Full) ty) te m ps ps
    | red_field_struct: <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">pt&#39;</span> <span class="nv">id</span> <span class="nv">co</span> <span class="nv">a</span> <span class="nv">f</span> <span class="nv">ty</span> <span class="nv">pct</span> <span class="nv">delta</span> <span class="nv">bf</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ce!id = Some co -&gt;
        field_offset ce f (co_members co) = OK (delta, bf) -&gt;
        FieldT l ce pct pt ty id ps0 = (Success pt&#39;,ps1) -&gt;
        lred (Efield (<span class="kn">Eval</span> (Vptr p, pt) (Tstruct id a)) f ty) pct te m
             (Eloc (Lmem (off p (Int64.repr delta)) pt&#39; bf) ty) te m ps0 ps1
    | red_field_union: <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">pt&#39;</span> <span class="nv">id</span> <span class="nv">co</span> <span class="nv">a</span> <span class="nv">f</span> <span class="nv">ty</span> <span class="nv">pct</span> <span class="nv">delta</span> <span class="nv">bf</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ce!id = Some co -&gt;
        union_field_offset ce f (co_members co) = OK (delta, bf) -&gt;
        FieldT l ce pct pt ty id ps0 = (Success pt&#39;,ps1) -&gt;
        lred (Efield (<span class="kn">Eval</span> (Vptr p, pt) (Tunion id a)) f ty) pct te m
             (Eloc (Lmem (off p (Int64.repr delta)) pt&#39; bf) ty) te m ps0 ps1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">lfailred</span>: expr -&gt;  control_tag -&gt; trace -&gt;  FailureClass -&gt;
                        pstate-&gt; pstate -&gt; <span class="kt">Prop</span> :=
    | failred_field_struct: <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">id</span> <span class="nv">co</span> <span class="nv">a</span> <span class="nv">f</span> <span class="nv">ty</span> <span class="nv">pct</span> <span class="nv">delta</span> <span class="nv">bf</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ce!id = Some co -&gt;
        field_offset ce f (co_members co) = OK (delta, bf) -&gt;
        FieldT l ce pct pt ty id ps0 = (<span class="kn">Fail</span> failure, ps1) -&gt;
        lfailred (Efield (<span class="kn">Eval</span> (Vptr p, pt) (Tstruct id a)) f ty) pct E0
                failure ps0 ps1
    | failred_field_union: <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">id</span> <span class="nv">co</span> <span class="nv">a</span> <span class="nv">f</span> <span class="nv">ty</span> <span class="nv">pct</span> <span class="nv">delta</span> <span class="nv">bf</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ce!id = Some co -&gt;
        union_field_offset ce f (co_members co) = OK (delta, bf) -&gt;
        FieldT l ce pct pt ty id ps0 = (<span class="kn">Fail</span> failure, ps1) -&gt;
        lfailred (Efield (<span class="kn">Eval</span> (Vptr p, pt) (Tunion id a)) f ty) pct E0
                 failure ps0 ps1
    .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Head reductions for r-values *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">rred</span> (<span class="nv">pct</span>:control_tag) :
      expr -&gt; tenv -&gt; mem -&gt; trace -&gt; control_tag -&gt;
      expr -&gt; tenv -&gt; mem -&gt; pstate -&gt; pstate -&gt; <span class="kt">Prop</span> :=
    | red_const: <span class="kr">forall</span> <span class="nv">v</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">vt&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ConstT l pct ps0 = (Success vt&#39;,ps1) -&gt;
        rred pct (Econst v ty) te m E0 pct (<span class="kn">Eval</span> (v,vt&#39;) ty) te m ps0 ps1
    | red_rvalof_mem: <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">lts</span> <span class="nv">bf</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">v</span> <span class="nv">vts</span> <span class="nv">vt&#39;&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        deref_loc ty m p pt bf tr &lt;&lt;ps0&gt;&gt; (Success (v, vts, lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        (vt &lt;- CoalesceT l vts;;
         vt&#39; &lt;- LoadT l pct pt vt (concretize p) lts;;
         AccessT l pct vt&#39;) ps1 = (Success vt&#39;&#39;,ps2) -&gt;
        rred pct (Evalof (Eloc (Lmem p pt bf) ty) ty) te m tr
             pct (<span class="kn">Eval</span> (v,vt&#39;&#39;) ty) te m ps0 ps2
    | red_rvalof_ifun: <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        rred pct (Evalof (Eloc (Lifun b pt) ty) ty) te m E0
             pct (<span class="kn">Eval</span> (Vfptr b, pt) ty) te m ps ps
    | red_rvalof_efun: <span class="kr">forall</span> <span class="nv">ef</span> <span class="nv">tyargs</span> <span class="nv">tyres</span> <span class="nv">cc</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        rred pct (Evalof (Eloc (Lefun ef tyargs tyres cc pt) ty) ty) te m E0
             pct (<span class="kn">Eval</span> (Vefptr ef tyargs tyres cc, pt) ty) te m ps ps
    | red_rvalof_tmp: <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">vt&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        te!b = Some (v,vt) -&gt;
        AccessT l pct vt ps0 = (Success vt&#39;,ps1) -&gt;
        rred pct (Evalof (Eloc (Ltmp b) ty) ty) te m E0
             pct (<span class="kn">Eval</span> (v,vt&#39;) ty) te m ps0 ps1
    | red_addrof_loc: <span class="kr">forall</span> <span class="nv">ofs</span> <span class="nv">pt</span> <span class="nv">ty1</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        rred pct (Eaddrof (Eloc (Lmem ofs pt Full) ty1) ty) te m E0
             pct (<span class="kn">Eval</span> (Vptr ofs, pt) ty) te m ps ps
    | red_addrof_fptr: <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        rred pct (Eaddrof (Eloc (Lifun b pt) ty) ty) te m E0
             pct (<span class="kn">Eval</span> (Vfptr b, pt) ty) te m ps ps
    | red_addrof_efptr: <span class="kr">forall</span> <span class="nv">ef</span> <span class="nv">tyargs</span> <span class="nv">tyres</span> <span class="nv">cc</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        rred pct (Eaddrof (Eloc (Lefun ef tyargs tyres cc pt) ty) ty) te m E0
             pct (<span class="kn">Eval</span> (Vefptr ef tyargs tyres cc, pt) ty) te m ps ps
    | red_unop: <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">pct&#39;</span> <span class="nv">vt</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        sem_unary_operation op v1 ty1 m = Some v -&gt;
        UnopT l op pct vt1 ps0 = (Success (pct&#39;, vt), ps1) -&gt;
        rred pct (Eunop op (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0
             pct&#39; (<span class="kn">Eval</span> (v,vt) ty) te m ps0 ps1
    | red_binop: <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">vt&#39;</span> <span class="nv">pct&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        sem_binary_operation ce op v1 ty1 v2 ty2 tt = Some v -&gt;
        BinopT l op pct vt1 vt2 ps0 = (Success (pct&#39;, vt&#39;), ps1) -&gt;
        rred pct (Ebinop op (<span class="kn">Eval</span> (v1,vt1) ty1) (<span class="kn">Eval</span> (v2,vt2) ty2) ty) te m E0
             pct&#39; (<span class="kn">Eval</span> (v,vt&#39;) ty) te m ps0 ps1
    | red_cast_int_int: <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">vt&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty1 &lt;&gt; Tpointer ty&#39; attr) -&gt;
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty &lt;&gt; Tpointer ty&#39; attr) -&gt;
        sem_cast v1 ty1 ty tt = Some v -&gt;
        IICastT l pct vt1 ty ps0 = (Success vt&#39;,ps1) -&gt;
        rred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0
             pct (<span class="kn">Eval</span> (v,vt&#39;) ty) te m ps0 ps1
    | red_cast_int_ptr: <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">p</span> <span class="nv">tr</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">lts</span> <span class="nv">pt&#39;</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty1 &lt;&gt; Tpointer ty&#39; attr) -&gt;
        ty = Tpointer ty&#39; attr -&gt;
        sem_cast v1 ty1 ty tt = Some (Vptr p) -&gt;
        ~ Vnullptr (Vptr p) -&gt;
        deref_loc ty m p vt1 Full tr &lt;&lt;ps0&gt;&gt; (Success ((v2,vt2), lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        IPCastT l pct vt1 (Some lts) ty ps1 = (Success pt&#39;, ps2) -&gt;
        rred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m tr
             pct (<span class="kn">Eval</span> ((Vptr p),pt&#39;) ty) te m ps0 ps2
    <span class="c">(* null pointers are special, do not try to deref, but they can be cast for checks *)</span>
    | red_cast_int_nullptr: <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">p</span> <span class="nv">pt&#39;</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty1 &lt;&gt; Tpointer ty&#39; attr) -&gt;
        ty = Tpointer ty&#39; attr -&gt;
        sem_cast v1 ty1 ty tt = Some (Vptr p) -&gt;
        Vnullptr (Vptr p) -&gt;
        IPCastT l pct vt1 None ty ps0 = (Success pt&#39;, ps1) -&gt;
        rred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0
            pct (<span class="kn">Eval</span> ((Vptr p),pt&#39;) ty) te m ps0 ps1
    | red_cast_ptr_int: <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">vt&#39;</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ty1 = Tpointer ty&#39; attr -&gt;
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty &lt;&gt; Tpointer ty&#39; attr) -&gt;
        sem_cast v1 ty1 ty tt = Some v -&gt;
        PICastT l pct vt1 None ty ps0 = (Success vt&#39;,ps1) -&gt;
        rred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0
            pct (<span class="kn">Eval</span> (v,vt&#39;) ty) te m ps0 ps1
    | red_cast_ptr_ptr: <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">p</span> <span class="nv">tr</span>
                               <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">lts</span> <span class="nv">ty1&#39;</span> <span class="nv">attr1</span> <span class="nv">ty&#39;</span> <span class="nv">attr2</span> <span class="nv">pt&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        ty1 = Tpointer ty1&#39; attr1 -&gt;
        ty = Tpointer ty&#39; attr2 -&gt;
        sem_cast v1 ty1 ty tt = Some (Vptr p) -&gt;
        ~ Vnullptr (Vptr p) -&gt;
        deref_loc ty m p vt1 Full tr &lt;&lt;ps0&gt;&gt; (Success ((v2,vt2), lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        PPCastT l pct vt1 (Some lts) ty ps1 = (Success pt&#39;,ps2) -&gt;
        rred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m tr
             pct (<span class="kn">Eval</span> (Vptr p,pt&#39;) ty) te m ps0 ps2
    | red_cast_ptr_nullptr: <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">p</span>
          <span class="nv">ty1&#39;</span> <span class="nv">attr1</span> <span class="nv">ty&#39;</span> <span class="nv">attr2</span> <span class="nv">pt&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ty1 = Tpointer ty1&#39; attr1 -&gt;
        ty = Tpointer ty&#39; attr2 -&gt;
        sem_cast v1 ty1 ty tt = Some (Vptr p) -&gt;
        Vnullptr (Vptr p) -&gt;
        PPCastT l pct vt1 None ty ps0 = (Success pt&#39;,ps1) -&gt;
        rred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0
             pct (<span class="kn">Eval</span> (Vptr p,pt&#39;) ty) te m ps0 ps1
    | red_seqand_true: <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">r2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">pct&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        bool_val v1 ty1 m = Some true -&gt;
        ExprSplitT l pct vt1 ps0 = (Success pct&#39;,ps1) -&gt;
        rred pct (Eseqand (<span class="kn">Eval</span> (v1,vt1) ty1) r2 ty) te m E0
             pct&#39; (Eparen r2 type_bool ty) te m ps0 ps1
    | red_seqand_false: <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">r2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">pct&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        bool_val v1 ty1 m = Some false -&gt;
        ExprSplitT l pct vt1 ps0 = (Success pct&#39;,ps1) -&gt;
        rred pct (Eseqand (<span class="kn">Eval</span> (v1,vt1) ty1) r2 ty) te m E0
             pct&#39; (<span class="kn">Eval</span> (Vint Int.zero, vt1) ty) te m ps0 ps1
    | red_seqor_true: <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">r2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">pct&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        bool_val v1 ty1 m = Some true -&gt;
        ExprSplitT l pct vt1 ps0 = (Success pct&#39;, ps1) -&gt;
        rred pct (Eseqor (<span class="kn">Eval</span> (v1,vt1) ty1) r2 ty) te m E0
             pct&#39; (<span class="kn">Eval</span> (Vint Int.one, vt1) ty) te m ps0 ps1
    | red_seqor_false: <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">r2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">pct&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        bool_val v1 ty1 m = Some false -&gt;
        ExprSplitT l pct vt1 ps0 = (Success pct&#39;,ps1) -&gt;
        rred pct (Eseqor (<span class="kn">Eval</span> (v1,vt1) ty1) r2 ty) te m E0
             pct&#39; (Eparen r2 type_bool ty) te m ps0 ps1
    | red_condition: <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">ty</span> <span class="nv">b</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">pct&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        bool_val v1 ty1 m = Some b -&gt;
        ExprSplitT l pct vt1 ps0 = (Success pct&#39;,ps1) -&gt;
        rred pct (Econdition (<span class="kn">Eval</span> (v1,vt1) ty1) r1 r2 ty) te m E0
             pct&#39; (Eparen (<span class="kr">if</span> b <span class="kr">then</span> r1 <span class="kr">else</span> r2) ty ty) te m ps0 ps1
    | red_sizeof: <span class="kr">forall</span> <span class="nv">ty1</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">vt&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ConstT l pct ps0 = (Success vt&#39;,ps1) -&gt;
        rred pct (Esizeof ty1 ty) te m E0
             pct (<span class="kn">Eval</span> (Vlong (Int64.repr (sizeof ce ty1)), vt&#39;) ty) te m ps0 ps1
    | red_alignof: <span class="kr">forall</span> <span class="nv">ty1</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">vt&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ConstT l pct ps0 = (Success vt&#39;,ps1) -&gt;
        rred pct (Ealignof ty1 ty) te m E0
        pct (<span class="kn">Eval</span> (Vlong (Int64.repr (alignof ce ty1)), vt&#39;) ty) te m ps0 ps1
    | red_assign_mem: <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">ty1</span> <span class="nv">pt</span> <span class="nv">bf</span> <span class="nv">v1</span> <span class="nv">vts</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">t1</span> <span class="nv">t2</span> <span class="nv">m&#39;</span> <span class="nv">v&#39;</span>
                             <span class="nv">pct&#39;&#39;</span> <span class="nv">vt&#39;&#39;</span> <span class="nv">v&#39;&#39;</span> <span class="nv">vt&#39;&#39;&#39;</span> <span class="nv">lts</span> <span class="nv">lts&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span> <span class="nv">ps3</span>,
        sem_cast v2 ty2 ty1 tt = Some v&#39; -&gt;
        deref_loc ty1 m p pt bf t1 &lt;&lt;ps0&gt;&gt; (Success (v1, vts, lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        (&#39;(pct&#39;,vt&#39;) &lt;- AssignT l pct (EffectiveT l vts) vt2;;
        StoreT l pct&#39; pt vt&#39; (concretize p) lts) ps1 = (Success (pct&#39;&#39;, vt&#39;&#39;, lts&#39;),ps2) -&gt;
        assign_loc ty1 m p pt lts&#39; bf (v&#39;,vt&#39;&#39;) t2 &lt;&lt;ps2&gt;&gt; (Success (m&#39;, (v&#39;&#39;,vt&#39;&#39;&#39;))) &lt;&lt;ps3&gt;&gt; -&gt;
        rred pct (Eassign (Eloc (Lmem p pt bf) ty1) (<span class="kn">Eval</span> (v2, vt2) ty2) ty1) te m (t1++t2)
             pct&#39;&#39; (<span class="kn">Eval</span> (v&#39;&#39;,vt&#39;&#39;&#39;) ty1) te m&#39; ps0 ps3
    | red_assign_tmp: <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">ty1</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">te&#39;</span> <span class="nv">v</span> <span class="nv">pct&#39;</span> <span class="nv">vt&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        te!b = Some (v1,vt1) -&gt;
        sem_cast v2 ty2 ty1 tt = Some v -&gt;
        te&#39; = PTree.<span class="nb">set</span> b (v,vt&#39;) te -&gt;
        AssignT l pct vt1 vt2 ps0 = (Success (pct&#39;,vt&#39;),ps1) -&gt;
        rred pct (Eassign (Eloc (Ltmp b) ty1) (<span class="kn">Eval</span> (v2, vt2) ty2) ty1) te m E0
             pct&#39; (<span class="kn">Eval</span> (v,vt&#39;) ty1) te&#39; m ps0 ps1
    | red_assignop_mem: <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">ty1</span> <span class="nv">bf</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">tyres</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">t</span>
                               <span class="nv">v1</span> <span class="nv">vts</span> <span class="nv">vt1&#39;&#39;</span> <span class="nv">lts</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        deref_loc ty1 m p pt bf t &lt;&lt;ps0&gt;&gt; (Success (v1, vts, lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        (vt1 &lt;- CoalesceT l vts;;
         vt1&#39; &lt;- LoadT l pct pt vt1 (concretize p) lts;;
         AccessT l pct vt1&#39;) ps1 = (Success vt1&#39;&#39;,ps2) -&gt;
        rred pct (Eassignop op (Eloc (Lmem p pt bf) ty1) (<span class="kn">Eval</span> (v2,vt2) ty2) tyres ty1) te m t
             pct (Eassign (Eloc (Lmem p pt bf) ty1)
                          (Ebinop op (<span class="kn">Eval</span> (v1,vt1&#39;&#39;) ty1) (<span class="kn">Eval</span> (v2,vt2) ty2) tyres) ty1) te m ps0 ps2
    | red_assignop_tmp: <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">b</span> <span class="nv">ty1</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">tyres</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">vt1&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        te!b = Some (v1,vt1) -&gt;
        AccessT l pct vt1 ps0 = (Success vt1&#39;,ps1) -&gt;
        rred pct (Eassignop op (Eloc (Ltmp b) ty1) (<span class="kn">Eval</span> (v2,vt2) ty2) tyres ty1) te m E0
             pct (Eassign (Eloc (Ltmp b) ty1)
                          (Ebinop op (<span class="kn">Eval</span> (v1,vt1&#39;) ty1) (<span class="kn">Eval</span> (v2,vt2) ty2) tyres) ty1) te m ps0 ps1
    | red_assignop_ifun: <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">b</span> <span class="nv">pt</span> <span class="nv">ty1</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">tyres</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        rred pct (Eassignop op (Eloc (Lifun b pt) ty1) (<span class="kn">Eval</span> (v2,vt2) ty2) tyres ty1) te m E0
             pct (Eassign (Eloc (Lifun b pt) ty1)
                          (Ebinop op (<span class="kn">Eval</span> (Vfptr b,pt) ty1) (<span class="kn">Eval</span> (v2,vt2) ty2) tyres) ty1) te m ps ps
    | red_assignop_efun: <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">ef</span> <span class="nv">tyargs</span> <span class="nv">tyres</span> <span class="nv">cc</span> <span class="nv">pt</span> <span class="nv">ty1</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        rred pct (Eassignop op (Eloc (Lefun ef tyargs tyres cc pt) ty1)
                            (<span class="kn">Eval</span> (v2,vt2) ty2) ty ty1) te m E0
             pct (Eassign (Eloc (Lefun ef tyargs tyres cc pt) ty1)
                          (Ebinop op (<span class="kn">Eval</span> (Vefptr ef tyargs tyres cc,pt) ty1)
                                  (<span class="kn">Eval</span> (v2,vt2) ty2) ty) ty1) te m ps ps
    | red_postincr_mem: <span class="kr">forall</span> <span class="nv">id</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">bf</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">t</span> <span class="nv">v</span> <span class="nv">vts</span> <span class="nv">vt&#39;&#39;</span> <span class="nv">lts</span> <span class="nv">op</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        deref_loc ty m p pt bf t &lt;&lt;ps0&gt;&gt; (Success (v, vts, lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        op = <span class="kr">match</span> id <span class="kr">with</span> Incr =&gt; Oadd | Decr =&gt; Osub <span class="kr">end</span> -&gt;
        (vt &lt;- CoalesceT l vts;;
         vt&#39; &lt;- LoadT l pct pt vt (concretize p) lts;;
         AccessT l pct vt&#39;) ps1 = (Success vt&#39;&#39;,ps2) -&gt;
        rred pct (Epostincr id (Eloc (Lmem p pt bf) ty) ty) te m t
             pct (Ecomma (Eassign (Eloc (Lmem p pt bf) ty)
                                  (Ebinop op (<span class="kn">Eval</span> (v,vt&#39;&#39;) ty)
                                          (Econst (Vint Int.one) type_int32s)
                                          (incrdecr_type ty))
                                  ty)
                         (<span class="kn">Eval</span> (v,vt&#39;&#39;) ty) ty) te m ps0 ps2
    | red_postincr_tmp: <span class="kr">forall</span> <span class="nv">id</span> <span class="nv">b</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">vt&#39;</span> <span class="nv">op</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        te!b = Some (v,vt) -&gt;
        op = <span class="kr">match</span> id <span class="kr">with</span> Incr =&gt; Oadd | Decr =&gt; Osub <span class="kr">end</span> -&gt;
        AccessT l pct vt ps0 = (Success vt&#39;, ps1) -&gt;
        rred pct (Epostincr id (Eloc (Ltmp b) ty) ty) te m E0
             pct (Ecomma (Eassign (Eloc (Ltmp b) ty)
                                  (Ebinop op (<span class="kn">Eval</span> (v,vt&#39;) ty)
                                          (Econst (Vint Int.one) type_int32s)
                                          (incrdecr_type ty))
                                  ty)
                         (<span class="kn">Eval</span> (v,vt&#39;) ty) ty) te m ps0 ps1
    | red_postincr_ifun: <span class="kr">forall</span> <span class="nv">id</span> <span class="nv">b</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">op</span> <span class="nv">ps</span>,
        op = <span class="kr">match</span> id <span class="kr">with</span> Incr =&gt; Oadd | Decr =&gt; Osub <span class="kr">end</span> -&gt;
        rred pct (Epostincr id (Eloc (Lifun b pt) ty) ty) te m E0
             pct (Ecomma (Eassign (Eloc (Lifun b pt) ty)
                                  (Ebinop op (<span class="kn">Eval</span> (Vfptr b, pt) ty)
                                          (Econst (Vint Int.one) type_int32s)
                                          (incrdecr_type ty))
                                  ty)
                         (<span class="kn">Eval</span> (Vfptr b,pt) ty) ty) te m ps ps
    | red_postincr_efun: <span class="kr">forall</span> <span class="nv">id</span> <span class="nv">ef</span> <span class="nv">tyargs</span> <span class="nv">tyres</span> <span class="nv">cc</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">op</span> <span class="nv">ps</span>,
        op = <span class="kr">match</span> id <span class="kr">with</span> Incr =&gt; Oadd | Decr =&gt; Osub <span class="kr">end</span> -&gt;
        rred pct (Epostincr id (Eloc (Lefun ef tyargs tyres cc pt) ty) ty) te m E0
             pct (Ecomma (Eassign (Eloc (Lefun ef tyargs tyres cc pt) ty)
                                  (Ebinop op (<span class="kn">Eval</span> (Vefptr ef tyargs tyres cc, pt) ty)
                                          (Econst (Vint Int.one) type_int32s)
                                          (incrdecr_type ty))
                                  ty)
                         (<span class="kn">Eval</span> (Vefptr ef tyargs tyres cc,pt) ty) ty) te m ps ps
    | red_comma: <span class="kr">forall</span> <span class="nv">v</span> <span class="nv">ty1</span> <span class="nv">r2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span>,
        typeof r2 = ty -&gt;
        rred pct (Ecomma (<span class="kn">Eval</span> v ty1) r2 ty) te m E0
             pct r2 te m ps ps
    | red_paren: <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">ty2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">pct&#39;</span> <span class="nv">vt&#39;</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        sem_cast v1 ty1 ty2 tt = Some v -&gt;
        ExprJoinT l pct vt1 ps0 = (Success (pct&#39;, vt&#39;),ps1) -&gt;
        rred pct (Eparen (<span class="kn">Eval</span> (v1,vt1) ty1) ty2 ty) te m E0
             pct&#39; (<span class="kn">Eval</span> (v,vt&#39;) ty) te m ps0 ps1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="sd">(** Failstops for r-values *)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">rfailred</span> (<span class="nv">pct</span>:control_tag) :
      expr -&gt; tenv -&gt; mem -&gt; trace -&gt; FailureClass -&gt; pstate -&gt; pstate -&gt; <span class="kt">Prop</span> :=
    | failred_const:
      <span class="kr">forall</span> <span class="nv">v</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">failure</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span>,
        ConstT l pct ps = (<span class="kn">Fail</span> failure, ps&#39;) -&gt;
        rfailred pct (Econst v ty) te m E0 failure ps ps&#39;
    | failred_rvalof_mem0:
      <span class="kr">forall</span> <span class="nv">ofs</span> <span class="nv">pt</span> <span class="nv">bf</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        deref_loc ty m ofs pt bf tr &lt;&lt;ps0&gt;&gt; (<span class="kn">Fail</span> failure) &lt;&lt;ps1&gt;&gt; -&gt;
        rfailred pct (Evalof (Eloc (Lmem ofs pt bf) ty) ty) te m tr failure ps0 ps1
    | failred_rvalof_mem1:
      <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">lts</span> <span class="nv">bf</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">v</span> <span class="nv">vts</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        deref_loc ty m p pt bf tr &lt;&lt;ps0&gt;&gt; (Success (v, vts, lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        (vt &lt;- CoalesceT l vts;;
        vt&#39; &lt;- LoadT l pct pt vt (concretize p) lts;;
        AccessT l pct vt&#39;) ps1 = (<span class="kn">Fail</span> failure, ps2) -&gt;
        rfailred pct (Evalof (Eloc (Lmem p pt bf) ty) ty) te m tr failure ps0 ps2
    | failred_rvalof_tmp:
      <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        te!b = Some (v,vt) -&gt;
        AccessT l pct vt ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Evalof (Eloc (Ltmp b) ty) ty) te m E0 failure ps0 ps1
    | failred_unop:
      <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        sem_unary_operation op v1 ty1 m = Some v -&gt;
        UnopT l op pct vt1 ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Eunop op (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0 failure ps0 ps1
    | failred_binop:
      <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        sem_binary_operation ce op v1 ty1 v2 ty2 tt = Some v -&gt;
        BinopT l op pct vt1 vt2 ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Ebinop op (<span class="kn">Eval</span> (v1,vt1) ty1) (<span class="kn">Eval</span> (v2,vt2) ty2) ty) te m E0 failure ps0 ps1
    | failred_seqand:
      <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">r2</span> <span class="nv">ty</span> <span class="nv">b</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        bool_val v1 ty1 m = Some b -&gt;
        ExprSplitT l pct vt1 ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Eseqand (<span class="kn">Eval</span> (v1,vt1) ty1) r2 ty) te m E0 failure ps0 ps1
    | failred_seqor:
      <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">r2</span> <span class="nv">ty</span> <span class="nv">b</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        bool_val v1 ty1 m = Some b -&gt;
        ExprSplitT l pct vt1 ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Eseqor (<span class="kn">Eval</span> (v1,vt1) ty1) r2 ty) te m E0 failure ps0 ps1
    | failred_condition:
      <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">r1</span> <span class="nv">r2</span> <span class="nv">ty</span> <span class="nv">b</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        bool_val v1 ty1 m = Some b -&gt;
        ExprSplitT l pct vt1 ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Econdition (<span class="kn">Eval</span> (v1,vt1) ty1) r1 r2 ty) te m E0 failure ps0 ps1
    | failred_sizeof:
      <span class="kr">forall</span> <span class="nv">ty1</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ConstT l pct ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Esizeof ty1 ty) te m E0 failure ps0 ps1
    | failred_alignof:
      <span class="kr">forall</span> <span class="nv">ty1</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ConstT l pct ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Ealignof ty1 ty) te m E0 failure ps0 ps1
    | failred_assign_mem0:
      <span class="kr">forall</span> <span class="nv">ofs</span> <span class="nv">ty1</span> <span class="nv">pt</span> <span class="nv">bf</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">t1</span> <span class="nv">v&#39;</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        sem_cast v2 ty2 ty1 tt = Some v&#39; -&gt;
        deref_loc ty1 m ofs pt bf t1 &lt;&lt;ps0&gt;&gt; (<span class="kn">Fail</span> failure) &lt;&lt;ps1&gt;&gt; -&gt;
        rfailred pct (Eassign (Eloc (Lmem ofs pt bf) ty1)
                              (<span class="kn">Eval</span> (v2, vt2) ty2) ty1) te m t1 failure ps0 ps1
    | failred_assign_mem1:
      <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">ty1</span> <span class="nv">pt</span> <span class="nv">bf</span> <span class="nv">v1</span> <span class="nv">vts</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">t1</span> <span class="nv">v&#39;</span> <span class="nv">lts</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        sem_cast v2 ty2 ty1 tt = Some v&#39; -&gt;
        deref_loc ty1 m p pt bf t1 &lt;&lt;ps0&gt;&gt; (Success (v1, vts, lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        (&#39;(pct&#39;,vt&#39;) &lt;- AssignT l pct (EffectiveT l vts) vt2;;
         StoreT l pct&#39; pt vt&#39; (concretize p) lts) ps1 = (<span class="kn">Fail</span> failure,ps2) -&gt;
        rfailred pct (Eassign (Eloc (Lmem p pt bf) ty1) (<span class="kn">Eval</span> (v2, vt2) ty2) ty1) te m t1 failure ps0 ps2
    | failred_assign_mem2:
      <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">ty1</span> <span class="nv">pt</span> <span class="nv">bf</span> <span class="nv">v1</span> <span class="nv">vts</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">t1</span> <span class="nv">v&#39;</span> <span class="nv">lts</span> <span class="nv">pct&#39;&#39;</span> <span class="nv">vt&#39;&#39;</span> <span class="nv">lts&#39;</span> <span class="nv">t2</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span> <span class="nv">ps3</span>,
        sem_cast v2 ty2 ty1 tt = Some v&#39; -&gt;
        deref_loc ty1 m p pt bf t1 &lt;&lt;ps0&gt;&gt; (Success (v1, vts, lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        (&#39;(pct&#39;,vt&#39;) &lt;- AssignT l pct (EffectiveT l vts) vt2;;
         StoreT l pct&#39; pt vt&#39; (concretize p) lts) ps1 = (Success (pct&#39;&#39;,vt&#39;&#39;,lts&#39;),ps2) -&gt;
        assign_loc ty1 m p pt lts&#39; bf (v&#39;,vt&#39;&#39;) t2 &lt;&lt;ps2&gt;&gt; (<span class="kn">Fail</span> failure) &lt;&lt;ps3&gt;&gt; -&gt;
        rfailred pct (Eassign (Eloc (Lmem p pt bf) ty1) (<span class="kn">Eval</span> (v2, vt2) ty2) ty1) te m (t1++t2) failure ps0 ps3
    | failred_assign_tmp:
      <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">ty1</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        te!b = Some (v1,vt1) -&gt;
        sem_cast v2 ty2 ty1 tt = Some v -&gt;
        AssignT l pct vt1 vt2 ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Eassign (Eloc (Ltmp b) ty1) (<span class="kn">Eval</span> (v2, vt2) ty2) ty1) te m E0 failure ps0 ps1
    | failred_assignop_mem0:
      <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">ofs</span> <span class="nv">pt</span> <span class="nv">ty1</span> <span class="nv">bf</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">tyres</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">t1</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        deref_loc ty1 m ofs pt bf t1 &lt;&lt;ps0&gt;&gt; (<span class="kn">Fail</span> failure) &lt;&lt;ps1&gt;&gt; -&gt;
        rfailred pct (Eassignop op (Eloc (Lmem ofs pt bf) ty1)
                                (<span class="kn">Eval</span> (v2,vt2) ty2) tyres ty1) te m t1 failure ps0 ps1
    | failred_assignop_mem1:
      <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">ty1</span> <span class="nv">bf</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">tyres</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">t1</span> <span class="nv">v1</span> <span class="nv">vts</span> <span class="nv">lts</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        deref_loc ty1 m p pt bf t1 &lt;&lt;ps0&gt;&gt; (Success (v1,vts, lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        (vt1 &lt;- CoalesceT l vts;;
         vt1&#39; &lt;- LoadT l pct pt vt1 (concretize p) lts;;
         AccessT l pct vt1&#39;) ps1 = (<span class="kn">Fail</span> failure,ps2) -&gt;
        rfailred pct (Eassignop op (Eloc (Lmem p pt bf) ty1)
                                (<span class="kn">Eval</span> (v2,vt2) ty2) tyres ty1) te m t1 failure ps0 ps2
    | failred_assignop_tmp:
      <span class="kr">forall</span> <span class="nv">op</span> <span class="nv">b</span> <span class="nv">ty1</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">ty2</span> <span class="nv">tyres</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        te!b = Some (v1,vt1) -&gt;
        AccessT l pct vt1 ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Eassignop op (Eloc (Ltmp b) ty1) (<span class="kn">Eval</span> (v2,vt2) ty2) tyres ty1) te m E0 failure ps0 ps1
    | failred_postincr_mem0:
      <span class="kr">forall</span> <span class="nv">id</span> <span class="nv">ofs</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">bf</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        deref_loc ty m ofs pt bf tr &lt;&lt;ps0&gt;&gt; (<span class="kn">Fail</span> failure) &lt;&lt;ps1&gt;&gt; -&gt;
        rfailred pct (Epostincr id (Eloc (Lmem ofs pt bf) ty) ty) te m tr failure ps0 ps1
    | failred_postincr_mem1:
      <span class="kr">forall</span> <span class="nv">id</span> <span class="nv">p</span> <span class="nv">pt</span> <span class="nv">ty</span> <span class="nv">bf</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">v</span> <span class="nv">vts</span> <span class="nv">lts</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        deref_loc ty m p pt bf tr &lt;&lt;ps0&gt;&gt; (Success (v,vts, lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        (vt &lt;- CoalesceT l vts;;
         vt&#39; &lt;- LoadT l pct pt vt (concretize p) lts;;
         AccessT l pct vt&#39;) ps1 = (<span class="kn">Fail</span> failure,ps2) -&gt;
        rfailred pct (Epostincr id (Eloc (Lmem p pt bf) ty) ty) te m tr failure ps0 ps2
    | failred_postincr_tmp:
      <span class="kr">forall</span> <span class="nv">id</span> <span class="nv">b</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        te!b = Some (v,vt) -&gt;
        AccessT l pct vt ps0 = (<span class="kn">Fail</span> failure, ps1) -&gt;
        rfailred pct (Epostincr id (Eloc (Ltmp b) ty) ty) te m E0 failure ps0 ps1
    | failred_paren:
      <span class="kr">forall</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">ty2</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        sem_cast v1 ty1 ty2 tt = Some v -&gt;
        ExprJoinT l pct vt1 ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
        rfailred pct (Eparen (<span class="kn">Eval</span> (v1,vt1) ty1) ty2 ty) te m E0 failure ps0 ps1
    | failred_cast_int_int:
      <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty1 &lt;&gt; Tpointer ty&#39; attr) -&gt;
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty &lt;&gt; Tpointer ty&#39; attr) -&gt;
        sem_cast v1 ty1 ty tt = Some v -&gt;
        IICastT l pct vt1 ty ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt; 
        rfailred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0 failure ps0 ps1
    | failred_cast_int_ptr:
      <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">p</span> <span class="nv">tr</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">lts</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty1 &lt;&gt; Tpointer ty&#39; attr) -&gt;
        ty = Tpointer ty&#39; attr -&gt;
        sem_cast v1 ty1 ty tt = Some (Vptr p) -&gt;
        ~ Vnullptr (Vptr p) -&gt;
        deref_loc ty m p vt1 Full tr &lt;&lt;ps0&gt;&gt; (Success ((v2,vt2), lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        IPCastT l pct vt1 (Some lts) ty ps1 = (<span class="kn">Fail</span> failure,ps2) -&gt;
        rfailred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m tr failure ps0 ps2
    | failred_cast_ptr_int:
      <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        ty1 = Tpointer ty&#39; attr -&gt;
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty &lt;&gt; Tpointer ty&#39; attr) -&gt;
        sem_cast v1 ty1 ty tt = Some v -&gt;
        PICastT l pct vt1 None ty ps0 = (<span class="kn">Fail</span> failure, ps1) -&gt;
        rfailred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0 failure ps0 ps1
    | failred_cast_ptr_ptr:
      <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">p</span> <span class="nv">tr</span> <span class="nv">v2</span> <span class="nv">vt2</span> <span class="nv">lts</span> <span class="nv">ty1&#39;</span> <span class="nv">attr1</span> <span class="nv">ty&#39;</span> <span class="nv">attr2</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span>,
        ty1 = Tpointer ty1&#39; attr1 -&gt;
        ty = Tpointer ty&#39; attr2 -&gt;
        sem_cast v1 ty1 ty tt = Some (Vptr p) -&gt;
        ~ Vnullptr (Vptr p) -&gt;
        deref_loc ty m p vt1 Full tr &lt;&lt;ps0&gt;&gt; (Success ((v2,vt2), lts)) &lt;&lt;ps1&gt;&gt; -&gt;
        PPCastT l pct vt1 (Some lts) ty ps1 = (<span class="kn">Fail</span> failure,ps2) -&gt;
        rfailred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m tr failure ps0 ps2
    | failred_cast_int_nullptr: <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">p</span> <span class="nv">failure</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        (<span class="kr">forall</span> <span class="nv">ty&#39;</span> <span class="nv">attr</span>, ty1 &lt;&gt; Tpointer ty&#39; attr) -&gt;
        ty = Tpointer ty&#39; attr -&gt;
        sem_cast v1 ty1 ty tt = Some (Vptr p) -&gt;
        Vnullptr (Vptr p) -&gt;
        IPCastT l pct vt1 None ty ps0 = (<span class="kn">Fail</span> failure, ps1) -&gt;
        rfailred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0 failure ps0 ps1 
    | failred_cast_ptr_nullptr: <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">v1</span> <span class="nv">vt1</span> <span class="nv">ty1</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">p</span> <span class="nv">ty1&#39;</span> <span class="nv">attr1</span> <span class="nv">ty&#39;</span> <span class="nv">attr2</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
      ty1 = Tpointer ty1&#39; attr1 -&gt;
      ty = Tpointer ty&#39; attr2 -&gt;
      sem_cast v1 ty1 ty tt = Some (Vptr p) -&gt;
      Vnullptr (Vptr p) -&gt;
      PPCastT l pct vt1 None ty ps0 = (<span class="kn">Fail</span> failure,ps1) -&gt;
      rfailred pct (Ecast (<span class="kn">Eval</span> (v1,vt1) ty1) ty) te m E0 failure ps0 ps1 

    | red_call_internal_fail: <span class="kr">forall</span> <span class="nv">ty</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">b</span> <span class="nv">fd</span> <span class="nv">vft</span> <span class="nv">tyf</span> <span class="nv">tyargs</span> <span class="nv">tyres</span> <span class="nv">cconv</span> <span class="nv">el</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        Genv.find_funct ge (Vfptr b) = Some fd -&gt;
        type_of_fundef fd = Tfunction tyargs tyres cconv -&gt;
        classify_fun tyf = fun_case_f tyargs tyres cconv -&gt;
        cast_arguments l pct ps0 vft tt el tyargs ps1 (<span class="kn">Fail</span> failure) -&gt;
        rfailred pct (Ecall (<span class="kn">Eval</span> (Vfptr b,vft) tyf) el ty) te m E0 failure ps0 ps1
    | red_call_external_fail: <span class="kr">forall</span> <span class="nv">vft</span> <span class="nv">tyf</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tyargs</span> <span class="nv">tyres</span> <span class="nv">cconv</span> <span class="nv">el</span> <span class="nv">ty</span> <span class="nv">ef</span> <span class="nv">failure</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        cast_arguments l pct ps0 vft tt el tyargs ps1 (<span class="kn">Fail</span> failure) -&gt;
        rfailred pct (Ecall (<span class="kn">Eval</span> (Vefptr ef tyargs tyres cconv,vft) tyf) el ty) te m E0
                 failure ps0 ps1
    .</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">callred</span>: control_tag -&gt; expr -&gt; mem -&gt; fundef -&gt;
                       val_tag -&gt; list atom -&gt; type -&gt; control_tag -&gt;
                       pstate -&gt; pstate -&gt; <span class="kt">Prop</span> :=
    | red_call_internal: <span class="kr">forall</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">b</span> <span class="nv">vft</span> <span class="nv">tyf</span> <span class="nv">m</span> <span class="nv">tyargs</span> <span class="nv">tyres</span> <span class="nv">cconv</span> <span class="nv">el</span> <span class="nv">ty</span> <span class="nv">fd</span> <span class="nv">vargs</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        Genv.find_funct ge (Vfptr b) = Some fd -&gt;
        type_of_fundef fd = Tfunction tyargs tyres cconv -&gt;
        classify_fun tyf = fun_case_f tyargs tyres cconv -&gt;
        cast_arguments l pct ps0 vft tt el tyargs ps1 (Success (pct&#39;,vargs)) -&gt;
        callred pct (Ecall (<span class="kn">Eval</span> (Vfptr b,vft) tyf) el ty) m
                fd vft vargs ty pct&#39; ps0 ps1
    | red_call_external: <span class="kr">forall</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">vft</span> <span class="nv">tyf</span> <span class="nv">m</span> <span class="nv">tyargs</span> <span class="nv">tyres</span> <span class="nv">cconv</span> <span class="nv">el</span> <span class="nv">ty</span> <span class="nv">ef</span> <span class="nv">vargs</span> <span class="nv">ps0</span> <span class="nv">ps1</span>,
        cast_arguments l pct ps0 vft tt el tyargs ps1 (Success (pct&#39;,vargs)) -&gt;
        callred pct (Ecall (<span class="kn">Eval</span> (Vefptr ef tyargs tyres cconv,vft) tyf) el ty)
                m (External ef tyargs ty cconv) vft vargs ty pct&#39; ps0 ps1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">context</span>: kind -&gt; kind -&gt; (expr -&gt; expr) -&gt; <span class="kt">Prop</span> :=
    | ctx_top: <span class="kr">forall</span> <span class="nv">k</span>,
        <span class="kp">context</span> k k (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x)
    | ctx_deref: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k LV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Ederef (C x) ty)
    | ctx_field: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">f</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k LV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Efield (C x) f ty)
    | ctx_rvalof: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k LV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Evalof (C x) ty)
    | ctx_addrof: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k LV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Eaddrof (C x) ty)
    | ctx_unop: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">op</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Eunop op (C x) ty)
    | ctx_binop_left: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">op</span> <span class="nv">e2</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Ebinop op (C x) e2 ty)
    | ctx_binop_right: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">op</span> <span class="nv">e1</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Ebinop op e1 (C x) ty)
    | ctx_cast: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Ecast (C x) ty)
    | ctx_seqand: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">r2</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Eseqand (C x) r2 ty)
    | ctx_seqor: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">r2</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Eseqor (C x) r2 ty)
    | ctx_condition: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">r2</span> <span class="nv">r3</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Econdition (C x) r2 r3 ty)
    | ctx_assign_left: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">e2</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k LV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Eassign (C x) e2 ty)
    | ctx_assign_right: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">e1</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Eassign e1 (C x) ty)
    | ctx_assignop_left: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">op</span> <span class="nv">e2</span> <span class="nv">tyres</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k LV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Eassignop op (C x) e2 tyres ty)
    | ctx_assignop_right: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">op</span> <span class="nv">e1</span> <span class="nv">tyres</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Eassignop op e1 (C x) tyres ty)
    | ctx_postincr: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">id</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k LV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Epostincr id (C x) ty)
    | ctx_call_left: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">el</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Ecall (C x) el ty)
    | ctx_call_right: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">e1</span> <span class="nv">ty</span>,
        contextlist k C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Ecall e1 (C x) ty)
    | ctx_comma: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">e2</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Ecomma (C x) e2 ty)
    | ctx_paren: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">tycast</span> <span class="nv">ty</span>,
        <span class="kp">context</span> k RV C -&gt; <span class="kp">context</span> k RV (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Eparen (C x) tycast ty)

    <span class="kr">with</span> contextlist: kind -&gt; (expr -&gt; exprlist) -&gt; <span class="kt">Prop</span> :=
    | ctx_list_head: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">el</span>,
        <span class="kp">context</span> k RV C -&gt; contextlist k (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Econs (C x) el)
    | ctx_list_tail: <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">e1</span>,
        contextlist k C -&gt; contextlist k (<span class="kr">fun</span> <span class="nv">x</span> =&gt; Econs e1 (C x)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">imm_safe</span>: kind -&gt; expr -&gt; pstate -&gt; control_tag -&gt; tenv -&gt; mem -&gt; <span class="kt">Prop</span> :=
  | imm_safe_val: <span class="kr">forall</span> <span class="nv">v</span> <span class="nv">ty</span> <span class="nv">s</span> <span class="nv">pct</span> <span class="nv">te</span> <span class="nv">m</span>,
      imm_safe RV (<span class="kn">Eval</span> v ty) s pct te m
  | imm_safe_loc: <span class="kr">forall</span> <span class="nv">lk</span> <span class="nv">ty</span> <span class="nv">s</span> <span class="nv">pct</span> <span class="nv">te</span> <span class="nv">m</span>,
      imm_safe LV (Eloc lk ty) s pct te m
  | imm_safe_lred: <span class="kr">forall</span> <span class="nv">pct</span> <span class="nv">to</span> <span class="nv">C</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">e&#39;</span> <span class="nv">te&#39;</span> <span class="nv">m&#39;</span> <span class="nv">s</span> <span class="nv">s&#39;</span>,
      lred e pct te m e&#39; te&#39; m&#39; s s&#39; -&gt;
      <span class="kp">context</span> LV to C -&gt;
      imm_safe to (C e) s pct te m
  | imm_safe_lfailred: <span class="kr">forall</span> <span class="nv">pct</span> <span class="nv">to</span> <span class="nv">C</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">failure</span> <span class="nv">s</span> <span class="nv">s&#39;</span>,
      lfailred e pct tr failure s s&#39; -&gt;
      <span class="kp">context</span> LV to C -&gt;
      imm_safe to (C e) s pct te m                 
  | imm_safe_rred: <span class="kr">forall</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">to</span> <span class="nv">C</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">t</span> <span class="nv">e&#39;</span> <span class="nv">te&#39;</span> <span class="nv">m&#39;</span> <span class="nv">s</span> <span class="nv">s&#39;</span>,
      rred pct e te m t pct&#39; e&#39; te&#39; m&#39; s s&#39; -&gt;
      <span class="kp">context</span> RV to C -&gt;
      imm_safe to (C e) s pct te m
  | imm_safe_rfailred: <span class="kr">forall</span> <span class="nv">pct</span> <span class="nv">to</span> <span class="nv">C</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">failure</span> <span class="nv">s</span> <span class="nv">s&#39;</span>,
      rfailred pct e te m tr failure s s&#39; -&gt;
      <span class="kp">context</span> RV to C -&gt;
      imm_safe to (C e) s pct te m
  | imm_safe_callred: <span class="kr">forall</span> <span class="nv">pct</span> <span class="nv">to</span> <span class="nv">C</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">fd</span> <span class="nv">fpt</span> <span class="nv">args</span> <span class="nv">ty</span> <span class="nv">pct&#39;</span> <span class="nv">s</span> <span class="nv">s&#39;</span>,
      callred pct e m fd fpt args ty pct&#39; s s&#39; -&gt;
      <span class="kp">context</span> RV to C -&gt;
      imm_safe to (C e) s pct te m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">not_stuck</span> (<span class="nv">e</span>: expr) (<span class="nv">te</span>: tenv) (<span class="nv">m</span>: mem) : <span class="kt">Prop</span> :=
      <span class="kr">forall</span> <span class="nv">k</span> <span class="nv">C</span> <span class="nv">e&#39;</span> <span class="nv">ps</span> <span class="nv">pct</span>,
        <span class="kp">context</span> k RV C -&gt; e = C e&#39; -&gt; imm_safe k e&#39; ps pct te m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
    <span class="c">(* Property that safe expressions must have the right kind*)</span>
</span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">expr_kind</span> (<span class="nv">a</span>: expr) : kind :=
      <span class="kr">match</span> a <span class="kr">with</span>
      | Eloc _ _ =&gt; LV
      | Evar _ _ =&gt; LV
      | Ederef _ _ =&gt; LV
      | Efield _ _ _ =&gt; LV
      | Ebuiltin _ _ _ _ =&gt; LV
      | _ =&gt; RV
      <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk0"><span class="kn">Lemma</span> <span class="nf">lred_kind</span>:
    <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">PCT</span> <span class="nv">a&#39;</span> <span class="nv">te&#39;</span> <span class="nv">m&#39;</span>,
      lred a te m PCT a&#39; te&#39; m&#39; ps ps&#39;-&gt;
      expr_kind a = LV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : expr) (<span class="nv">te</span> : control_tag) (<span class="nv">m</span> : tenv)
  (<span class="nv">ps</span> <span class="nv">ps&#39;</span> : pstate) (<span class="nv">PCT</span> : mem) (<span class="nv">a&#39;</span> : expr)
  (<span class="nv">te&#39;</span> : tenv) (<span class="nv">m&#39;</span> : mem),
lred a te m PCT a&#39; te&#39; m&#39; ps ps&#39; -&gt; expr_kind a = LV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : expr) (<span class="nv">te</span> : control_tag) (<span class="nv">m</span> : tenv)
  (<span class="nv">ps</span> <span class="nv">ps&#39;</span> : pstate) (<span class="nv">PCT</span> : mem) (<span class="nv">a&#39;</span> : expr)
  (<span class="nv">te&#39;</span> : tenv) (<span class="nv">m&#39;</span> : mem),
lred a te m PCT a&#39; te&#39; m&#39; ps ps&#39; -&gt; expr_kind a = LV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk2"><span class="kn">Lemma</span> <span class="nf">lfailred_kind</span>:
    <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">pstate</span> <span class="nv">PCT</span> <span class="nv">tr</span> <span class="nv">msg</span> <span class="nv">failure</span>,
      lfailred a pstate PCT tr msg failure -&gt;
      expr_kind a = LV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : expr) (<span class="nv">pstate0</span> : control_tag)
  (<span class="nv">PCT</span> : trace) (<span class="nv">tr</span> : FailureClass)
  (<span class="nv">msg</span> <span class="nv">failure</span> : pstate),
lfailred a pstate0 PCT tr msg failure -&gt;
expr_kind a = LV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : expr) (<span class="nv">pstate0</span> : control_tag)
  (<span class="nv">PCT</span> : trace) (<span class="nv">tr</span> : FailureClass)
  (<span class="nv">msg</span> <span class="nv">failure</span> : pstate),
lfailred a pstate0 PCT tr msg failure -&gt;
expr_kind a = LV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk4"><span class="kn">Lemma</span> <span class="nf">rred_kind</span>:
    <span class="kr">forall</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">PCT</span> <span class="nv">a</span> <span class="nv">m</span> <span class="nv">e</span> <span class="nv">t</span> <span class="nv">PCT&#39;</span> <span class="nv">a&#39;</span> <span class="nv">e&#39;</span> <span class="nv">m&#39;</span>,
      rred PCT a e m t PCT&#39; a&#39; e&#39; m&#39; ps ps&#39; -&gt;
      expr_kind a = RV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ps</span> <span class="nv">ps&#39;</span> : pstate) (<span class="nv">PCT</span> : control_tag)
  (<span class="nv">a</span> : expr) (<span class="nv">m</span> : mem) (<span class="nv">e</span> : tenv) (<span class="nv">t</span> : trace)
  (<span class="nv">PCT&#39;</span> : control_tag) (<span class="nv">a&#39;</span> : expr) (<span class="nv">e&#39;</span> : tenv)
  (<span class="nv">m&#39;</span> : mem),
rred PCT a e m t PCT&#39; a&#39; e&#39; m&#39; ps ps&#39; -&gt;
expr_kind a = RV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ps</span> <span class="nv">ps&#39;</span> : pstate) (<span class="nv">PCT</span> : control_tag)
  (<span class="nv">a</span> : expr) (<span class="nv">m</span> : mem) (<span class="nv">e</span> : tenv) (<span class="nv">t</span> : trace)
  (<span class="nv">PCT&#39;</span> : control_tag) (<span class="nv">a&#39;</span> : expr) (<span class="nv">e&#39;</span> : tenv)
  (<span class="nv">m&#39;</span> : mem),
rred PCT a e m t PCT&#39; a&#39; e&#39; m&#39; ps ps&#39; -&gt;
expr_kind a = RV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk6"><span class="kn">Lemma</span> <span class="nf">rfailred_kind</span>:
    <span class="kr">forall</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">PCT</span> <span class="nv">a</span> <span class="nv">m</span> <span class="nv">e</span> <span class="nv">tr</span> <span class="nv">failure</span>,
      rfailred PCT a e m tr failure ps ps&#39; -&gt;
      expr_kind a = RV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ps</span> <span class="nv">ps&#39;</span> : pstate) (<span class="nv">PCT</span> : control_tag)
  (<span class="nv">a</span> : expr) (<span class="nv">m</span> : mem) (<span class="nv">e</span> : tenv) (<span class="nv">tr</span> : trace)
  (<span class="nv">failure</span> : FailureClass),
rfailred PCT a e m tr failure ps ps&#39; -&gt;
expr_kind a = RV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ps</span> <span class="nv">ps&#39;</span> : pstate) (<span class="nv">PCT</span> : control_tag)
  (<span class="nv">a</span> : expr) (<span class="nv">m</span> : mem) (<span class="nv">e</span> : tenv) (<span class="nv">tr</span> : trace)
  (<span class="nv">failure</span> : FailureClass),
rfailred PCT a e m tr failure ps ps&#39; -&gt;
expr_kind a = RV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk8"><span class="kn">Lemma</span> <span class="nf">callred_kind</span>:
    <span class="kr">forall</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">ft</span> <span class="nv">a</span> <span class="nv">m</span> <span class="nv">pct&#39;</span> <span class="nv">fd</span> <span class="nv">args</span> <span class="nv">ty</span>,
      callred pct a m ft fd args ty pct&#39; ps ps&#39; -&gt;
      expr_kind a = RV.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ps</span> <span class="nv">ps&#39;</span> : pstate) (<span class="nv">pct</span> : control_tag)
  (<span class="nv">ft</span> : fundef) (<span class="nv">a</span> : expr) (<span class="nv">m</span> : mem)
  (<span class="nv">pct&#39;</span> : control_tag) (<span class="nv">fd</span> : val_tag)
  (<span class="nv">args</span> : list atom) (<span class="nv">ty</span> : type),
callred pct a m ft fd args ty pct&#39; ps ps&#39; -&gt;
expr_kind a = RV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk9"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">ps</span> <span class="nv">ps&#39;</span> : pstate) (<span class="nv">pct</span> : control_tag)
  (<span class="nv">ft</span> : fundef) (<span class="nv">a</span> : expr) (<span class="nv">m</span> : mem)
  (<span class="nv">pct&#39;</span> : control_tag) (<span class="nv">fd</span> : val_tag)
  (<span class="nv">args</span> : list atom) (<span class="nv">ty</span> : type),
callred pct a m ft fd args ty pct&#39; ps ps&#39; -&gt;
expr_kind a = RV</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chka"><span class="kn">Lemma</span> <span class="nf">context_kind</span>:
    <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">from</span> <span class="nv">to</span> <span class="nv">C</span>, <span class="kp">context</span> <span class="kn">from</span> to C -&gt;
      expr_kind a = <span class="kn">from</span> -&gt; expr_kind (C a) = to.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : expr) (<span class="nv">from</span> <span class="nv">to</span> : kind) (<span class="nv">C</span> : expr -&gt; expr),
<span class="kp">context</span> <span class="kn">from</span> to C -&gt;
expr_kind a = <span class="kn">from</span> -&gt; expr_kind (C a) = to</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chkb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : expr) (<span class="nv">from</span> <span class="nv">to</span> : kind) (<span class="nv">C</span> : expr -&gt; expr),
<span class="kp">context</span> <span class="kn">from</span> to C -&gt;
expr_kind a = <span class="kn">from</span> -&gt; expr_kind (C a) = to</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> <span class="mi">1</span>; <span class="nb">intros</span>; <span class="nb">simpl</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chkc"><span class="kn">Lemma</span> <span class="nf">imm_safe_kind</span>:
    <span class="kr">forall</span> <span class="nv">te</span> <span class="nv">k</span> <span class="nv">a</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">m</span>,
      imm_safe k a ps pct te m -&gt;
      expr_kind a = k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">te</span> : tenv) (<span class="nv">k</span> : kind) (<span class="nv">a</span> : expr) (<span class="nv">ps</span> : pstate)
  (<span class="nv">pct</span> : control_tag) (<span class="nv">m</span> : mem),
imm_safe k a ps pct te m -&gt; expr_kind a = k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">te</span> : tenv) (<span class="nv">k</span> : kind) (<span class="nv">a</span> : expr) (<span class="nv">ps</span> : pstate)
  (<span class="nv">pct</span> : control_tag) (<span class="nv">m</span> : mem),
imm_safe k a ps pct te m -&gt; expr_kind a = k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chke"><span class="nb">induction</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind (<span class="kn">Eval</span> v ty) = RV</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>lk</var><span class="hyp-type"><b>: </b><span>loc_kind</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br></div><label class="goal-separator" for="csem-v-chkf"><hr></label><div class="goal-conclusion">expr_kind (Eloc lk ty) = LV</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lred e0 pct te m e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk10"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lfailred e0 pct tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk11"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct, pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rred pct e0 te m t0 pct&#39; e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk12"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk13"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk14"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk15"><span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>lk</var><span class="hyp-type"><b>: </b><span>loc_kind</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind (Eloc lk ty) = LV</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lred e0 pct te m e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk16"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lfailred e0 pct tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk17"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk18" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct, pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rred pct e0 te m t0 pct&#39; e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk18"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk19" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk19"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk1a"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk1b"><span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lred e0 pct te m e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk1c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lfailred e0 pct tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk1c"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk1d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct, pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rred pct e0 te m t0 pct&#39; e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk1d"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk1e"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk1f"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk20"><span class="nb">eapply</span> context_kind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lred e0 pct te m e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind e0 = LV</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lfailred e0 pct tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk21"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct, pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rred pct e0 te m t0 pct&#39; e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk22"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk23" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk23"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk24"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk25"><span class="nb">eapply</span> lred_kind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lfailred e0 pct tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct, pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rred pct e0 te m t0 pct&#39; e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk26"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk27"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk28"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk29"><span class="nb">eapply</span> context_kind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>lfailred e0 pct tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> LV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind e0 = LV</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct, pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rred pct e0 te m t0 pct&#39; e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk2a"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk2b"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk2c"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk2d"><span class="nb">eapply</span> lfailred_kind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct, pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rred pct e0 te m t0 pct&#39; e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk2e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk2e"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk2f"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk30"><span class="nb">eapply</span> context_kind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct, pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>e'</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te'</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m'</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rred pct e0 te m t0 pct&#39; e&#39; te&#39; m&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind e0 = RV</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk31" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk31"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><input class="alectryon-extra-goal-toggle" id="csem-v-chk32" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk32"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk33"><span class="nb">eapply</span> rred_kind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk34"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk35"><span class="nb">eapply</span> context_kind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>tr</var><span class="hyp-type"><b>: </b><span>trace</span></span></span><br><span><var>failure</var><span class="hyp-type"><b>: </b><span>FailureClass</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>rfailred pct e0 te m tr failure s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind e0 = RV</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><label class="goal-separator" for="csem-v-chk36"><hr></label><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk37"><span class="nb">eapply</span> rfailred_kind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind (C e0) = to</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk38"><span class="nb">eapply</span> context_kind; <span class="nb">eauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>to</var><span class="hyp-type"><b>: </b><span>kind</span></span></span><br><span><var>C</var><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span><br><span><var>e0</var><span class="hyp-type"><b>: </b><span>expr</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>fd</var><span class="hyp-type"><b>: </b><span>fundef</span></span></span><br><span><var>fpt</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list atom</span></span></span><br><span><var>ty</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>pct'</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>s, s'</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>callred pct e0 m fd fpt args ty pct&#39; s s&#39;</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kp">context</span> RV to C</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">expr_kind e0 = RV</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> callred_kind; <span class="nb">eauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">EXPR</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">cont</span>: <span class="kt">Type</span> :=
| Kstop: cont
| Kdo: cont -&gt; cont       <span class="sd">(**r [Kdo k] = after [x] in [x;] *)</span>
| Kseq: statement -&gt; cont -&gt; cont    <span class="sd">(**r [Kseq s2 k] = after [s1] in [s1;s2] *)</span>
| Kifthenelse: statement -&gt; statement -&gt; option label -&gt; cont -&gt; cont     <span class="sd">(**r [Kifthenelse s1 s2 k] = after [x] in [if (x) { s1 } else { s2 }] *)</span>
| Kwhile1: expr -&gt; statement -&gt; option label -&gt; Cabs.loc -&gt; cont -&gt; cont      <span class="sd">(**r [Kwhile1 x s k] = after [x] in [while(x) s] *)</span>
| Kwhile2: expr -&gt; statement -&gt; option label -&gt; Cabs.loc -&gt; cont -&gt; cont      <span class="sd">(**r [Kwhile x s k] = after [s] in [while (x) s] *)</span>
| Kdowhile1: expr -&gt; statement -&gt; option label -&gt; Cabs.loc -&gt; cont -&gt; cont    <span class="sd">(**r [Kdowhile1 x s k] = after [s] in [do s while (x)] *)</span>
| Kdowhile2: expr -&gt; statement -&gt; option label -&gt; Cabs.loc -&gt; cont -&gt; cont    <span class="sd">(**r [Kdowhile2 x s k] = after [x] in [do s while (x)] *)</span>
| Kfor2: expr -&gt; statement -&gt; statement -&gt; option label -&gt; Cabs.loc -&gt; cont -&gt; cont   <span class="sd">(**r [Kfor2 e2 e3 s k] = after [e2] in [for(e1;e2;e3) s] *)</span>
| Kfor3: expr -&gt; statement -&gt; statement -&gt; option label -&gt; Cabs.loc -&gt; cont -&gt; cont   <span class="sd">(**r [Kfor3 e2 e3 s k] = after [s] in [for(e1;e2;e3) s] *)</span>
| Kfor4: expr -&gt; statement -&gt; statement -&gt; option label -&gt; Cabs.loc -&gt; cont -&gt; cont   <span class="sd">(**r [Kfor4 e2 e3 s k] = after [e3] in [for(e1;e2;e3) s] *)</span>
| Kswitch1: labeled_statements -&gt; cont -&gt; cont     <span class="sd">(**r [Kswitch1 ls k] = after [e] in [switch(e) { ls }] *)</span>
| Kswitch2: cont -&gt; cont       <span class="sd">(**r catches [break] statements arising out of [switch] *)</span>
| Kreturn: cont -&gt; cont        <span class="sd">(**r [Kreturn k] = after [e] in [return e;] *)</span>
| Kcall: function -&gt;           <span class="sd">(**r calling function *)</span>
         env -&gt;                <span class="sd">(**r local env of calling function *)</span>
         tenv -&gt;               <span class="sd">(**r temp env of calling function *)</span>
         Cabs.loc -&gt;           <span class="sd">(**r location before call *)</span>
         control_tag -&gt;        <span class="sd">(**r PC tag before call *)</span>
         val_tag -&gt;            <span class="sd">(**r Tag on function pointer that was called *)</span>
         (expr -&gt; expr) -&gt;     <span class="sd">(**r context of the call *)</span>
         type -&gt;               <span class="sd">(**r type of call expression *)</span>
         cont -&gt; cont.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">call_cont</span> (<span class="nv">k</span>: cont) : cont :=
  <span class="kr">match</span> k <span class="kr">with</span>
  | Kstop =&gt; k
  | Kdo k =&gt; k
  | Kseq s k =&gt; call_cont k
  | Kifthenelse s1 s2 _ k =&gt; call_cont k
  | Kwhile1 e s _ _ k =&gt; call_cont k
  | Kwhile2 e s _ _ k =&gt; call_cont k
  | Kdowhile1 e s _ _ k =&gt; call_cont k
  | Kdowhile2 e s _ _ k =&gt; call_cont k
  | Kfor2 e2 e3 s _ _ k =&gt; call_cont k
  | Kfor3 e2 e3 s _ _ k =&gt; call_cont k
  | Kfor4 e2 e3 s _ _ k =&gt; call_cont k
  | Kswitch1 ls k =&gt; call_cont k
  | Kswitch2 k =&gt; call_cont k
  | Kreturn k =&gt; call_cont k
  | Kcall _ _ _ _ _ _ _ _ _ =&gt; k
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_call_cont</span> (<span class="nv">k</span>: cont) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> k <span class="kr">with</span>
  | Kstop =&gt; <span class="kt">True</span>
  | Kcall _ _ _ _ _ _ _ _ _ =&gt; <span class="kt">True</span>
  | _ =&gt; <span class="kt">False</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">state&#39;</span>: <span class="kt">Type</span> :=
| State                               <span class="sd">(**r execution of a statement *)</span>
    (f: function)
    (ps: pstate)
    (pct: control_tag)
    (s: statement)
    (k: cont)
    (e: env)
    (te: tenv)
    (m: mem) : state&#39;
| ExprState                           <span class="sd">(**r reduction of an expression *)</span>
    (f: function)
    (l: Cabs.loc)
    (ps: pstate)
    (pct: control_tag)
    (r: expr)
    (k: cont)
    (e: env)
    (te: tenv)
    (m: mem) : state&#39;
| Callstate                           <span class="sd">(**r calling a function *)</span>
    (fd: fundef)                      <span class="c">(* callee that has just been entered *)</span>
    (l: Cabs.loc)
    (ps: pstate)
    (pct: control_tag)
    (fpt: val_tag)
    (args: list atom)
    (k: cont)
    (m: mem) : state&#39;
| Returnstate                         <span class="sd">(**r returning from a function *)</span>
    (fd: fundef)                      <span class="c">(* callee that is now returning *)</span>
    (l: Cabs.loc)
    (ps: pstate)
    (pct: control_tag)
    (res: atom)
    (k: cont)
    (m: mem) : state&#39;
| Stuckstate                          <span class="sd">(**r undefined behavior occurred *)</span>
| Failstop                            <span class="sd">(**r tag failure occurred, propagate details *)</span>
    (failure: FailureClass)
    (lg: logs): state&#39;
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">state</span> := state&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Find the statement and manufacture the continuation</span>
<span class="sd">  corresponding to a label. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">find_label</span> (<span class="nv">lbl</span>: label) (<span class="nv">s</span>: statement) (<span class="nv">k</span>: cont)
                    {<span class="nv">struct</span> <span class="nv">s</span>}: option (statement * cont) :=
  <span class="kr">match</span> s <span class="kr">with</span>
  | Ssequence s1 s2 =&gt;
      <span class="kr">match</span> find_label lbl s1 (Kseq s2 k) <span class="kr">with</span>
      | Some sk =&gt; Some sk
      | None =&gt; find_label lbl s2 k
      <span class="kr">end</span>
  | Sifthenelse a s1 s2 olbl loc =&gt;
      <span class="kr">match</span> find_label lbl s1 k <span class="kr">with</span>
      | Some sk =&gt; Some sk
      | None =&gt; find_label lbl s2 k
      <span class="kr">end</span>
  | Swhile a s1 olbl loc =&gt;
      find_label lbl s1 (Kwhile2 a s1 olbl loc k)
  | Sdowhile a s1 olbl loc =&gt;
      find_label lbl s1 (Kdowhile1 a s1 olbl loc k)
  | Sfor a1 a2 a3 s1 olbl loc =&gt;
      <span class="kr">match</span> find_label lbl a1 (Kseq (Sfor Sskip a2 a3 s1 olbl loc) k) <span class="kr">with</span>
      | Some sk =&gt; Some sk
      | None =&gt;
          <span class="kr">match</span> find_label lbl s1 (Kfor3 a2 a3 s1 olbl loc k) <span class="kr">with</span>
          | Some sk =&gt; Some sk
          | None =&gt; find_label lbl a3 (Kfor4 a2 a3 s1 olbl loc k)
          <span class="kr">end</span>
      <span class="kr">end</span>
  | Sswitch e sl loc =&gt;
      find_label_ls lbl sl (Kswitch2 k)
  | Slabel lbl&#39; s&#39; =&gt;
      <span class="kr">if</span> ident_eq lbl lbl&#39; <span class="kr">then</span> Some(s&#39;, k) <span class="kr">else</span> find_label lbl s&#39; k
  | _ =&gt; None
  <span class="kr">end</span>

<span class="kr">with</span> find_label_ls (lbl: label) (sl: labeled_statements) (k: cont)
                    {<span class="kr">struct</span> sl}: option (statement * cont) :=
  <span class="kr">match</span> sl <span class="kr">with</span>
  | LSnil =&gt; None
  | LScons _ s sl&#39; =&gt;
      <span class="kr">match</span> find_label lbl s (Kseq (seq_of_labeled_statement sl&#39;) k) <span class="kr">with</span>
      | Some sk =&gt; Some sk
      | None =&gt; find_label_ls lbl sl&#39; k
      <span class="kr">end</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We separate the transition rules in two groups:</span>
<span class="sd">- one group that deals with reductions over expressions;</span>
<span class="sd">- the other group that deals with everything else: statements, function calls, etc.</span>

<span class="sd">This makes it easy to express different reduction strategies for expressions:</span>
<span class="sd">the second group of rules can be reused as is. *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">estep</span>: state -&gt; trace -&gt; state -&gt; <span class="kt">Prop</span> :=
| step_lred: <span class="kr">forall</span> <span class="nv">C</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">pct</span> <span class="nv">a</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">a&#39;</span> <span class="nv">m</span> <span class="nv">te&#39;</span> <span class="nv">m&#39;</span> <span class="nv">s</span> <span class="nv">s&#39;</span>,
    lred e l a pct te m a&#39; te&#39; m&#39; s s&#39; -&gt;
    <span class="kp">context</span> LV RV C -&gt;
    estep (ExprState f l s pct (C a) k e te m)
          E0 (ExprState f l s&#39; pct (C a&#39;) k e te&#39; m&#39;)
| step_rred: <span class="kr">forall</span> <span class="nv">C</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">a</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">a&#39;</span> <span class="nv">te&#39;</span> <span class="nv">m&#39;</span> <span class="nv">s</span> <span class="nv">s&#39;</span>,
    rred l pct a te m tr pct&#39; a&#39; te&#39; m&#39; s s&#39; -&gt;
    <span class="kp">context</span> RV RV C -&gt;
    estep (ExprState f l s pct (C a) k e te m)
          tr (ExprState f l s&#39; pct&#39; (C a&#39;) k e te&#39; m&#39;)
| step_call: <span class="kr">forall</span> <span class="nv">C</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">fpt</span> <span class="nv">a</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">fd</span> <span class="nv">vargs</span> <span class="nv">ty</span> <span class="nv">s</span> <span class="nv">s&#39;</span>,
    callred l pct a m fd fpt vargs ty pct&#39; s s&#39; -&gt;
    <span class="kp">context</span> RV RV C -&gt;
    estep (ExprState f l s pct (C a) k e te m)
          E0 (Callstate fd l s&#39; pct&#39; fpt vargs (Kcall f e te l pct fpt C ty k) m)
| step_stuck: <span class="kr">forall</span> <span class="nv">C</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">pct</span> <span class="nv">a</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">K</span> <span class="nv">s</span>,
    <span class="kp">context</span> K RV C -&gt; ~(imm_safe e l K a s pct te m) -&gt;
    estep (ExprState f l s pct (C a) k e te m)
          E0 Stuckstate
| step_lfail: <span class="kr">forall</span> <span class="nv">C</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">pct</span> <span class="nv">a</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">failure</span> <span class="nv">s</span> <span class="nv">ps</span> <span class="nv">lg</span>,
    lfailred l a pct tr failure s (ps,lg) -&gt;
    <span class="kp">context</span> LV RV C -&gt;
    estep (ExprState f l s pct (C a) k e te m)
          E0 (Failstop failure lg)
| step_rfail: <span class="kr">forall</span> <span class="nv">C</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">pct</span> <span class="nv">a</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">tr</span> <span class="nv">failure</span> <span class="nv">s</span> <span class="nv">ps</span> <span class="nv">lg</span>,
    rfailred l pct a te m tr failure s (ps,lg) -&gt;
    <span class="kp">context</span> RV RV C -&gt;
    estep (ExprState f l s pct (C a) k e te m)
          tr (Failstop failure lg).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">option_zip</span> {<span class="nv">A</span>:<span class="kt">Type</span>} {<span class="nv">B</span>:<span class="kt">Type</span>} (<span class="nv">l1</span> : list A) (<span class="nv">l2</span> : list B) : list (A*option B) :=
  <span class="kr">match</span> l1, l2 <span class="kr">with</span>
  | [], _ =&gt; []
  | h1::tl1, [] =&gt; (h1,None)::(option_zip tl1 [])
  | h1::tl1, h2::tl2 =&gt; (h1,Some h2)::(option_zip tl1 tl2)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">sstep</span>: state -&gt; trace -&gt; state -&gt; <span class="kt">Prop</span> :=
| step_do_1: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">x</span> <span class="nv">l</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sdo x l) k e te m)
          E0 (ExprState f l ps pct x (Kdo k) e te m)
| step_do_2: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">v</span> <span class="nv">ty</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> v ty) (Kdo k) e te m)
          E0 (State f ps pct Sskip k e te m)

| step_seq:  <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Ssequence s1 s2) k e te m)
          E0 (State f ps pct s1 (Kseq s2 k) e te m)
| step_skip_seq: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">s</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct Sskip (Kseq s k) e te m)
          E0 (State f ps pct s k e te m)
| step_continue_seq: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">loc</span> <span class="nv">s</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Scontinue loc) (Kseq s k) e te m)
          E0 (State f ps pct (Scontinue loc) k e te m)
| step_break_seq: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">loc</span> <span class="nv">s</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,  
    sstep (State f ps pct (Sbreak loc) (Kseq s k) e te m)
          E0 (State f ps pct (Sbreak loc) k e te m)

| step_ifthenelse_1: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">a</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sifthenelse a s1 s2 olbl l) k e te m)
          E0 (ExprState f l ps pct a (Kifthenelse s1 s2 olbl k) e te m)
| step_ifthenelse_2:  <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">b</span>,
    bool_val v ty m = Some b -&gt;
    SplitT l pct vt olbl ps = (Success pct&#39;,ps&#39;) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kifthenelse s1 s2 olbl k) e te m)
          E0 (State f ps&#39; pct&#39; (<span class="kr">if</span> b <span class="kr">then</span> s1 <span class="kr">else</span> s2) k e te m)

| step_while: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">olbl</span> <span class="nv">l</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Swhile x s olbl l) k e te m)
          E0 (ExprState f l ps pct x (Kwhile1 x s olbl l k) e te m)
| step_while_false: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    bool_val v ty m = Some false -&gt;
    SplitT l pct vt olbl ps = (Success pct&#39;,ps&#39;) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kwhile1 x s olbl l&#39; k) e te m)
          E0 (State f ps&#39; pct&#39; Sskip k e te m)
| step_while_true: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    bool_val v ty m = Some true -&gt;
    SplitT l pct vt olbl ps = (Success pct&#39;,ps&#39;) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kwhile1 x s olbl l&#39; k) e te m)
          E0 (State f ps&#39; pct&#39; s (Kwhile2 x s olbl l&#39; k) e te m)
| step_skip_while: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct Sskip (Kwhile2 x s olbl l k) e te m)
          E0 (State f ps pct (Swhile x s olbl l) k e te m)
| step_continue_while: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Scontinue l) (Kwhile2 x s olbl l&#39; k) e te m)
          E0 (State f ps pct (Swhile x s olbl l&#39;) k e te m)
| step_break_while: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sbreak l) (Kwhile2 x s olbl l&#39; k) e te m)
          E0 (State f ps pct Sskip k e te m)

| step_dowhile: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">a</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sdowhile a s olbl l) k e te m)
          E0 (State f ps pct s (Kdowhile1 a s olbl l k) e te m)
| step_skip_dowhile: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct Sskip (Kdowhile1 x s olbl l k) e te m)
          E0 (ExprState f l ps pct x (Kdowhile2 x s olbl l k) e te m)
| step_continue_dowhile: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Scontinue l) (Kdowhile1 x s olbl l&#39; k) e te m)
          E0 (ExprState f l&#39; ps pct x (Kdowhile2 x s olbl l&#39; k) e te m)
| step_dowhile_false: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    bool_val v ty m = Some false -&gt;
    SplitT l pct vt olbl ps = (Success pct&#39;, ps&#39;) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kdowhile2 x s olbl l&#39; k) e te m)
          E0 (State f ps&#39; pct&#39; Sskip k e te m)
| step_dowhile_true: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    bool_val v ty m = Some true -&gt;
    SplitT l pct vt olbl ps = (Success pct&#39;, ps&#39;) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kdowhile2 x s olbl l&#39; k) e te m)
          E0 (State f ps&#39; pct&#39; (Sdowhile x s olbl l&#39;) k e te m)
| step_break_dowhile: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">a</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sbreak l) (Kdowhile1 a s olbl l&#39; k) e te m)
          E0 (State f ps pct Sskip k e te m)

| step_for_start: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">a1</span> <span class="nv">a2</span> <span class="nv">a3</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    a1 &lt;&gt; Sskip -&gt;
    sstep (State f ps pct (Sfor a1 a2 a3 s olbl l) k e te m)
          E0 (State f ps pct a1 (Kseq (Sfor Sskip a2 a3 s olbl l) k) e te m)
| step_for: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">a2</span> <span class="nv">a3</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sfor Sskip a2 a3 s olbl l) k e te m)
          E0 (ExprState f l ps pct a2 (Kfor2 a2 a3 s olbl l k) e te m)
| step_for_false: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">a2</span> <span class="nv">a3</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    bool_val v ty m = Some false -&gt;
    SplitT l pct vt olbl ps = (Success pct&#39;,ps&#39;) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kfor2 a2 a3 s olbl l&#39; k) e te m)
          E0 (State f ps&#39; pct&#39; Sskip k e te m)
| step_for_true: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">a2</span> <span class="nv">a3</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    bool_val v ty m = Some true -&gt;
    SplitT l pct vt olbl ps = (Success pct&#39;,ps&#39;) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kfor2 a2 a3 s olbl l&#39; k) e te m)
          E0 (State f ps&#39; pct&#39; s (Kfor3 a2 a3 s olbl l&#39; k) e te m)
| step_skip_for3: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">a2</span> <span class="nv">a3</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct Sskip (Kfor3 a2 a3 s olbl l k) e te m)
          E0 (State f ps pct a3 (Kfor4 a2 a3 s olbl l k) e te m)
| step_continue_for3: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">a2</span> <span class="nv">a3</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Scontinue l) (Kfor3 a2 a3 s olbl l&#39; k) e te m)
          E0 (State f ps pct a3 (Kfor4 a2 a3 s olbl l&#39; k) e te m)
| step_break_for3: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">a2</span> <span class="nv">a3</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sbreak l) (Kfor3 a2 a3 s olbl l&#39; k) e te m)
          E0 (State f ps pct Sskip k e te m)
| step_skip_for4: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">a2</span> <span class="nv">a3</span> <span class="nv">s</span> <span class="nv">l</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct Sskip (Kfor4 a2 a3 s olbl l k) e te m)
          E0 (State f ps pct (Sfor Sskip a2 a3 s olbl l) k e te m)

| step_ifthenelse_fail:  <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">lg</span> <span class="nv">pct</span> <span class="nv">failure</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">s1</span> <span class="nv">s2</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">b</span>,
    bool_val v ty m = Some b -&gt;
    SplitT l pct vt olbl ps = (<span class="kn">Fail</span> failure, (ps&#39;,lg)) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kifthenelse s1 s2 olbl k) e te m)
          E0 (Failstop failure lg)
| step_while_fail: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">lg</span> <span class="nv">pct</span> <span class="nv">failure</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">b</span>,
    bool_val v ty m = Some b -&gt;
    SplitT l pct vt olbl ps = (<span class="kn">Fail</span> failure, (ps&#39;,lg)) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kwhile1 x s olbl l&#39; k) e te m)
          E0 (Failstop failure lg)
| step_dowhile_fail: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">lg</span> <span class="nv">pct</span> <span class="nv">failure</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">x</span> <span class="nv">s</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">b</span>,
    bool_val v ty m = Some b -&gt;
    SplitT l pct vt olbl ps = (<span class="kn">Fail</span> failure, (ps&#39;,lg)) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kdowhile2 x s olbl l&#39; k) e te m)
          E0 (Failstop failure lg)
| step_for_fail: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">lg</span> <span class="nv">pct</span> <span class="nv">failure</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">a2</span> <span class="nv">a3</span> <span class="nv">s</span> <span class="nv">l&#39;</span> <span class="nv">olbl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">b</span>,
    bool_val v ty m = Some b -&gt;
    SplitT l pct vt olbl ps = (<span class="kn">Fail</span> failure, (ps&#39;,lg)) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kfor2 a2 a3 s olbl l&#39; k) e te m)
          E0 (Failstop failure lg)

| step_return_none: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">l</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">m&#39;</span>,
    do_free_variables l pct m (variables_of_env e) ps = (Success (pct&#39;, m&#39;), ps&#39;) -&gt;
    sstep (State f ps pct (Sreturn None l) k e te m)
          E0 (Returnstate (Internal f) l ps&#39; pct&#39; (Vundef, def_tag) (call_cont k) m&#39;)
| step_return_none_fail0: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">lg</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">failure</span>,
    do_free_variables l pct m (variables_of_env e) ps = (<span class="kn">Fail</span> failure, (ps&#39;,lg)) -&gt;
    sstep (State f ps pct (Sreturn None l) k e te m)
          E0 (Failstop failure lg)
| step_return_1: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">x</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sreturn (Some x) l) k e te m)
          E0 (ExprState f l ps pct x (Kreturn k) e te m)
| step_return_2:  <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">l</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v&#39;</span> <span class="nv">m&#39;</span>,
    sem_cast v ty f.(fn_return) tt = Some v&#39; -&gt;
    do_free_variables l pct m (variables_of_env e) ps = (Success (pct&#39;, m&#39;), ps&#39;) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kreturn k) e te m)
          E0 (Returnstate (Internal f) l ps&#39; pct&#39; (v&#39;,vt) (call_cont k) m&#39;)
| step_return_fail:  <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">lg</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">ty</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v&#39;</span> <span class="nv">failure</span>,
    sem_cast v ty f.(fn_return) tt = Some v&#39; -&gt;
    do_free_variables l pct m (variables_of_env e) ps = (<span class="kn">Fail</span> failure, (ps&#39;,lg)) -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kreturn k) e te m)
          E0 (Failstop failure lg)
| step_skip_call: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    is_call_cont k -&gt;
    sstep (State f ps pct Sskip k e te m)
          E0 (State f ps pct (Sreturn None Cabs.no_loc) k e te m)

| step_switch: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">x</span> <span class="nv">sl</span> <span class="nv">l</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sswitch x sl l) k e te m)
          E0 (ExprState f l ps pct x (Kswitch1 sl k) e te m)
| step_expr_switch: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">ty</span> <span class="nv">sl</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">n</span>,
    sem_switch_arg v ty = Some n -&gt;
    sstep (ExprState f l ps pct (<span class="kn">Eval</span> (v,vt) ty) (Kswitch1 sl k) e te m)
          E0 (State f ps pct (seq_of_labeled_statement (select_switch n sl)) (Kswitch2 k) e te m)
| step_skip_switch: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct Sskip (Kswitch2 k) e te m)
          E0 (State f ps pct Sskip k e te m)
| step_break_switch: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Sbreak l) (Kswitch2 k) e te m)
          E0 (State f ps pct Sskip k e te m)
| step_continue_switch: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">l</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    sstep (State f ps pct (Scontinue l) (Kswitch2 k) e te m)
          E0 (State f ps pct (Scontinue l) k e te m)

| step_label: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">pct&#39;</span> <span class="nv">lbl</span> <span class="nv">s</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    LabelT (loc_of s) pct lbl ps = (Success pct&#39;, ps&#39;) -&gt;
    sstep (State f ps pct (Slabel lbl s) k e te m)
          E0 (State f ps&#39; pct&#39; s k e te m)
| step_label_fail: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">lg</span> <span class="nv">pct</span> <span class="nv">lbl</span> <span class="nv">failure</span> <span class="nv">s</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span>,
    LabelT (loc_of s) pct lbl ps = (<span class="kn">Fail</span> failure, (ps&#39;,lg)) -&gt;
    sstep (State f ps pct (Slabel lbl s) k e te m)
          E0 (Failstop failure lg)

| step_goto: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">lbl</span> <span class="nv">l</span> <span class="nv">k</span> <span class="nv">e</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">s&#39;</span> <span class="nv">k&#39;</span>,
    find_label lbl f.(fn_body) (call_cont k) = Some (s&#39;, k&#39;) -&gt;
    sstep (State f ps pct (Sgoto lbl l) k e te m)
          E0 (State f ps pct s&#39; k&#39; e te m)

| step_internal_function: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span> <span class="nv">ps3</span> <span class="nv">pct0</span> <span class="nv">pct1</span> <span class="nv">pct2</span> <span class="nv">pct3</span> <span class="nv">vft</span> <span class="nv">vargs</span> <span class="nv">k</span> <span class="nv">m</span> <span class="nv">e</span> <span class="nv">m&#39;</span> <span class="nv">e&#39;</span> <span class="nv">m&#39;&#39;</span>,
    list_norepet (var_names (fn_params f) ++ var_names (fn_vars f)) -&gt;
    CallT l pct0 vft ps0 = (Success pct1,ps1) -&gt;
    do_alloc_variables l pct1 empty_env m f.(fn_vars) ps1 = (Success (pct2, e, m&#39;), ps2) -&gt;
    do_init_params l pct2 e m&#39; (option_zip f.(fn_params) vargs) ps2 =
      (Success (pct3, e&#39;, m&#39;&#39;), ps3) -&gt;
    sstep (Callstate (Internal f) l ps0 pct0 vft vargs k m)
          E0 (State f ps3 pct3 f.(fn_body) k e&#39; empty_tenv m&#39;&#39;)
| step_internal_function_fail0: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">lg</span> <span class="nv">pct</span> <span class="nv">vft</span> <span class="nv">vargs</span> <span class="nv">k</span> <span class="nv">m</span> <span class="nv">failure</span>,
    list_norepet (var_names (fn_params f) ++ var_names (fn_vars f)) -&gt;
    CallT l pct vft ps0 = (<span class="kn">Fail</span> failure, (ps1,lg)) -&gt;
    sstep (Callstate (Internal f) l ps0 pct vft vargs k m)
          E0 (Failstop failure lg)
| step_internal_function_fail1: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span> <span class="nv">lg</span> <span class="nv">pct0</span> <span class="nv">pct1</span> <span class="nv">vft</span> <span class="nv">vargs</span> <span class="nv">k</span> <span class="nv">m</span> <span class="nv">failure</span>,
    list_norepet (var_names (fn_params f) ++ var_names (fn_vars f)) -&gt;
    CallT l pct0 vft ps0 = (Success pct1, ps1) -&gt;
    do_alloc_variables l pct1 empty_env m f.(fn_vars) ps1 = (<span class="kn">Fail</span> failure, (ps2,lg)) -&gt;
    sstep (Callstate (Internal f) l ps0 pct0 vft vargs k m)
          E0 (Failstop failure lg)
| step_internal_function_fail2: <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">l</span> <span class="nv">ps0</span> <span class="nv">ps1</span> <span class="nv">ps2</span> <span class="nv">ps3</span> <span class="nv">lg</span> <span class="nv">pct0</span> <span class="nv">pct1</span> <span class="nv">pct2</span> <span class="nv">vft</span> <span class="nv">vargs</span> <span class="nv">k</span> <span class="nv">m</span> <span class="nv">e</span> <span class="nv">m&#39;</span> <span class="nv">failure</span>,
    list_norepet (var_names (fn_params f) ++ var_names (fn_vars f)) -&gt;
    CallT l pct0 vft ps0 = (Success pct1, ps1) -&gt;
    do_alloc_variables l pct1 empty_env m f.(fn_vars) ps1 = (Success (pct2, e, m&#39;), ps2) -&gt;
    do_init_params l pct2 e m&#39; (option_zip f.(fn_params) vargs) ps2 = (<span class="kn">Fail</span> failure, (ps3,lg)) -&gt;
    sstep (Callstate (Internal f) l ps0 pct0 vft vargs k m)
          E0 (Failstop failure lg)

| step_external_function: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">ef</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">ps&#39;&#39;</span> <span class="nv">pct</span> <span class="nv">vft</span> <span class="nv">pct&#39;</span> <span class="nv">pct&#39;&#39;</span> <span class="nv">targs</span> <span class="nv">tres</span> <span class="nv">cc</span> <span class="nv">vargs</span> <span class="nv">k</span> <span class="nv">m</span> <span class="nv">vres</span> <span class="nv">t</span> <span class="nv">m&#39;</span>,
    ExtCallT l ef pct vft (map snd vargs) ps = (Success pct&#39;,ps&#39;) -&gt;
    external_call l ef tt ge vargs pct&#39; vft m t &lt;&lt;ps&#39;&gt;&gt; (Success (vres, pct&#39;&#39;, m&#39;)) &lt;&lt;ps&#39;&#39;&gt;&gt; -&gt;
    sstep (Callstate (External ef targs tres cc) l ps pct vft vargs k m)
          t (Returnstate (External ef targs tres cc) l ps&#39;&#39; pct&#39;&#39; vres k m&#39;)
| step_external_function_fail0: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">ef</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">vft</span> <span class="nv">targs</span> <span class="nv">tres</span> <span class="nv">cc</span> <span class="nv">vargs</span> <span class="nv">k</span> <span class="nv">m</span> <span class="nv">failure</span> <span class="nv">ps&#39;</span>,
    ExtCallT l ef pct vft (map snd vargs) ps = (<span class="kn">Fail</span> failure,ps&#39;) -&gt;
    sstep (Callstate (External ef targs tres cc) l ps pct vft vargs k m)
          E0 (Failstop failure (snd ps&#39;))
| step_external_function_fail1: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">ef</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">vft</span> <span class="nv">targs</span> <span class="nv">tres</span> <span class="nv">cc</span> <span class="nv">vargs</span> <span class="nv">k</span> <span class="nv">m</span> <span class="nv">t</span> <span class="nv">failure</span> <span class="nv">ps&#39;</span> <span class="nv">ps&#39;&#39;</span> <span class="nv">pct&#39;</span>,
    ExtCallT l ef pct vft (map snd vargs) ps = (Success pct&#39;,ps&#39;) -&gt;
    external_call l ef tt ge vargs pct&#39; vft m t &lt;&lt;ps&#39;&gt;&gt; (<span class="kn">Fail</span> failure) &lt;&lt;ps&#39;&#39;&gt;&gt; -&gt;
    sstep (Callstate (External ef targs tres cc) l ps pct vft vargs k m)
          t (Failstop failure (snd ps&#39;&#39;))

| step_returnstate: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">vt&#39;</span> <span class="nv">f</span> <span class="nv">fd</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">pct</span> <span class="nv">oldloc</span> <span class="nv">oldpct</span> <span class="nv">fpt</span> <span class="nv">pct&#39;</span> <span class="nv">e</span> <span class="nv">C</span> <span class="nv">ty</span> <span class="nv">k</span> <span class="nv">te</span> <span class="nv">m</span>,
    RetT l pct oldpct fpt vt ty ps = (Success (pct&#39;, vt&#39;), ps&#39;) -&gt;
    sstep (Returnstate fd l ps pct (v,vt) (Kcall f e te oldloc oldpct fpt C ty k) m)
          E0 (ExprState f oldloc ps&#39; pct&#39; (C (<span class="kn">Eval</span> (v,vt&#39;) ty)) k e te m)
| step_returnstate_fail: <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">v</span> <span class="nv">vt</span> <span class="nv">f</span> <span class="nv">fd</span> <span class="nv">ps</span> <span class="nv">ps&#39;</span> <span class="nv">lg</span> <span class="nv">pct</span> <span class="nv">oldloc</span> <span class="nv">oldpct</span> <span class="nv">fpt</span> <span class="nv">e</span> <span class="nv">C</span> <span class="nv">ty</span> <span class="nv">k</span> <span class="nv">te</span> <span class="nv">m</span> <span class="nv">failure</span>,
    RetT l pct oldpct fpt vt ty ps = (<span class="kn">Fail</span> failure, (ps&#39;,lg)) -&gt;
    sstep (Returnstate fd l ps pct (v,vt) (Kcall f e te oldloc oldpct fpt C ty k) m)
          E0 (Failstop failure lg)
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">step</span> (<span class="nv">S</span>: state) (<span class="nv">t</span>: trace) (<span class="nv">S&#39;</span>: state) : <span class="kt">Prop</span> :=
  estep S t S&#39; \/ sstep S t S&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">x</span> <span class="nv">y</span> : <span class="kn">ident</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">f</span> : function.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">ps</span> : pstate.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">pct</span> : control_tag.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">k</span> : cont.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">e</span> : env.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">te</span> : tenv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">m</span> : mem.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">lc</span> : Cabs.loc.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ty</span> := Tint I32 Signed noattr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">p1</span> : ptr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">pt1</span> : val_tag.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">x_pub</span> : e ! x = Some (PUB p1 pt1 ty).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">p2</span> : ptr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">pt2</span> : val_tag.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">y_pub</span> : e ! y = Some (PUB p2 pt2 ty).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">example_state1</span> : state :=
  State f ps pct
        (Sdo (Eassign (Evar x ty)
                      (Evalof (Evar y ty) ty) ty) lc)
        k e te m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">example_state2</span> : state :=
  ExprState f lc ps pct
            (Eassign (Evar x ty)
                     (Evalof (Evar y ty) ty) ty)
            (Kdo k) e te m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk39"><span class="kn">Remark</span> <span class="nf">step1</span> : step example_state1 E0 example_state2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">step example_state1 E0 example_state2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk3a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">step example_state1 E0 example_state2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk3b"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sstep example_state1 E0 example_state2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">example_state3</span> : state :=
  ExprState f lc ps pct
            (Eassign (Eloc (Lmem p1 pt1 Full) ty)
                     (Evalof (Evar y ty) ty) ty)
            (Kdo k) e te m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk3c"><span class="kn">Remark</span> <span class="nf">step2</span> : step example_state2 E0 example_state3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">step example_state2 E0 example_state3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk3d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">step example_state2 E0 example_state3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk3e"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep example_state2 E0 example_state3</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk3f"><span class="nb">unfold</span> example_state2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct
     (Eassign (Evar x ty) (Evalof (Evar y ty) ty) ty)
     (Kdo k) e te m) E0 example_state3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk40"><span class="nb">pose</span> (C := <span class="kr">fun</span> <span class="nv">l</span> =&gt; (Eassign l (Evalof (Evar y ty) ty) ty)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct
     (Eassign (Evar x ty) (Evalof (Evar y ty) ty) ty)
     (Kdo k) e te m) E0 example_state3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk41"><span class="nb">replace</span> (Eassign (Evar x ty) (Evalof (Evar y ty) ty) ty) <span class="kr">with</span>
    (C (Evar x ty)) <span class="bp">by</span> <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct (C (Evar x ty)) (Kdo k) e te
     m) E0 example_state3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk42"><span class="nb">unfold</span> example_state3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct (C (Evar x ty)) (Kdo k) e te
     m) E0
  (ExprState f lc ps pct
     (Eassign (Eloc (Lmem p1 pt1 Full) ty)
        (Evalof (Evar y ty) ty) ty) (Kdo k) e te m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk43"><span class="nb">replace</span> (Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof (Evar y ty) ty) ty) <span class="kr">with</span>
    (C (Eloc (Lmem p1 pt1 Full) ty)) <span class="bp">by</span> <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct (C (Evar x ty)) (Kdo k) e te
     m) E0
  (ExprState f lc ps pct
     (C (Eloc (Lmem p1 pt1 Full) ty)) (Kdo k) e te m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk44"><span class="nb">apply</span> step_lred.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lred e lc (Evar x ty) pct te m
  (Eloc (Lmem p1 pt1 Full) ty) te m ps ps</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><label class="goal-separator" for="csem-v-chk45"><hr></label><div class="goal-conclusion"><span class="kp">context</span> LV RV C</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk46">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lred e lc (Evar x ty) pct te m
  (Eloc (Lmem p1 pt1 Full) ty) te m ps ps</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk47"><span class="nb">apply</span> red_var_local.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e ! x = Some (PUB p1 pt1 ty)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> x_pub.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk48">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kp">context</span> LV RV C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk49"><span class="nb">apply</span> ctx_assign_left.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign l (Evalof (Evar y ty) ty) ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kp">context</span> LV LV (<span class="kr">fun</span> <span class="nv">x</span> : expr =&gt; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ctx_top.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">example_state4</span> : state :=
  ExprState f lc ps pct
            (Eassign (Eloc (Lmem p1 pt1 Full) ty)
                     (Evalof (Eloc (Lmem p2 pt2 Full) ty) ty) ty)
            (Kdo k) e te m.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk4a"><span class="kn">Remark</span> <span class="nf">step3</span> : step example_state3 E0 example_state4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">step example_state3 E0 example_state4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">step example_state3 E0 example_state4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk4c"><span class="nb">left</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep example_state3 E0 example_state4</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk4d"><span class="nb">unfold</span> example_state3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct
     (Eassign (Eloc (Lmem p1 pt1 Full) ty)
        (Evalof (Evar y ty) ty) ty) (Kdo k) e te m) E0
  example_state4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk4e"><span class="nb">pose</span> (C := <span class="kr">fun</span> <span class="nv">l</span> =&gt; (Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty) ty)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct
     (Eassign (Eloc (Lmem p1 pt1 Full) ty)
        (Evalof (Evar y ty) ty) ty) (Kdo k) e te m) E0
  example_state4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk4f"><span class="nb">replace</span> (Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof (Evar y ty) ty) ty) <span class="kr">with</span>
    (C (Evar y ty)) <span class="bp">by</span> <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct (C (Evar y ty)) (Kdo k) e te
     m) E0 example_state4</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk50"><span class="nb">unfold</span> example_state4.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct (C (Evar y ty)) (Kdo k) e te
     m) E0
  (ExprState f lc ps pct
     (Eassign (Eloc (Lmem p1 pt1 Full) ty)
        (Evalof (Eloc (Lmem p2 pt2 Full) ty) ty) ty)
     (Kdo k) e te m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk51"><span class="nb">replace</span> (Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof (Eloc (Lmem p2 pt2 Full) ty) ty) ty) <span class="kr">with</span>
    (C (Eloc (Lmem p2 pt2 Full) ty)) <span class="bp">by</span> <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">estep
  (ExprState f lc ps pct (C (Evar y ty)) (Kdo k) e te
     m) E0
  (ExprState f lc ps pct
     (C (Eloc (Lmem p2 pt2 Full) ty)) (Kdo k) e te m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk52"><span class="nb">apply</span> step_lred.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lred e lc (Evar y ty) pct te m
  (Eloc (Lmem p2 pt2 Full) ty) te m ps ps</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="csem-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><label class="goal-separator" for="csem-v-chk53"><hr></label><div class="goal-conclusion"><span class="kp">context</span> LV RV C</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk54">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">lred e lc (Evar y ty) pct te m
  (Eloc (Lmem p2 pt2 Full) ty) te m ps ps</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk55"><span class="nb">apply</span> red_var_local.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">e ! y = Some (PUB p2 pt2 ty)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> y_pub.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk56">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kp">context</span> LV RV C</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk57"><span class="nb">apply</span> ctx_assign_right.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kp">context</span> LV RV (<span class="kr">fun</span> <span class="nv">x</span> : expr =&gt; Evalof x ty)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="csem-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="csem-v-chk58"><span class="nb">apply</span> ctx_rvalof.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ge</var><span class="hyp-type"><b>: </b><span>genv</span></span></span><br><span><var>ce</var><span class="hyp-type"><b>: </b><span>composite_env</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>f</var><span class="hyp-type"><b>: </b><span>function</span></span></span><br><span><var>ps</var><span class="hyp-type"><b>: </b><span>pstate</span></span></span><br><span><var>pct</var><span class="hyp-type"><b>: </b><span>control_tag</span></span></span><br><span><var>k</var><span class="hyp-type"><b>: </b><span>cont</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>env</span></span></span><br><span><var>te</var><span class="hyp-type"><b>: </b><span>tenv</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>mem</span></span></span><br><span><var>lc</var><span class="hyp-type"><b>: </b><span>Cabs.loc</span></span></span><br><span><var>p1</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt1</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>p2</var><span class="hyp-type"><b>: </b><span>ptr</span></span></span><br><span><var>pt2</var><span class="hyp-type"><b>: </b><span>val_tag</span></span></span><br><span><var>C</var><span><span class="hyp-body"><b>:= </b><span><span class="kr">fun</span> <span class="nv">l</span> : expr =&gt;
Eassign (Eloc (Lmem p1 pt1 Full) ty) (Evalof l ty)
  ty</span></span><span class="hyp-type"><b>: </b><span>expr -&gt; expr</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kp">context</span> LV LV (<span class="kr">fun</span> <span class="nv">x</span> : expr =&gt; x)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> ctx_top.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">Y</span> : val.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">vts</span> : list val_tag.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">lts</span> : list loc_tag.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">ps&#39;</span> : pstate.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Axiom</span> <span class="nv">deref_happens</span> : deref_loc ty m p2 pt2 Full E0 &lt;&lt;ps&gt;&gt; (Success (Y, vts, lts)) &lt;&lt;ps&#39;&gt;&gt;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(*Definition example_state5 : state :=</span>
<span class="c">  ExprState f lc ps pct</span>
<span class="c">            (Eassign (Eloc (Lmem p1 pt1 Full) ty)</span>
<span class="c">                     (Eval (Y,(CoalesceT vts)) ty) ty)</span>
<span class="c">            (Kdo k) e te m.</span>

<span class="c">Print state&#39;.</span>

<span class="c">Remark step4 :</span>
<span class="c">  step example_state4 E0 example_state5 \/</span>
<span class="c">    exists failure lg, step example_state4 E0 (Failstop failure lg).</span>
<span class="c">Proof.</span>
<span class="c">  unfold example_state4.</span>
<span class="c">  pose (C := fun r =&gt; (Eassign (Eloc (Lmem p1 pt1 Full) ty) r ty)).</span>
<span class="c">  replace (Eassign (Eloc (Lmem p1 pt1 Full) ty)</span>
<span class="c">                   (Evalof (Eloc (Lmem p2 pt2 Full) ty) ty) ty) with</span>
<span class="c">    (C (Evalof (Eloc (Lmem p2 pt2 Full) ty) ty)) by auto.</span>
<span class="c">  unfold example_state5.</span>
<span class="c">  replace (Eassign (Eloc (Lmem p1 pt1 Full) ty) (Eval (Y, vt) ty) ty) with</span>
<span class="c">    (C (Eval (Y, vt) ty)) by auto.</span>
<span class="c">  left. left.</span>
<span class="c">  apply step_rred.</span>
<span class="c">  - eapply red_rvalof_mem.*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">SEM</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">store_init_data</span> (<span class="nv">ge</span>: genv) (<span class="nv">m</span>: mem) (<span class="nv">p</span>: ptr) (<span class="nv">id</span>: init_data) (<span class="nv">vt</span>: val_tag) (<span class="nv">lt</span>: loc_tag) :
    PolicyResult mem :=
    <span class="kr">match</span> id <span class="kr">with</span>
    | Init_int8 n =&gt; store Mint8unsigned m p (Vint n, vt) [lt]
    | Init_int16 n =&gt; store Mint16unsigned m p (Vint n, vt) [lt;lt]
    | Init_int32 n =&gt; store Mint32 m p (Vint n, vt) [lt;lt;lt;lt]
    | Init_int64 n =&gt; store Mint64 m p (Vlong n, vt) [lt;lt;lt;lt;lt;lt;lt;lt]
    | Init_float32 n =&gt; store Mfloat32 m p (Vsingle n, vt) [lt;lt;lt;lt]
    | Init_float64 n =&gt; store Mfloat64 m p (Vfloat n, vt) [lt;lt;lt;lt;lt;lt;lt;lt]
    | Init_addrof symb ofs =&gt;
        <span class="kr">match</span> find_symbol ge symb <span class="kr">with</span>
        | None =&gt; raise (OtherFailure <span class="s2">&quot;Symbol not found&quot;</span>)
        | Some (SymGlob base bound pt gv) =&gt;
            store Mptr m p (Vptr base, vt) [lt;lt;lt;lt;lt;lt;lt;lt]
        | Some (SymIFun _ b pt) =&gt; 
            store Mptr m p (Vfptr b, vt) [lt;lt;lt;lt;lt;lt;lt;lt]
        | Some (SymEFun _ ef tyargs tyres cc pt) =&gt;
            store Mptr m p (Vefptr ef tyargs tyres cc, pt) [lt;lt;lt;lt;lt;lt;lt;lt]
        <span class="kr">end</span>
    | Init_space n =&gt; ret m
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">store_init_data_list</span> (<span class="nv">ge</span>: genv) (<span class="nv">m</span>: mem) (<span class="nv">p</span>: ptr) (<span class="nv">idl</span>: list init_data)
            (<span class="nv">vt</span>: val_tag) (<span class="nv">lt</span>: loc_tag)
            {<span class="nv">struct</span> <span class="nv">idl</span>}: PolicyResult mem :=
    <span class="kr">match</span> idl <span class="kr">with</span>
    | [] =&gt; ret m
    | id :: idl&#39; =&gt;
        m&#39; &lt;- store_init_data ge m p id vt lt;;
        store_init_data_list ge m&#39; (off p (Int64.repr (init_data_size id))) idl&#39; vt lt
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">init_globals</span> (<span class="nv">ge</span>: genv) (<span class="nv">m</span>: mem) (<span class="nv">idls</span>: list (ident * list init_data)):
    PolicyResult mem :=
    <span class="kr">match</span> idls <span class="kr">with</span>
    | [] =&gt; ret m
    | (id, idl)::idls&#39; =&gt;
      <span class="kr">match</span> find_symbol ge id <span class="kr">with</span>
      | None =&gt; raise (OtherFailure <span class="s2">&quot;Symbol not found&quot;</span>)
      | Some (SymGlob base _ _ _) =&gt;
        <span class="kr">match</span> PTree.get id ge.(genv_glob_tags) <span class="kr">with</span>
        | Some (vt,lt) =&gt;
          m&#39; &lt;- store_init_data_list ge m base idl vt lt;;
          init_globals ge m&#39; idls&#39;
        | None =&gt;
          raise (OtherFailure <span class="s2">&quot;Initial tags not found&quot;</span>)
        <span class="kr">end</span>
      | _ =&gt; init_globals ge m idls&#39;
      <span class="kr">end</span>
    <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">globalenv</span> (<span class="nv">p</span>: program) : PolicyResult (genv * composite_env * mem):=
    <span class="kr">let</span> <span class="nv">ce</span> := p.(prog_comp_env) <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">sizes</span>, inits) := (filter_vars p.(AST.prog_defs)) <span class="kr">in</span> 
    <span class="kr">let</span> (<span class="nv">m</span>,gmap) := globalalloc A.empty sizes <span class="kr">in</span>
    <span class="kr">let</span> <span class="nv">ge</span> := Genv.globalenv ce p.(prog_public) p.(prog_defs) gmap <span class="kr">in</span>
    m&#39; &lt;- init_globals ge m inits;;
    ret (ge, ce, m&#39;).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** * Whole-program semantics *)</span>

  <span class="sd">(** Execution of whole programs are described as sequences of transitions</span>
<span class="sd">      from an initial state to a final state.  An initial state is a [Callstate]</span>
<span class="sd">      corresponding to the invocation of the ``main&#39;&#39; function of the program</span>
<span class="sd">      without arguments and with an empty continuation. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">initial_state&#39;</span> (<span class="nv">p</span>: program): state -&gt; <span class="kt">Prop</span> :=
  | initial_state_intro: <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">pt</span> <span class="nv">f</span> <span class="nv">ge</span> <span class="nv">ce</span> <span class="nv">m</span> <span class="nv">ps</span>,
      globalenv p (init_state,[]) = (Success (ge,ce,m), ps) -&gt;
      Genv.find_symbol ge p.(prog_main) = Some (SymIFun _ b pt) -&gt;
      Genv.find_funct_ptr ge b = Some f -&gt;
      type_of_fundef f = Tfunction Tnil type_int32s cc_default -&gt;
      initial_state&#39; p (Callstate f Cabs.no_loc ps InitPCT def_tag nil Kstop m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">initial_state</span> := initial_state&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
  <span class="sd">(** A final state is a [Returnstate] with an empty continuation. *)</span>

</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">final_state&#39;</span>: state -&gt; int -&gt; <span class="kt">Prop</span> :=
  | final_state_intro: <span class="kr">forall</span> <span class="nv">fd</span> <span class="nv">l</span> <span class="nv">ps</span> <span class="nv">pct</span> <span class="nv">r</span> <span class="nv">m</span> <span class="nv">t</span>,
      final_state&#39; (Returnstate fd l ps pct (Vint r, t) Kstop m) r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">final_state</span> := final_state&#39;.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">semantics</span> (<span class="nv">p</span>: program) (<span class="nv">ge</span>: Genv.t fundef type) (<span class="nv">ce</span>: composite_env) :=
    Semantics_gen step (initial_state p) final_state ge ce.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">TaggedCsem</span>.</span></span></pre></div>
</div>
</div></body>
</html>
