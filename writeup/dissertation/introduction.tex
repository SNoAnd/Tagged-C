\documentclass{report}

\usepackage{geometry}
\usepackage{verbatim}

\begin{document}

\chapter{Introduction}

The computing infrastructure that underpins today's world is insecure. Code written
in unsafe languages (e.g., C) may hide any number of programming bugs that go uncaught
until they are exploited in the wild, especially memory errors. Safe or not, any code
might contain logic errors (SQL injection, input-sanitization flaws, etc.) that subvert
its security requirements.

Although static analyses can detect and mitigate many insecurities, an important line of
defense against undetected or unfixable vulnerabilities is runtime enforcement of
{\em security policies} using a reference monitor~\cite{Anderson72:PlanningStudy}. In particular, 
many useful policies can be specified in terms of flow constraints on 
\emph{metadata tags}, which augment the underlying data with information like type, provenance,
ownership, or security classification.

Tag-based policies are well-suited for efficient hardware enforcement, using 
processor extensions such as ARM MTE~\cite{arm-mte},
STAR~\cite{Gollapudi:23}, and
PIPE.  PIPE\footnote{ Variants of PIPE have
been called PUMP~\cite{Dhawan+15} or %Dhawan+14},
SDMP~\cite{RoesslerD18}% ,Dover16}},
and marketed commercially under the names Dover CoreGuard and Draper Inherently Secure Processor.}
(Processor Interlocks for Policy Enforcement)~\cite{Azevedo+16,Azevedo+15},%Dhawan+15,
the specific motivator for this work, is a programmable hardware mechanism that supports monitoring 
at the granularity of individual instructions. A customizable set of rules updates the metadata tags
at key points during execution, maintaining a relationship between the tags and the security-relevant
behavior of the system as a whole. If the tags would enter a configuration corresponding to insecure
or undesirable behavior, the program \emph{failstops}. PIPE is highly flexible: it supports
arbitrary software-defined tag rules over large (word-sized) tags with arbitrary structure,
which enables fine-grained policies and composition of multiple policies.

This dissertation centers around the problem of specifying PIPE-style policies.
(Although the work is not specific to PIPE, PIPE's basic structure serves to represent the
likely capabilities of tag-based enforcement mechanisms in general.) Specification
means both the operational definition of how policies work in the concrete sense, and
the higher-level formal definitions that capture the kind of security they aim to enforce.

In the literature, PIPE policies are defined at the assembly level. If they aim to enforce
source-level constructs, such as memory safety, they do so with the help of compiler annotations;
such constructs do not take advantage of the PIPE model's flexibility. If they instead
aim to enforce narrower program-specific notions of security, they require careful hand-annotation
by an engineer familiar with the source code. Some works have proven or tested their policies
against a higher-level security specification, but so far this is restricted to simple specifications
and straightforward implementations. When policies are optimized to give up some security in the name
of performance, it is very hard to specify the security that remains.

The work is divided into three main parts. The first proposes a new formal characterization of
stack safety using concepts from language-based security. Though not specific to a PIPE
implementation, this formulation is motivated by a particular class of PIPE-based enforcement
mechanisms, the ``lazy'' stack safety policies studied by Roessler and DeHon~\cite{RoesslerD18},
which permit functions to write into one another's frames but taint the changed locations so that the
frame's owner cannot access them. No prior characterization of stack safety captures this style of
safety.

Next, I present Tagged C, a \emph{source-level}
specification framework that allows engineers to describe policies in terms of familiar
C-level concepts. PIPE policies can be difficult for a C engineer to write: their tags and rules
are defined in terms of individual machine instructions and ISA-level
concepts, and in practice they depend on reverse engineering the behavior
of specific compilers. Tagged C takes the form of a variant C language whose semantics are
parameterized by tags attached to C functions, variables and data values, and rules triggered at
\emph{control points} that correspond to significant execution events, such as function calls,
expression evaluation, and pointer-based memory accesses.
Tagged C may be seen as an operational specification for instrumenting C with a
tag-based reference monitor: it describes policies in terms of their concrete effects
on the execution state of the underlying C semantics.

Armed with this knowledge, a Tagged C user may then prove that a given policy enforces
a higher-level security specification. In the final third of this dissertation I define
a compartmentalization property in the form of
a novel abstract compartmentalized semantics, define a Tagged C policy that enforces it,
and prove in Coq that the policy satisfies its specification.

\section{Contributions and Organization}

Chapter \ref{ch:background} introduces the concept of tag-based reference monitors
and brings the reader up to date on the state-of-the-art in that and related areas.
The contributions in this dissertation are divided across its three main topics.

\paragraph{Stack Safety}

Chapter \ref{ch:stacksafety} gives a novel formalization of stack safety in the
form of a collection of trace properties. Stack Safety exemplifies the specification problem:
"the stack" is not a clearly defined language concept, but a loosely defined component of
a system's ABI that is relied on by many different higher-level abstractions.
Our trace properties describe the behavior that those abstractions
should be able to expect from a well-behaved stack, even when enforced with the
optimized "lazy" tagging approach of Roessler and DeHon \cite{RoesslerD18}.
Our contributions are:

\begin{itemize}
  \item A novel characterization of stack safety as a conjunction
        of security properties---confidentiality and integrity for callee
        and caller---plus well-bracketed control-flow.
        The properties are parameterized over a notion of
        external observation, allowing them to characterize lazy enforcement
        mechanisms.
  \item An extension of these core definitions to
        describe a realistic setting with argument passing on the stack,
        callee-saves registers, and tail-call elimination. The model is
        modular enough that adding these features is straightforward.
  \item Validation of a published enforcement mechanism,
        \emph{Lazy Tagging and Clearing}, via property-based random testing; we find that
        it falls short, and propose and validate a fix.
\end{itemize}

This chapter was first published at the IEEE Computer Security Foundations Symposium,
July 2023 as ``Formalizing Stack Safety as a Security Policy,'' a
joint work with Roberto Blanco, Leonidas Lampropoulos, Benjamin Pierce, and Andrew Tolmach
\cite{Anderson23:StackSafety}.

\paragraph{Tagged C}

In Chapter \ref{ch:taggedc}, we attack the definition problem by lifting tagged enforcement
to the level of C source code. We introduce Tagged C, a C variant whose semantics are parameterized
by an arbitrary tag-based policy. The Tagged C semantics and interpreter are based on those of
CompCert C \cite{Leroy09:CompCert}.

\begin{itemize}
\item The design of a comprehensive set of {\em control points} at which the C language interfaces
  with a tag-based policy. These expand on prior work by encompassing the full C language
  while being powerful enough to enable a range of policies even in the presence of C's more
  challenging constructs (e.g., {\tt goto}, conditional expressions, etc.).
\item Tagged C policies enforcing: (1) compartmentalization;
  (2) memory safety, with realistic memory models that support varying kinds of low-level idioms;
  and (3) secure information flow.
\item A full formal semantic definition for Tagged C, formalized in Coq, describing how the
  control points interact with programs, and an interpreter, implemented and verified against
  the semantics in Coq and extracted to OCaml.
\end{itemize}

The core of this chapter was first published at the International Conference on Runtime Verification,
October 2023 as ``Flexible Runtime Security Enforcement with Tagged C,'' a joint work
with Andrew Tolmach and Allison Naaktgeboren \cite{Anderson23:TaggedC}. Some technical
details are also published in Chaak et al. \cite{}, a joint work with CHR Chaak and Andrew Tolmach.
The original content has been updated to reflect further development, and the chapter has been
extended with a detailed discussion of the design decisions that inform the current development.

\paragraph{Compartmentalization}

Finally, I return to the specification and validation problems, now at the C level. Chapter
\ref{ch:compartments} presents a compartmentalization policy in conjunction with the abstract
compartmentalization scheme that it enforces, and proves that the policy indeed enforces the
abstract model. In this case the specification takes the form of an abstract machine.

Both the specification and the policy that enforces it are novel, and improve upon the
state-of-the art in tag-based compartmentalization by allowing objects to be shared between
compartments via passed pointers, without the overhead of protecting every object individually.
The proof is mechanized.

\begin{itemize}
\item A formal model of C compartmentalization in the form of an abstract machine that
  supports sharing between compartments while keeping their memories isolated by construction.
\item A novel compartmentalization policy for Tagged C that supports cross-compartment
  sharing with fewer constraints on available tags than similar systems from the literature.
\item A proof that the compartmentalization policy is safe with respect to the abstract semantics.
\end{itemize}

The compartmentalization work is not yet submitted for publication.

\chapter{Tags and Monitors}
\label{ch:background}

\chapter{Formalizing Stack Safety as a Security Policy}
\label{ch:stacksafety}

\chapter{Flexible Runtime Security Enforcement with Tagged C}
\label{ch:taggedc}

\chapter{Formalizing Compartmentalization as an Abstract Machine}
\label{ch:compartments}

\chapter{Conclusion}

\bibliographystyle{acm}
\bibliography{taggedc.bib}

\end{document}
