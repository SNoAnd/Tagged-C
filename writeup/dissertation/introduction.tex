\documentclass{report}

\usepackage{verbatim}

\begin{document}

\chapter{Introduction}

The computing infrastructure that underpins today's world is insecure. Code written
in unsafe languages (e.g., C) may hide any number of programming bugs that go uncaught
until they are exploited in the wild, especially memory errors. Safe or not, any code
might contain logic errors (SQL injection, input-sanitization flaws, etc.) that subvert
its security requirements.

Although static analyses can detect and mitigate many insecurities, an important line of
defense against undetected or unfixable vulnerabilities is runtime enforcement of
{\em security policies} using a reference monitor~\cite{Anderson72:PlanningStudy}. In particular, 
many useful policies can be specified in terms of flow constraints on 
\emph{metadata tags}, which augment the underlying data with information like type, provenance,
ownership, or security classification.

Tag-based policies are well-suited for efficient hardware enforcement, using 
processor extensions such as ARM MTE~\cite{arm-mte},
STAR~\cite{Gollapudi:23}, and
PIPE.  PIPE\footnote{ Variants of PIPE have
been called PUMP~\cite{Dhawan+15} or %Dhawan+14},
SDMP~\cite{RoesslerD18}% ,Dover16}},
and marketed commercially under the names Dover CoreGuard and Draper Inherently Secure Processor.}
(Processor Interlocks for Policy Enforcement)~\cite{Azevedo+16,Azevedo+15},%Dhawan+15,
the specific motivator for this work, is a programmable hardware mechanism that supports monitoring 
at the granularity of individual instructions. A customizable set of rules updates the metadata tags
at key points during execution, maintaining a relationship between the tags and the security-relevant
behavior of the system as a whole. If the tags would enter a configuration corresponding to insecure
or undesirable behavior, the program \emph{failstops}. PIPE is highly flexible: it supports
arbitrary software-defined tag rules over large (word-sized) tags with arbitrary structure,
which enables fine-grained policies and composition of multiple policies.

This dissertation centers around the problem of specifying PIPE-style policies.
(Although the work is not specific to PIPE, PIPE's basic structure serves to represent the
likely capabilities of tag-based enforcement mechanisms in general.) Specification
means both the operational definition of how policies work in the concrete sense, and
the higher-level formal definitions that capture the kind of security they aim to enforce.

In the literature, PIPE policies are defined at the assembly level. If they aim to enforce
source-level constructs, such as memory safety, they do so with the help of compiler annotations;
such constructs do not take advantage of the PIPE model's flexibility. If they instead
aim to enforce narrower program-specific notions of security, they require careful hand-annotation
by an engineer familiar with the source code. Some works have proven or tested their policies
against a higher-level security specification, but so far this is restricted to simple specifications
and straightforward implementations. When policies are optimized to give up some security in the name
of performance, it is very hard to specify the security that remains.

The work is divided into three main parts. The first proposes a new formal characterization of
stack safety using concepts from language-based security. Though not specific to a PIPE
implementation, this formulation is motivated by a particular class of PIPE-based enforcement
mechanisms, the ``lazy'' stack safety policies studied by Roessler and DeHon~\cite{RoesslerD18},
which permit functions to write into one another's frames but taint the changed locations so that the
frame's owner cannot access them. No prior characterization of stack safety captures this style of
safety.

Next, I present Tagged C, a \emph{source-level}
specification framework that allows engineers to describe policies in terms of familiar
C-level concepts. PIPE policies can be difficult for a C engineer to write: their tags and rules
are defined in terms of individual machine instructions and ISA-level
concepts, and in practice they depend on reverse engineering the behavior
of specific compilers. Tagged C takes the form of a variant C language whose semantics are
parameterized by tags attached to C functions, variables and data values, and rules triggered at
\emph{control points} that correspond to significant execution events, such as function calls,
expression evaluation, and pointer-based memory accesses.
Tagged C may be seen as an operational specification for instrumenting C with a
tag-based reference monitor: it describes policies in terms of their concrete effects
on the execution state of the underlying C semantics.

Armed with this knowledge, a Tagged C user may then prove that a given policy enforces
a higher-level security specification. In the final third of this dissertation I define
a compartmentalization property in the form of
a novel abstract compartmentalized semantics, define a Tagged C policy that enforces it,
and prove in Coq that the policy satisfies its specification.

\section{Contributions and Organization}

Chapter \ref{ch:background} introduces the concept of tag-based reference monitors
and brings the reader up to date on the state-of-the-art in that and related areas.
The contributions in this dissertation are divided across its three main topics.

\paragraph{Stack Safety}

The work discussed in Chapter \ref{ch:stacksafety} was first published at the
IEEE Computer Security Foundations Symposium, July 2023 as
``Formalizing Stack Safety as a Security Policy,'' a
joint work with Roberto Blanco, Leonidas Lampropoulos, Benjamin Pierce, and Andrew Tolmach.
Its contributions are:

\begin{itemize}
\item A novel characterization of stack safety as a conjunction
  of security properties---confidentiality and integrity for callee
  and caller---plus well-bracketed control-flow.
  The properties are parameterized over a notion of
  external observation, allowing them to characterize lazy enforcement
  mechanisms.
\item An extension of these core definitions to
  describe a realistic setting with argument passing on the stack,
  callee-saves registers, and tail-call elimination. The model is
  modular enough that adding these features is straightforward.
\item Validation of a published enforcement mechanism,
  \emph{Lazy Tagging and Clearing}, via property-based random testing; we find that
  it falls short, and propose and validate a fix.
\end{itemize}

\paragraph{Tagged C}

This work was first published at the International Conference on Runtime Verification,
October 2023 as ``Flexible Runtime Security Enforcement with Tagged C,'' a joint work
with Andrew Tolmach and Allison Naaktgeboren. Its contributions are:
 
\begin{itemize}
\item The design of a comprehensive set of {\em control points} at which the C language interfaces
  with a tag-based policy. These expand on prior work by encompassing the full C language
  while being powerful enough to enable a range of policies even in the presence of C's more
  challenging constructs (e.g., {\tt goto}, conditional expressions, etc.).
\item Tagged C policies enforcing: (1) compartmentalization;
  (2) memory safety, with realistic memory models that support varying kinds of low-level idioms;
  and (3) secure information flow.
\item A full formal semantic definition for Tagged C, formalized in Coq, describing how the
  control points interact with programs, and an interpreter, implemented and verified against
  the semantics in Coq and extracted to OCaml.
\end{itemize}

Chapter \ref{ch:taggedc} corresponds to the original paper. It introduces the Tagged C language
and explains the semantics and interpreter. Chapter \ref{ch:pragmatics} discusses the underlying
design decisions that inform how Tagged C works, and how those choices
impact the actual process of defining policies for Tagged C.

\paragraph{Compartmentalization}

The compartmentalization work is not yet submitted for publication.

\begin{itemize}
\item A formal model of C compartmentalization in the form of an abstract machine that
  supports sharing between compartments while keeping their memories isolated by construction.
\item A novel compartmentalization policy for Tagged C that supports cross-compartment
  sharing with fewer constraints on available tags than similar systems from the literature.
\item A proof that the compartmentalization policy is safe with respect to the abstract semantics.
\end{itemize}

These topics are split between Chapter \ref{ch:compartments}, which defines the compartmentalization
model, and Chapter \ref{ch:proof}, which covers the associated policy and the proof effort to show that
it enforces that model.

\chapter{Tags and Monitors}
\label{ch:background}

\chapter{Formalizing Stack Safety as a Security Policy}
\label{ch:stacksafety}

\chapter{Flexible Runtime Security Enforcement with Tagged C}
\label{ch:taggedc}

\chapter{Pragmatics of Tagged C and Policy Design}
\label{ch:pragmatics}

\chapter{Formalizing Compartmentalization as an Abstract Machine}
\label{ch:compartments}

\chapter{Proving Compartmentalization}
\label{ch:proof}

\chapter{Conclusion}

\bibliographystyle{acm}
\bibliography{taggedc.bib}

\end{document}
