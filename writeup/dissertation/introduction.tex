\documentclass{report}

\usepackage{geometry}
\usepackage{verbatim}
\usepackage[table]{xcolor}
\usepackage{subcaption}

\begin{document}

\chapter{Introduction}

The computing infrastructure that underpins today's world is insecure. Code written
in unsafe languages (e.g., C) may hide any number of programming bugs that go uncaught
until they are exploited in the wild, especially memory errors. Safe or not, any code
might contain logic errors (SQL injection, input-sanitization flaws, etc.) that subvert
its security requirements.

Although static analyses can detect and mitigate many insecurities, an important line of
defense against undetected or unfixable vulnerabilities is runtime enforcement of
{\em security policies} using a reference monitor~\cite{Anderson72:PlanningStudy}.
A security policy restricts the behavior of the system, typically by interrupting
<<<<<<< HEAD
a badly-behaved process, termed ``failstop behavior.'' At the most general, a policy could be
any kind of runtime check, from simple assertions (``at line X, variable Y has value Z'') to
sophisticated temporal logic formulae.

This dissertation focuses on a class of policies that can be specified in terms of flow constraints
on \emph{metadata tags}. A tag annotates a value with information like type, provenance,
ownership, or security classification, and a tag-based policy is defined solely in terms of
the interaction of tags, without reference to the values that they are attached to.
Notable policies that can be implemented in this way include:

\begin{itemize}
\item {\em Memory safety}, which restricts programs in memory unsafe languages to obey
  the spatial and/or temporal constraints of the language, turning unchecked errors into
  checked ones
\item {\em Information flow control} (IFC), in which data identified as being in some way secret
  or sensitive is preventing from leaking on an externally visible
\item {\em Compartmentalization}, in which programs are divided into components (compartments)
  with restricted access to data and other resources
\item {\em Mandatory access control}, which identifies ``subjects'' (possibly compartments,
  but also non-code entities such as users) and explicitly restricts their access to resources
\end{itemize}

Tag-based policies include a number of important security concepts, and are well-suited to
efficient hardware enforcement. As an exemplar of hardware tag monitors, take the 
PIPE\footnote{ Variants of PIPE have
been called PUMP~\cite{Dhawan+15} or SDMP~\cite{RoesslerD18} and marketed commercially
under the names Dover CoreGuard and Draper Inherently Secure Processor.}
(Processor Interlocks for Policy Enforcement) ISA extension \cite{Azevedo+16,Azevedo+15}.

PIPE is a programmable hardware mechanism that associates large (word-sized) metadata tags
with every word of memory and register. At each step of execution, while the ALU processes
the operands of the current instruction, the tags associated with those operands are processed
by a module called the ``tag management unit'' (TMU).
The TMU, instantiated as a cache or lookup table into a set of software-defined rules,
consults those rules to (1) determine whether the operation should
proceed, sending an interrupt if not, and (2) compute updated tags to associate with the
outputs of the operation. These rules collectively define a state machine operating on the
tags in the system, which is termed a ``micro-policy,'' a concrete instantiation of the
sorts of policies mentioned above.

Because PIPE tags are so large, they can encode complex data structures, giving PIPE a high
degree of flexibility in the policies that it can enforce. It is even feasible to layer
multiple policies on top of one another by taking the Cartesian product of their tags.
And because tags are inaccessible to normal execution, PIPE policies are protected from
subversion by application code.

However, the complexity of PIPE's style of tagging leads to challenges in the definition,
specification, and verification of policies, described in detail below. This dissertation
addresses those challenges.

\paragraph{Defining Policies}

=======
a badly-behaved process, termed ``failstop behavior.'' Policies of note include:

\begin{itemize}
\item {\em Memory safety}, which restricts programs in memory unsafe languages to obey
  the spatial and/or temporal constraints of the language, turning unchecked errors into
  checked ones
\item {\em Information flow control} (IFC), in which data identified as being in some way secret
  or sensitive is preventing from leaking on an externally visible
\item {\em Compartmentalization}, in which programs are divided into components (compartments)
  with restricted access to data and other resources
\item {\em Mandatory access control}, which identifies ``subjects'' (possibly compartments,
  but also non-code entities such as users) and explicitly restricts their access to resources
\item {\em Sealing}, in which a piece of data is protected from access until some future
  point in execution
\end{itemize}

The policies can be specified in terms of flow constraints on \emph{metadata tags},
which augment the underlying data with information like type, provenance, ownership, or
security classification. The broad class of tag-based policies are well-suited for efficient
hardware enforcement. This dissertation focuses on an exemplar of hardware tagging, the
PIPE\footnote{ Variants of PIPE have
been called PUMP~\cite{Dhawan+15} or SDMP~\cite{RoesslerD18} and marketed commercially
under the names Dover CoreGuard and Draper Inherently Secure Processor.}
(Processor Interlocks for Policy Enforcement) ISA extension \cite{Azevedo+16,Azevedo+15}.

PIPE is a programmable hardware mechanism that associates large (word-sized) metadata tags
with every word of memory and register. At each step of execution, while the ALU processes
the operands of the current instruction, the tags associated with those operands are processed
by a module called the ``tag management unit'' (TMU).
The TMU consults a set of software-defined rules to (1) determine whether the operation should
proceed, sending an interrupt if not, and (2) compute updated tags to associate with the
outputs of the operation. These rules collectively define a state machine operating on the
tags in the system, which is termed a ``micro-policy,'' a concrete instantiation of the
sorts of policies mentioned above.

Because PIPE tags are so large, they can encode complex data structures, giving PIPE a high
degree of flexibility in the policies that it can enforce. It is even feasible to layer
multiple policies on top of one another by taking the Cartesian product of their tags.
And because tags are inaccessible to normal execution, PIPE policies are protected from
subversion by application code.

However, the complexity of PIPE's style of tagging leads to challenges in the definition,
specification, and verification of policies, described in detail below. This dissertation
addresses those challenges.

\paragraph{Defining Policies}

>>>>>>> origin/heapproblems
Tag policies are difficult to write.
A policy consists of a collection of rules, each associated with a family of opcodes.
Almost all policies will need to distinguish
individual special instructions via tags on their values in memory, since many opcodes can
play different roles that need to be
treated differently in the policy. Defining a policy requires knowledge of both the assembly
language of the host ISA and the behavior of the compiler, so that the policy designer can
identify which instructions serve special purposes. Many policies require the binary
to be rewritten with additional instructions whose primary purpose is moving and manipulating
tags.

For example, Figure \ref{ex:call} shows how a single function header must be updated to
<<<<<<< HEAD
support a (simplified) spatial stack safety policy. % say in words what the point of the policy is
The policy is conceptually simple:
each location in a stack frame is identified by the depth of the frame, and the stack pointer
is tagged with the depth of the current function activation.  Loads and stores of stack
addresses must use a pointer that matches that of the location, i.e. the current stack pointer
or a pointer derived from it. % say that it doesn't enforce the full temporal safety
=======
support a (simplified) spatial stack safety policy. The policy is conceptually simple:
each location in a stack frame is identified by the depth of the frame, and the stack pointer
is tagged with the depth of the current function activation.  Loads and stores of stack
addresses must use a pointer that matches that of the location, i.e. the current stack pointer
or a pointer derived from it.
>>>>>>> origin/heapproblems

Figure \ref{ex:call1} shows a typical header sequence for a function. It merely stores
the return address to the stack pointer, then decreases the stack pointer by \(size\)
(the size of the function frame in bytes). Figure \ref{ex:call2} gives a sense of how
this code might be instrumented with tags, and Figure \ref{ex:call3} describes some of
the rules that act on these tags. The header sequence is given special tags to enforce
that it runs from beginning to end and only following a call, and instructions are added
to initialize tags on the stack frame.

A significant portion of the policy's rules is dedicated to bookkeeping, in this case
mostly for purposes of ensuring that the header sequence executes in order (red).
Only the lines in blue deal with the main focus of the policy:
tagging the frame and the stack pointer with the current depth of the call stack, and enforcing
that a stack address can only be written through the stack pointer at the same depth.

\begin{figure}
<<<<<<< HEAD
  \begin{subfigure}[t]{0.55\textwidth}
    \vspace{0em}
    \begin{tabular}{l l}
      0: {\tt sub sp 16 sp} & Allocate sixteen bytes \\
      8: {\tt store ra sp} & Save return address \\
      \dots \\
      32: {\tt store 42 (sp+8)} & Store to stack in body \\
      \dots \\
      64: {\tt load r0 (sp+8)} & Load from stack in body \\
=======
  \begin{subfigure}{0.4\textwidth}
    \begin{tabular}{l l}
      0 & store \(ra\) \\
      8 & subtract \(size\) from \(sp\) \\
      16 & [function body] \\
>>>>>>> origin/heapproblems
    \end{tabular}
    \caption{Initial generated code}
    \label{ex:call1}
  \end{subfigure}
<<<<<<< HEAD
  \begin{subfigure}[t]{0.45\textwidth}
    \vspace{0em}
    \begin{tabular}{l l}
      0: {\tt sub sp 16 sp} & @ {\sc Head}\((0)\) \\
      8: {\tt store ra sp} & @ {\sc Head}\((1)\) \\
      16: {\tt store 0 (sp+8)} & @ {\sc Head}\((2)\) \\
      24: {\tt nop} & @ {\sc Entry} \\
      \dots \\
      48: {\tt store 42 (sp+8)} & @ {\sc Normal} \\
      \dots \\
      80: {\tt load r0 (sp+8)} & @ {\sc Normal} \\
=======
  \begin{subfigure}{0.5\textwidth}
    \begin{tabular}{l l}
      0 @ {\sc Head}\((0)\) & store \(ra\) through \(sp\) \\
      8 @ {\sc Head}\((1)\) & subtract \(size\) from \(sp\) \\
      16 @ {\sc Head}\((2)\) & store \(0\) through \(sp-(size*8)\) \\
      \(\dots\) \\
      n @ {\sc Head}\((x)\) & store \(0\) through \(sp-8\) \\
      n+8 @ {\sc Entry} & nop \\
      n+16 @ {\sc Normal} & [function body] \\
>>>>>>> origin/heapproblems
    \end{tabular}
    \caption{Code tagged and expanded for policy}
    \label{ex:call2}
  \end{subfigure}

  \vspace{\belowdisplayskip}
  
  \begin{subfigure}{\textwidth}
    \begin{tabular}{|l|}
      \hline
<<<<<<< HEAD
      When executing {\tt sub imm r}@{\sc Head}\((0)\): \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag {\sc Call} \\
=======
      When executing {\tt store r1 r2}@{\sc Head}\((0)\): \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag {\sc Call} \\
      \rowcolor{red!20}
      \(\cdot\) Set tag at {\tt r2}'s target to {\sc RetPtr} \\
      \hline
    \end{tabular}
    %
    \begin{tabular}{|l|}
      \hline
      When executing {\tt sub imm r}@{\sc Head}\((1)\): \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag {\sc Head}\((0)\) \\
>>>>>>> origin/heapproblems
      \rowcolor{blue!30}
      \(\cdot\) Tag on {\tt r} must be {\sc Depth}\((n)\) for some \(n\) \\
      \rowcolor{blue!30}
      \(\cdot\) Set tag on {\tt r} to {\sc Depth}\((n+1)\) \\
      \hline
    \end{tabular}
<<<<<<< HEAD
    %
   \begin{tabular}{|l|}
      \hline
      When executing {\tt store r1 r2}@{\sc Head}\((1)\): \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag {\sc Head}\((0)\) \\
      \rowcolor{red!20}
      \(\cdot\) Set tag at {\tt r2}'s target to {\sc RetPtr} \\
      \hline
    \end{tabular}
    
=======

>>>>>>> origin/heapproblems
    \begin{tabular}{|l|}
      \hline
      When executing {\tt store imm (r+x)}@{\sc Head}\((n)\): \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag {\sc Head}\((n-1)\) \\
      \rowcolor{blue!30}
      \(\cdot\) Tag on {\tt r} must be {\sc Depth}\((m)\) \\
      \rowcolor{blue!30}
      \(\cdot\) Set tag at {\tt r}'s target to {\sc Depth}\((m)\) \\
      \hline
    \end{tabular}
    %
    \begin{tabular}{|l|}
      \hline
      When executing \(\underline{~~}\)@{\sc Entry} \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag \\
      \rowcolor{red!20} {\sc Head}\((size / 8)\) \\
      \hline
    \end{tabular}
    
    \begin{tabular}{|l|}
      \hline
      When executing {\tt load \_ (r+x)}@{\sc Normal} \\
      \hline
      \rowcolor{blue!30}
      \(\cdot\) If tag on {\tt r}'s target is {\sc Depth}\((m)\), then
      tag on {\tt r} must be tagged {\sc Depth}\((m)\) \\
      \hline
    \end{tabular}
    
    \begin{tabular}{|l|}
      \hline
      When executing {\tt store \_ (r+x)}@{\sc Normal} \\
      \hline
      \rowcolor{blue!30}
      \(\cdot\) If tag on {\tt r}'s target is {\sc Depth}\((m)\), then
      tag on {\tt r} must be tagged {\sc Depth}\((m)\) \\
      \hline
    \end{tabular}
    \caption{Associated policy rules}
    \label{ex:call3}
  \end{subfigure}

  \caption{Example: Adding Stack Safety policy at call}
  \label{ex:call}
\end{figure}

These modifications can be automated, given relevant annotations from the compiler, but the process
is both complex and repetitive. It would be better if most of the bookkeeping could be handled
within a compiler, leaving the policy developer free to focus on the rules that are relevant to
the specific policy (i.e., the ones in blue.)

<<<<<<< HEAD
\begin{figure}
  \begin{subfigure}[t]{0.18\textwidth}
    \vspace{0em}
    {\tt if (x == 42) \{

      ~~~ y = 0;

      \}
    }
  \end{subfigure}
  \begin{subfigure}[t]{0.42\textwidth}
    \vspace{0em}
    \begin{tabular}{l l}
      0: {\tt load r0 (sp+8)} & Load {\tt x} \\
      8: {\tt add zero 42 r1} & Constant 42 \\
      16: {\tt bne r0 r1 16} & Branch past {\tt if} \\
      24: {\tt store 0 (sp+16)} & Store to {\tt y} \\
      32: \dots & \\
    \end{tabular}
    \caption{Initial generated code}
    \label{ex:if1}
  \end{subfigure}
  \begin{subfigure}[t]{0.4\textwidth}
     \vspace{0em}
     \begin{tabular}{l l}
      0: {\tt load r0 (sp+8)} & @ {\sc Normal} \\
      8: {\tt add zero 42 r1} & @ {\sc Normal} \\
      16: {\tt sub pc pc r2} & @ {\sc SaveTag} \\
      24: {\tt bne r0 r1 16} & @ {\sc Split} \\
      32: {\tt store 0 (sp+16)} & @ {\sc Normal} \\
      40: {\tt jmp r2} & @ {\sc Join} \\
    \end{tabular}
    \caption{Code tagged and expanded for policy}
    \label{ex:if2}
  \end{subfigure}

  \vspace{\belowdisplayskip}
  
  \begin{subfigure}{\textwidth}
    \begin{tabular}{|l|}
      \hline
      When executing {\tt sub imm r}@{\sc Head}\((0)\): \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag {\sc Call} \\
      \rowcolor{blue!30}
      \(\cdot\) Tag on {\tt r} must be {\sc Depth}\((n)\) for some \(n\) \\
      \rowcolor{blue!30}
      \(\cdot\) Set tag on {\tt r} to {\sc Depth}\((n+1)\) \\
      \hline
    \end{tabular}
    %
   \begin{tabular}{|l|}
      \hline
      When executing {\tt store r1 r2}@{\sc Head}\((1)\): \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag {\sc Head}\((0)\) \\
      \rowcolor{red!20}
      \(\cdot\) Set tag at {\tt r2}'s target to {\sc RetPtr} \\
      \hline
    \end{tabular}
    
    \begin{tabular}{|l|}
      \hline
      When executing {\tt store imm (r+x)}@{\sc Head}\((n)\): \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag {\sc Head}\((n-1)\) \\
      \rowcolor{blue!30}
      \(\cdot\) Tag on {\tt r} must be {\sc Depth}\((m)\) \\
      \rowcolor{blue!30}
      \(\cdot\) Set tag at {\tt r}'s target to {\sc Depth}\((m)\) \\
      \hline
    \end{tabular}
    %
    \begin{tabular}{|l|}
      \hline
      When executing \(\underline{~~}\)@{\sc Entry} \\
      \hline
      \rowcolor{red!20}
      \(\cdot\) Preceding instruction must have tag \\
      \rowcolor{red!20} {\sc Head}\((size / 8)\) \\
      \hline
    \end{tabular}
    
    \begin{tabular}{|l|}
      \hline
      When executing {\tt load \_ (r+x)}@{\sc Normal} \\
      \hline
      \rowcolor{blue!30}
      \(\cdot\) If tag on {\tt r}'s target is {\sc Depth}\((m)\), then
      tag on {\tt r} must be tagged {\sc Depth}\((m)\) \\
      \hline
    \end{tabular}
    
    \begin{tabular}{|l|}
      \hline
      When executing {\tt store \_ (r+x)}@{\sc Normal} \\
      \hline
      \rowcolor{blue!30}
      \(\cdot\) If tag on {\tt r}'s target is {\sc Depth}\((m)\), then
      tag on {\tt r} must be tagged {\sc Depth}\((m)\) \\
      \hline
    \end{tabular}
    \caption{Associated policy rules}
    \label{ex:if3}
  \end{subfigure}

  \caption{Example: Adding Stack Safety policy at call}
  \label{ex:if}
\end{figure}


% another example that deals with things that are really hard at the C level

% specification before validation

=======
>>>>>>> origin/heapproblems
\paragraph{Validating Policies}

Once defined, a policy needs to be validated, either by testing or formal verification. Verification is
preferable, as it rules out the possibility of bugs too subtle to show up in testing.
But it is hard to prove properties of assembly code; high-level language features like
structured control flow are easier to reason about. Proofs about assembly programs are
also non-portable across architectures and compilers.
Besides these limitations, both verification and adequate testing require a specification before
they can even begin.

\paragraph{Specifying Policies}

In many cases, there is no standard specification for the kind of security that a policy hopes
to enforce. Even in cases where there is an existing formal specification, such as
memory safety \cite{Azevedo+16}, trade-offs between performance and protection may result in a
policy that does not precisely match it. When this happens, it could mean that the policy
has compromised its protection to an unacceptable degree---or that the existing specification
is too conservative. Whatever the reason, a new security property is valuable in its own right,
and even more valuable if it comes paired with a policy that provably enforces it.
<<<<<<< HEAD
% more concreteness around the tradeoffs
=======
>>>>>>> origin/heapproblems

Many policies aim to enforce security concepts that do not exist at the assembly level. Assembly
code has no notion of a heap, for instance. Specifying such a policy at the assembly
level typically requires one to explicitly account for how the compiler implements that source-level
construct. In the context of heap safety, for instance, that means that significant effort goes
toward defining a notion of pointer provenance that would just be present implicitly in a
source program.

<<<<<<< HEAD
% refer back to examples in specification and validation

=======
>>>>>>> origin/heapproblems
\section{Overview}

This dissertation is divided into three main parts. The first proposes a new formal characterization
of stack safety using concepts from language-based security. Stack safety exemplifies the challenges
of specifying a policy: ``the stack'' is not a clearly defined language concept, but a loosely
defined component of a system's ABI that is relied on by many different higher-level abstractions.
Performance tradeoffs are relevant as well: the ``lazy'' stack safety policies studied by
Roessler and DeHon~\cite{RoesslerD18} permit functions to write into one another's
frames, intuitively a violation, but taint the written locations so that their owner cannot
access them later. No prior characterization of stack safety captures this style of safety.

The second part presents Tagged C, a \emph{source-level} specification framework that allows
engineers to describe policies in terms of familiar C-level concepts.
Tagged C takes the form of a variant C language whose semantics is parameterized by tags
attached to its data and rules that triggered during execution at a set of predefined
\emph{control points}. Control points correspond to significant execution events, such as
function calls, expression evaluation, and pointer-based memory accesses.

<<<<<<< HEAD
% Make this the second sentence in the previous paragraph (what it's for precedes what it is)
=======
>>>>>>> origin/heapproblems
Tagged C addresses the challenges in definition, validation, and specification that relate to
assembly-level programs. It allows policies to be defined at the source level via a fixed interface
that never requires rewriting code. Where assembly instructions can serve different roles and must
be distinguished for tag purposes, each Tagged C control point serves one clear role. The policy
designer needs little knowledge of how the control points might be compiled, and need not
deal with portions of a policy that would be colored red in Figure \ref{ex:call}.

The current iteration of Tagged C is implemented as an interpreter, based on that of
CompCert C \cite{Leroy09:CompCert}. This is sufficient to test small programs. Ultimately
Tagged C will be compiled to a PIPE target by injecting the source policy's tag rules
as a payload into a predefined assembly-level policy that handles the bookkeeping.

The Tagged-C semantics (also based on CompCert C) gives a formal definition of what each
control point does. This means that properties of a policy may be proven in terms of how
source programs behave when run under it. Just as it is far preferable to prove properties
of a program with regard to its source semantics, this is a major step forward for policy
verification.

The final third of this dissertation makes use of Tagged C to perform a source-level specification and
verification of a novel compartmentalization property. The specification takes the form of
<<<<<<< HEAD
an abstract compartmentalized semantics. % emphasize correct by construction
I define a Tagged C policy that enforces it,
=======
an abstract compartmentalized semantics. I define a Tagged C policy that enforces it,
>>>>>>> origin/heapproblems
and prove in Coq that the policy satisfies its specification. The policy definition, its
specification, and its proof are all concrete contributions on their own, and together they
serve to demonstrate that Tagged C is a suitable setting in which to attack all three
challenges.

\subsection{Contributions and Organization}

Chapter \ref{ch:background} introduces the concept of tag-based reference monitors
and brings the reader up to date on the state-of-the-art in that and related areas.
The contributions in this dissertation are divided across its three main topics.

\paragraph{Stack Safety}

Chapter \ref{ch:stacksafety} gives a novel formalization of stack safety in the
form of a collection of trace properties. Our contributions are:

\begin{itemize}
  \item A novel characterization of stack safety as a conjunction
        of security properties---confidentiality and integrity for callee
        and caller---plus well-bracketed control-flow.
        The properties are parameterized over a notion of
        external observation, allowing them to characterize lazy enforcement
        mechanisms.
  \item An extension of these core definitions to
        describe a realistic setting with argument passing on the stack,
        callee-saves registers, and tail-call elimination. The model is
        modular enough that adding these features is straightforward.
  \item Validation of a published enforcement mechanism,
        \emph{Lazy Tagging and Clearing}, via property-based random testing; we find that
        it falls short, and propose and validate a fix.
\end{itemize}

This chapter was first published at the IEEE Computer Security Foundations Symposium,
July 2023 as ``Formalizing Stack Safety as a Security Policy,'' a
joint work with Roberto Blanco, Leonidas Lampropoulos, Benjamin Pierce, and Andrew Tolmach
\cite{Anderson23:StackSafety}.

\paragraph{Tagged C}

In Chapter \ref{ch:taggedc}, we attack the definition problem by lifting tagged enforcement
to the level of C source code. We introduce Tagged C, a C variant whose semantics are parameterized
by an arbitrary tag-based policy. Our contributions are:

\begin{itemize}
\item The design of a comprehensive set of {\em control points} at which the C language interfaces
  with a tag-based policy. These expand on prior work by encompassing the full C language
  while being powerful enough to enable a range of policies even in the presence of C's more
  challenging constructs (e.g., {\tt goto}, conditional expressions, etc.).
\item Tagged C policies enforcing: (1) compartmentalization;
  (2) memory safety, with realistic memory models that support varying kinds of low-level idioms;
  and (3) secure information flow.
\item A full formal semantic definition for Tagged C, formalized in Coq, describing how the
  control points interact with programs, and an interpreter, implemented and verified against
  the semantics in Coq and extracted to OCaml.
\end{itemize}

The core of this chapter was first published at the International Conference on Runtime Verification,
October 2023 as ``Flexible Runtime Security Enforcement with Tagged C,'' a joint work
with Andrew Tolmach and Allison Naaktgeboren \cite{Anderson23:TaggedC}. Some technical
details are also published in Chhak et al. \cite{}, a joint work with CHR Chhak and Andrew Tolmach.
The original content has been updated to reflect further development, and the chapter has been
extended with a detailed discussion of the design decisions that inform the current development.

\paragraph{Compartmentalization}

Finally, I return to the specification and validation problems, now at the C level. Chapter
\ref{ch:compartments} presents a compartmentalization policy in conjunction with the abstract
compartmentalization scheme that it enforces, and proves that the policy indeed enforces the
abstract model. In this case the specification takes the form of an abstract machine.

Both the specification and the policy that enforces it are novel, and improve upon the
state-of-the art in tag-based compartmentalization by allowing objects to be shared between
compartments via passed pointers, without the overhead of protecting every object individually.
The proof is mechanized. It both serves as a contribution in its own right, and a demonstration
of how Tagged C can enable this style of verification in general. 

\begin{itemize}
\item A formal model of C compartmentalization in the form of an abstract machine that
  supports sharing between compartments while keeping their memories isolated by construction.
\item A novel compartmentalization policy for Tagged C that supports cross-compartment
  sharing with fewer constraints on available tags than similar systems from the literature.
\item A proof that the compartmentalization policy is safe with respect to the abstract semantics.
\end{itemize}

This work is not yet submitted for publication.

\chapter{Tags and Monitors}
\label{ch:background}

\chapter{Formalizing Stack Safety as a Security Policy}
\label{ch:stacksafety}

\chapter{Flexible Runtime Security Enforcement with Tagged C}
\label{ch:taggedc}

\chapter{Formalizing Compartmentalization as an Abstract Machine}
\label{ch:compartments}

\chapter{Conclusion}

\bibliographystyle{acm}
\bibliography{taggedc.bib}

\end{document}
