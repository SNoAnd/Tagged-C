SUBMISSION: 34
TITLE: Flexible Runtime Security Enforcement with Tagged C


----------------------- REVIEW 1 ---------------------
SUBMISSION: 34
TITLE: Flexible Runtime Security Enforcement with Tagged C
AUTHORS: Sean Anderson, Allison Naaktgebooren and Andrew Tolmach

----------- Overall evaluation -----------
SCORE: 1 (weak accept)
----- TEXT:
This research paper presents "Tagged C", a CompCert-based tool that allows the user to specify and enforce at runtime different security policies for C code. This is illustrates with 3 policies, namely secure information flows, memory safety, and compartmentalization. The goal is to modify the CompCert compiler to generate an instrumented code for PIPE-based processors.

The paper is well written and is perfectly in scope for RV. I think the ideas and the tool presented in the paper are of great interest and worth being published. It proposes a novel approach for extending an existing semantics (here based on CompCert) with additional information (here security related) in a quite generic manner, even if there are still a few limitations, most of them being properly mentionned in the paper.

However, I think that there are perhaps too much materials for a 16-page LNCS-style paper. Consequently, some explanations and details are omitted, which makes the paper not always easy to understand in depth and, more annoyingly, to assess its correctness. In particular, the paper remains at an informal level of details, all the formal parts being in the appendix. The paper contains many examples, which is nice. However, understanding them in depth is not that easy because the underlying notations & definitions are not part of the (core) paper and their are not always explained step-by-step in the paper.

To sum up, I think that this work is definitively of great interest, but would deserve a more detailed presentation with more technical/formal details. Therefore, a journal extension of this paper would be much welcome.

Technical remarks/questions:

- Your goal is to compile to PIPE-based processor, but this aspect is not key in the paper. I wonder whether you need to insists that much on that part in the abstract/introduction/related work/conclusion, while you do not mention it at all in the technical parts of the paper.

- Which properties do you really enforce at runtime, in particular for memory safety and SIF? Considering SIF, it looks like it is somewhere between static tainting and flow-sensitive non-interference. However, the former seems more imprecise that your flow-sensitive approach, while (most forms of) the latter cannot be soundly detected with a pure dynamic technique [1]. I believe I manage to convince myself that what you do makes sense, but providing neither technical details nor theorems do not help in that respect (the Appendix provides technical details, but lacks of explanations and does not provide the formal guarantees provided by Tagged C).

[1] A. Russo and A. Sabelfeld. Dynamic vs static flow-sensitive security analysis. CSF 2010.

It is quite similar for memory safety: I **believe** that it is fine, but I cannot assess anything because of lack of details/theorems.

- Fig. 5:"(7) is also illegal in PVI". From ISO C99, Sect. 6.5.6, ยง9, "when two pointers are subtracted, both shall points to elements of the same array object, or one past the last element of the array object". Therefore, I believe that your example is legal in the PNVI model because it is fully flat and so arrays x and y are in contiguous 32-bit memory locations (so without padding bits in-between). If so, I think it would be worth adding a few words to make it clear. If I misunderstood, please explain why (7) is legal in the PNVI model.

- p13: "regardless of whether the code that they protect contains errors or undefined behaviors". I do not understand this part of the sentence. Indeed, if the code contains an UB, one can have no guarantee about the SIF policy since the execution of the code is, by definition, undefined (e.g., it could be removed at compile time, or it could lead to execute another piece of code). Usually, soundness theorems about information flows (or other semantic-based C properties) look like "if there is no UB, then [...]" (or "if the program point P is reachable, [...]", which is usually not possible when the program has an error between the start of the program and P)

- p14: "The internal syntactic form of each conditional statement": what about (possibly unnatural) loops encoded through gotos?

- Related Work: I think the part about (RV of) C code is a bit weak. Even if I am not aware of work such as yours, you could present a few works that specifically target the security properties that are investigated in your paper: memory safety, SIF, compartmentalization. I know no work about compartmentalization, but it does not mean that it does not exist :). For memory safety and SIF, several works do exist.

Typos:
FIXED p3: [23],[24] --> [23, 24]
FIXED p3: appear --> appears (last line of Sec. 1)
FIXED p5: \it{binoptname} --> BinOpT (probably \binoptname is a LaTeX macro)
FIXED p7, Tbl 1: oads --> loads
FIXED p7: formal rules: LaTeX's overfull hbox
FIXED p8: in Section 4 --> in Section 4. (dot missing at the end of the sentence)
FIXED p9: toogether --> together
FIXED p10: (Section 4.1) --> (Fig. 7)


----------------------- REVIEW 2 ---------------------
SUBMISSION: 34
TITLE: Flexible Runtime Security Enforcement with Tagged C
AUTHORS: Sean Anderson, Allison Naaktgebooren and Andrew Tolmach

----------- Overall evaluation -----------
SCORE: 1 (weak accept)
----- TEXT:
===============
Paper Summary
===============
This work introduced source-level tagged C to allow developers to write policies in C-level concepts together with tags to functions, vars, data values, and rules. Basically, it goes from Tagged C to machine code for a PIPE-equipped processor. 
These rules then correspond to the low-level execution events. Since for certain security policies, the specifications in high-level do not really guarantee it is also preserved at the machine level. This work extended the previous Tagine project[9], and apply this technique to the full, real C language. The built prototype is based on the CompCert C semantics, which is written in the language `Gallina` of Coq. The authors also provide three classes of policies for security enforcement.



===========
Strengths
===========
The paper is well-written and easy to follow. The introductory examples are clearly explained and are helpful for the reader to quickly understand the core contributions and the main technical approach.  The core idea of Tagged C with Coq Proof assistant is solid. Furthermore, Tagged C separates variables into public and private data in terms of memory-related UB which is the major difference compared to CompCert C. 


============
Weaknesses
============
The experimental section is not very strong.

First, the implementation seems to be not available. It is unclear how this approach can be applied to real programs.

ADDRESSED with "Selecting Control Points" - As the author also pointed out in Section 6, the control points is quite manually created and it is possible that it will fail to conduct the enforcement since the set of control points is too limited.

Furthermore, for security policy enforcement, the authors should also compare with other approaches such as faceted evaluation [ref], which can also force failstop when the insecure information flow (i.e., H->L) happens. The comparison is important because faceted evaluation can also guarantee secure information flow (SIF). 

[ref] Austin, Thomas H., and Cormac Flanagan. "Multiple facets for dynamic information flow." Proceedings of the 39th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages. 2012.



=========================
Comments for author(s)
=========================
- The extension from [9] seems limited, especially for the part that the authors also pointed out, that the control points are likely to be insufficient when trying to enforce new policies. Could the control points be synthesized to strength this approach? 
- What is the major difference between the failstop mechanism of tagged C compared to existing dynamic enforcement approach such as the faceted evaluation? 
- The core idea of Tagged C with Coq Proof assistant is solid but the implementation seems not public available. 
- The instances of security policies (i.e., experimental results) are not concrete enough and thus not very convincing. Would it be possible to apply this approach to enforce real C programs?  


Typos: 
FIXED Section1, last paragraph: 			descibes -> describes 
FIXED Section2, one to the last paragraph: 	ommitting -> omitting 
FIXED Section4, first paragraph: 			toogether -> together



----------------------- REVIEW 3 ---------------------
SUBMISSION: 34
TITLE: Flexible Runtime Security Enforcement with Tagged C
AUTHORS: Sean Anderson, Allison Naaktgebooren and Andrew Tolmach

----------- Overall evaluation -----------
SCORE: 1 (weak accept)
----- TEXT:
This paper describes an extension of C, called Tagged C, that adds tag-based monitors directly to the semantics of the language (leveraging the CompCert work on C semantics). The general idea is to extend the notion of value to carry tag metadata and fixed "control points" where users can specify rules for updating tags and/or failing execution. The paper shows how this policy language can be used to implement monitors for memory safety, compartmentalization, and information flow.

Overall, I found the problem to be well motivated and the examples in the paper were convincing. In general, I love the idea and the writing is great with one big exception - the narrative is missing two big pieces. Firstly, how it works i.e. more detail on how these monitors execute at runtime via PIPE. Secondly, that it works i.e. some description of the actual implementation, reference to things you have executed (i.e. benchmarks or case studies). With neither of these, I am not sure that this great idea is more than a great idea. There are also some questions about the practicality and usability of the approach that would probably appear if those topics were addressed. But, as implementation details are missing, we donโt get to think about such things.

However, I believe that there would still be merit to this paper if the missing pieces of narrative revealed that the implementation was still relatively immature. Therefore, I (weakly) recommend acceptance but encourage the authors to address these points regarding narrative.

Minor points:

- Including page numbers makes this job easier!

- Fig 1. Iโm not sure if there is a good solution to this but I struggled to read Fig 1 at the point it was first referenced as the syntax for tags and the meaning of some symbols (e.g. {\cal P}) had not yet been introduced (it comes at the top of the next page)

- Fig 2. I assume the rule to tag the input to f as High is artificial and that in reality, we would expect the passkey to get High security when it is first generated and then this would be traced to the input of f by propagating tags. Indeed, in part 2 of the example I donโt see the ArgT rule being extended to tag the input to g. For me, things would be more convincing if the input to f were not tagged but the assumption that psk will have been tagged H is made.

- Section 3. I didnโt pick up a clear intuition behind the value/pointer/location tag distinction. I think I can infer this but I didnโt see it discussed.

- In the example expression step reduction for binary operations the left reduction is meant to be tag-less but has a tag. On the right side, Iโm unsure why the premise gains two Eval calls. There is also some inconsistency in how the state is presented e.g. parenthesised (on the left) or not (on the right).

- In the paragraph on Memory it is unclear why you have the distinction between public and private. The point that it is strong enough to support a reasonable notion of semantics-preserving compilation doesnโt give us much detail. I assume the reason that PIPE isnโt used to enforce memory safety throughout is due to overhead? This is important as itโs a motivator for the whole work - if we could use PIPE for memory safety then we wouldnโt need Tagged C. So, why canโt we use PIPE?

- Fig 6. Should we be concerned about overflow with CLR(c + 1)? In general, Iโm unclear how expressive we can get with data stored in tags and the computations on this data as weโre missing the necessary information about implementation - later itโs mentioned that we could use the PC tag to track live objects, which sounds like weโre storing unbounded information in tags.

- Fig 6. I assume that assert means if(not condition) then failstop, but this isnโt stated

- The reference to Section 4.1 should probably be a reference to Fig 7. I got very confused in this paragraph due to this mistake. Itโs never explicitly stated that you combine the rules from Fig 6 with those from Fig 7, although implied.

- In the compartmentalisation example, could you use a special gate function instead of introducing malloc_share? If the source code needs altering anyway wouldnโt it be easier to introduce a gate function at the point memory is allowed to pass between compartments and then intercept this gate function in the rules. I expect that needing to use malloc_share would lead to more data being tagged as shareable than should be.

- Again, the claim that we can use this approach for MAC leaves me wondering how much complexity we can encode in tags

FIXED - โprooperties" typo

- I think youโre implying that you havenโt done the Proofs you want to do. Please just say that. If thatโs not the case then this bit needs to be clearer.

- Are there alternatives to PIPE? This is hard to ask as the details are missing from the paper but could something like CHERI be used for a limited subset of tags that apply only to locations/pointers? Can you compile to a software implementation for execution on non-PIPE-supported processors? 

FIXED (could do more) - The paper ends abruptly. Usually, itโs kind to the reader to spend a paragraph โConcludingโ i.e. reminding me what you think you just told me
