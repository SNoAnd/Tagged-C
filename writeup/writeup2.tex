\documentclass{llncs}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{xcolor, colortbl}
\usepackage{stmaryrd}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage[capitalize]{cleveref}
\usepackage{tikz}
\usepackage{array}
\usepackage[most]{tcolorbox}

\tcbset{on line, boxsep=0pt, left=0pt, right=0pt, top=0pt, bottom=0pt, colframe=blue!100, colback=blue!10}

\usetikzlibrary{automata,positioning,shapes.multipart,arrows.meta}

\title{Flexible Runtime Security Enforcement with Tagged C}
\author{Sean Anderson \and Allison Naaktgeboren \and Andrew Tolmach}
\institute{Portland State University}

\begin{document}

\input{macros.tex}
\input{tagrules.tex}
\input{semantics.tex}
\input{memorygraphics.tex}

\maketitle

\begin{abstract}
Today's computing infrastructure is built atop layers of legacy C code, 
which is often insecure, poorly understood, and difficult to maintain.
Security can be improved by using runtime reference monitors, including those
implemented using hardware support, such as the PIPE (Processor
Interlocks for Policy Enforcement) processor extensions. Unfortunately,
existing PIPE-based systems require security policies to be expressed at the ISA level,
which makes them opaque to C developers and hard to apply to higher-level language features.
To address this problem, we introduce Tagged C, a novel C variant with
built-in tag-based reference monitoring that can be enforced by PIPE.
Tagged C expresses security policies at the level of C source code rather than the ISA.
It is designed to express a variety of dynamic security policies,  
individually or in combination, and enforce them with compiler and hardware support.
Tagged C supports multiple approaches to security and varying levels of strictness. We demonstrate
this range by providing examples of memory safety, compartmentalization,
and secure information flow policies. We also give a full formalized semantics
and a reference interpreter for Tagged C.
\end{abstract}

\section{Introduction}
Many essential technologies rely on new and old C code.
Operating systems (Linux, Windows, OSX, BSD), databases (Oracle, sqlite3), the internet
(Apache, NGNIX, NetBSD, Cisco IOS), and the 
embedded devices that run our homes and hospitals are built in and on C \cite{Munoz:PoweredbyC}. 
%C is not a relic; more than a third of professional programmers report active developing
%in C today \cite{stackoverflow22:dev-survey}. \apt{That sentence seems off topic of ``essential technologies.''}
The safety of these technologies
depends on the security of their underlying C codebases.
Insecurity can arise from C
undefined behavior (UB) such as memory errors (e.g. buffer overflows, use-after-free, double-free),
logic errors (e.g. SQL injection, input-sanitization flaws), or
larger-scale architectural flaws (e.g. over-provisioning access rights).

Although static
analyses can detect and mitigate many C insecurities, a last line of
defense against undetected or unfixable vulnerabilities is runtime
enforcement of {\em security policies} using a reference
monitor~\cite{Anderson72:PlanningStudy}. In particular, 
many useful policies can be specified in terms of flow constraints on 
\emph{metadata tags}, which augment the underlying data with information like type, provenance,
ownership, or security classification. A tag-based policy takes the form of a set of
rules that check and update the metadata tags at key points during execution; if a rule violation is
encountered, the program failstops. 
Although monitoring based on metadata tags is less flexible and powerful than monitoring based on the
underlying data values, it can still enforce many useful security properties, including
both low-level concerns, such as fine-grained memory safety~\cite{Witchel02:MondrianMem}, and high-level
properties like secure information flow~\cite{Denning76:SFIlattice} and mandatory access control~\cite{USDoD85:OrangeBook}. 

Tag-based policies are especially well-suited for efficient hardware enforcement, using 
processor extensions such as ARM MTE~\cite{arm-mte},
STAR~\cite{Gollapudi+23}, and
PIPE.  PIPE\footnote{ Variants of PIPE have
been called PUMP~\cite{Dhawan+14,Dhawan+15},
SDMP~\cite{Dover16,RoesslerD18} or CoreGuard~\cite{Dover20}.} 
(Processor Interlocks for Policy Enforcement)~\cite{Dhawan+15,Azevedo+16,Azevedo+15},
the specific motivator for our work, 
is a programmable hardware mechanism that supports monitoring 
at the granularity of individual instructions. 
Each value in memory and registers
is extended with a metadata tag. Before executing each instruction,
PIPE checks the opcode and the tags on its operands to see if the operation 
should be permitted according to a tag rule, and if so, what tags should be 
assigned to the result.
PIPE is highly flexible: it supports
arbitrary software-defined tag rules over large (word-sized) tags with arbitrary structure,
which enables fine-grained policies and composition of multiple policies. This flexibility 
is useful because security needs may differ radically among codebases,
and even within a codebase. A conservative, one-size-fits-all policy might be too strong,
causing failstops during normal execution. Sensitive code might call for its own specialized
protection.
 
%% \apt{There is still a thought I would like to express here about tag-based policies being
%%   relatively accessible to programmers, since they manipulate meta state just like ordinary
%%   programs manipulate state.  As opposed to, say, writing temporal logic formulae.  But (a)
%%   I can't find a good place to put this, and (b) seems like this advantage is also shared
%%   by AOP and similar approaches. So I'm leaving it out for now.}

But PIPE policies can be difficult for a C engineer to write: their tags and rules
are defined in terms of individual machine instructions and ISA-level
concepts, and in practice they depend on reverse engineering the behavior
of specific compilers. 
Moreover, some security policies can only be expressed in terms of high-level code
features that are not preserved at machine level, such as function
arguments, structured types, and structured control flow.

To address these problems, we introduce a \emph{source-level} specification framework, \emph{Tagged C},
which allows engineers to describe policies in terms of familiar C-level concepts, with tags attached to
C functions, variables and data values, and rules triggered at \emph{control points} that correspond to
significant execution events, such as function calls, expression evaluation, and pointer-based memory accesses. 
Control points resemble ``advice points'' in aspect-oriented programming, but are narrowly
focused on the manipulation of tags.\apt{revisit this after related work is done}
In previous work on the Tagine project~\cite{Chhak21:Tagine}, we outlined such a framework for a toy
source language and showed how high-level policies could be compiled to ISA-level policies and 
enforced using PIPE-like hardware.  Here we extend this approach to handle
the full, real C language, by giving a detailed design for the necessary control points and
showing how they are integrated into C's dynamic semantics. 
Although motivated by PIPE, Tagged C is not tied to any particular enforcement mechanism. 
We currently implement it using a modified C interpreter rather than a compiler.
We validate the design of Tagged C by using it to specify a range of interesting security policies,
including compartmentalization, memory protection, and secure information flow.

%Importantly, a security policy can be modified without recompilation unless it is optimized as described in
%\cref{sec:optionals}.

Formally, Tagged C is defined as a variant C semantics that instruments ordinary execution with control points.
At each control point, a user-defined set of tag rules is consulted to propagate tags and potentially cause
execution to failstop. In the limiting case where no tag rules are defined, the semantics are similar to
those of ordinary C, except that the memory model is very concrete; 
data pointers are just integers, and all globals, dynamically-allocated objects,
and address-taken objects are allocated in the same integer-addressed memory space. Memory behaviors
that would be undefined in standard C are given a definition % (parameterized by a particular allocation strategy)
consistent with the behavior of a typical compiler.
We build the Tagged C semantics on top of the CompCert C semantics, which are formalized 
as part of the CompCert verified compiler \cite{Leroy09:CompCert}. For prototyping and executing example policies,
we provide a reference interpreter also based on that of CompCert~\cite[Ch. 4]{Leroy22:CompCertManual},
written in the Gallina functional language of the Coq Proof Assistant~\cite{coq}.
Tag types and rules are also written directly in Gallina. 

The choice of control points and their associations with tag rules, as well as the tag rules'
signatures, form the essence of Tagged C's design. 
We have validated this design on the three classes of policies explored in this paper,
and, outside of a few known limitations discussed in \cref{sec:limitations}, % , such as substructural memory safety,
we believe it is sufficiently expressive to describe most other flow-based policies, although 
further experience is needed to confirm this.

\paragraph*{Contributions}

%\apt{Should still try to goose these up as Catalin suggested}
In summary we offer the following contributions:

\begin{itemize}
\item The design of a comprehensive set of {\em control points} at which the C language interfaces
  with a tag-based policy. These expand on prior work by encompassing the full C language
  while being powerful enough to enable a range of policies even in the presence of C's more challenging
  constructs (e.g., go-to, conditional expressions.)
\item Tagged C policies enforcing (1) compartmentalization, including a novel compartmentalization policy
  with separate public and private memory, (2) memory safety, with realistic memory models that allow
  low-level idioms to varying degrees, and (3) secure information flow.
\item A full formal semantic definition for Tagged C, formalized in Coq, describing how the control points
  interact with programs, and an interpreter, implemented in Coq and extracted to OCaml.
\end{itemize}

The paper is organized as follows.
\Cref{sec:example} gives a high-level introduction of metadata tagging by example.
\Cref{sec:language} summarizes the Tagged C language as a whole and its control points.
\Cref{sec:policies} describes three example policies and how their
needs inform our choices of control points. 
%\Cref{sec:evaluation} assesses the degree to
%which the design meets our goals of flexibility and applicability to realistic
%security concerns.
\Cref{sec:related} discusses related work, and \cref{sec:futurework} descibes limitations and future work.
The full formal Tagged C semantics appear in our tech report\footnote{Not yet available.}.\apt{fix as appropriate}

\section{Metadata Tags and Policies, by Example}
\label{sec:example}

Consider a straightforward security requirement for a program that handles sensitive passkeys:
``do not leak passkeys on insecure channels.'' This is an instance of a broad class of
{\em secure information flow} (SIF) policies. Suppose the code on the left in \cref{fig:ex1} is part of
such a system, where {\tt psk} is expected to be a passkey and {\tt printi}
prints an integer to an insecure channel, so {\tt f} indirectly performs a leak via the
local variable {\tt x}.  We now explain how a monitor specified in Tagged C could detect
such a leak. (Of course, this particular leak could also be easily found using static analysis.)

\begin{figure}[t]
  \begin{tikzpicture}[every text node part/.style={align=left}]
    \node[matrix, ampersand replacement=\&, anchor=west] (code)
         {
           \node (l1) {\tt 1 void f(int psk) \{}; \\
           \node (l2) {\tt 2 ~ ~ int x = psk+5;}; \\
           \node (l3) {\tt 3 ~ ~ printi(x);}; \\
           \node {\tt 4 \}}; \\
         };

    \node[node distance=5em, right=of code.north] (mid1) {};
  
    \node[matrix, ampersand replacement=\&, node distance=6em, right=of code.north,draw] (table1)
         {
           \node[anchor=north] {\tt f}; \&
           \node[anchor=north, fill=gray!20] {\(\mathtt{psk} \mapsto i \tagat \vt[_1]\) \\ \(\mathtt{x} \mapsto \vundef \tagat \vt[_2]\)}; \&
           \node[anchor=north, fill=blue!10] {\(\vt[_1] \leftarrow \argtname(\vt[_0],\FN[f],\AN[psk])\) \\ \(\vt[_2] \leftarrow \constt\)};\\
         };

    \node[matrix, ampersand replacement=\&, node distance=4.5em, below=of table1.west,draw,anchor=west] (table2)
         {
           \node[anchor=north] {\tt f}; \&
           \node[anchor=north, fill=gray!20] {\(\mathtt{psk} \mapsto i \tagat \vt[_1]\) \\ \(\mathtt{x} \mapsto (i+5) \tagat \vt[_4]\)}; \&
           \node[anchor=north, fill=blue!10] {\(\vt[_3] \leftarrow \constt\) \\
             \(\vt[_4] \leftarrow \binoptname(+,\vt[_2],\vt[_3])\) }; \\
         };

    \node[matrix, ampersand replacement=\&, node distance=4.5em, below=of table2.west,draw,anchor=west] (table3)  
         {
           \node[anchor=north] {\tt printi}; \&
           \node[anchor=north, fill=gray!20] {\(\mathtt{a} \mapsto i \tagat \vt[_5]\)}; \&
           \node[anchor=north, fill=blue!10] {\(\vt[_5] \leftarrow \argtname(\vt[_4], \FN[printi], \AN[a])\)}; \\
         };

    \draw[Circle-]
    (l1.south) -| (mid1.center);
    \draw
    (mid1.center) -- (table1.west);

    \draw[Circle-]
    (l2.south) -| (table2.west);

    \draw[Circle-]
    (l3.south) |- (table3.west);  

  \end{tikzpicture}

  \caption{Example program execution showing tag rules and tag propagation.}
  \label{fig:ex1}
\end{figure}

\begin{figure}[t]
    \(\tau::=\high | \low\)
    \argtexruleblock
        {\caseofthree{\((\vt,\FN,\AN)\)}
          {(\(\high,\mathtt{printi},\underline{~~}\))}{\(\fail\)}
          {(\(\underline{~~},\mathtt{f},\mathtt{psk}\))}{\(\vt':=\high\)}
          {\(\underline{~~~}\)}{\(\vt':=\vt\)}}
    \consttruleblock{\(\vt' := \low\)}
    \binoptexruleblock
        {\caseoftwo{\((\vt[_1],\vt[_2])\)}
          {(\(\low,\low\))}{\(\vt':=\low\)}
          {\(\underline{~~~}\)}{\(\vt':=\high\)}}

  \caption{Tag rule instantiations for secure information flow (pt. 1)}
  \label{fig:example1rules}
\end{figure}

In Tagged C, all values carry a metadata tag. Whenever execution reaches a control point, it consults
an associated tag rule, to check whether the next execution step should be allowed to continue and
if so, to update the tags. A policy consists of a tag type definition and instantiations of the tag rules for every control point.
For a simple SIF policy like this one, the tag type is an enumeration containing \(\high\) (high security)
and \(\low\) (low security).
In this case, when {\tt f} processes its arguments, a program-specific tag rule 
will tag {\tt psk} as \(\high\). This tag will be propagated along with the value through variable accesses,
assignments, and arithmetic, according to generic rules that are not specific to this program.
Finally, a program-specific argument-handling rule for {\tt printi} will check that the tag is \(\low\);
since it is not, the rule will cause a failstop.

To explain the mechanics of Tagged C, we first show in \cref{fig:ex1} the policy-independent details of how
tags flow and where tag rules are triggered in this program; then in \cref{fig:example1rules}
we describe how the tag rules are instantiated for a particular policy like the one above.
\Cref{fig:ex1} maps three points in the execution of {\tt f} to descriptions of the program
state at that point, with the input value and all tags treated symbolically.
% APT: It is very confusing and irritating that these points are not (in general) control points.
In each state, the first column (white) shows the active function, the second (gray) gives the symbolic values and tags
of variables in the local environment, and the third (blue) shows the rules that produce those tags.
Throughout the paper, we highlight tag-related metavariables, rules, etc. in {\color{blue}blue}.
We write \(v\tagat \vt\) for value \(v\) tagged with \(\vt\).
Tags that are derived from identifiers are subscripted with the identifier namespace, e.g.
\(\FN[f]\) is the tag associated with the function name {\tt f}.  
\(\vundef\) denotes an uninitialized value.

Suppose {\tt f} is called with an actual argument \(i\tagat \vt[_0]\).
The tag on {\tt psk} comes from \(\argtname\), which is parameterized by the tag \(\vt[_0]\) from the argument
value and by the names of both the function
and the argument. The initial tag \(\vt[_2]\) on local
variable {\tt x} is the default tag \(\consttname\).
The result of the addition on line 2 is tagged by \(\binoptname\), which is parameterized
by the kind of operation as well as the tags on its inputs.
After the final step, execution is in the function {\tt printi}, which consults
\(\argtname\) again to obtain the tag on its parameter (here called {\tt a}).\footnote{
For simplicity, we omit showing tag rules \(\accesstname\) and \(\assigntname\), 
which are triggered each time a variable is read and assigned, respectively, because these
don't play an interesting role in this example.}

The SIF policy described informally above is implemented by instantiating the
tag rules as shown in \cref{fig:example1rules}. 
In tag rules,
the assignment operator := denotes an assignment to the named tag-rule output, by convention
written as primed metavariables \(\gentag[']\).  The \(binoptname\) rule is a
generic SIF rule that says the result tag is the higher of the two operand tags. 
\(\argtname\) connects the policy to the specifics of the program, identifying {\tt psk}
as high-security data and treating {\tt printi} as a low-security output channel by
triggering a failstop if it receives high-security data.

As a second example, \cref{fig:ex2} steps through the execution of a function {\tt g} that adds two new wrinkles:
we need to keep track of metadata associated with
addresses and with the program's control-flow state. We suppose {\tt mm} is
a memory-mapped device register that can be read from outside the program, so we want to avoid storing the passkey there;
therefore we need a way to monitor stores to memory.  Furthermore, although this code does not leak the passkey directly,
it does so indirectly: since the store to {\tt mm} is conditional on testing {\tt psk},
an outside observer of {\tt mm} can deduce one bit of the key (an {\em implicit flow}~\cite{Denning76:SFIlattice}).

\begin{figure}[t]
\begin{tikzpicture}[every text node part/.style={align=left}]
  \node[matrix, ampersand replacement=\&, anchor=west] (code)
       {
         \node {\tt 1 volatile int mm=0;}; \\
         \node (l1) {\tt 2 void g(int psk) \{}; \\
         \node (l2) {\tt 3 ~ ~ if(psk > 0)}; \\
         \node (l3) {\tt 4 ~ ~ ~ ~ mm = 1;}; \\
         \node {\tt 5 ~ ~ \}}; \\
         \node {\tt 6 \}}; \\
       };

  \node[matrix, ampersand replacement=\&, node distance=6em, right=of l1.north,draw,anchor=west] (table1)  
       {
         \node[anchor=north] {\(g \tagat \PCT[_1]\)}; \&
         \node[anchor=north, fill=gray!20] {\(\mathtt{mm} \mapsto p \tagat \pt[_1] \) \\
           \(p:\fbox{\(0 \tagat \vt[_1] \tagat \lt[_1]\)}\) \\
           \(\mathtt{psk} \mapsto i \tagat \vt[_2]\)
         }; \&
         \node[anchor=north, fill=blue!10] {\(\pt[_1], \vt[_1],\lt[_1] \leftarrow \globaltname(\GN[mm])\) \\
           \(\PCT[_1] \leftarrow \calltname(\PCT[_0], \FN[g])\)  \\
           \(\vt[_2] \leftarrow \argtname(\vt[_0],\FN[g],\AN[psk])\)}; \\
       };
       
 \node[matrix, ampersand replacement=\&, node distance=5em, below=of table1.west,draw,anchor=west] (table2)         
      {
        \node[anchor=north] {\(g \tagat \PCT[_2]\)}; \&
        \node[anchor=north, fill=gray!20] {\(\mathtt{mm} \mapsto p \tagat \pt[_1]\) \\
          \(p:\fbox{\(0 \tagat \vt[_1] \tagat \lt[_1]\)}\) \\
          \(\mathtt{psk} \mapsto i \tagat \vt[_2]\)
        }; \&
        \node[anchor=north, fill=blue!10] {\(\vt[_3] \leftarrow \constt\) \\
          \(\vt[_4] \leftarrow \binoptname(>,\vt[_2],\vt[_3])\) \\ 
          \(\PCT[_2] \leftarrow \splittname(\PCT[_1], \vt[_4])\)}; \\
      };

 \node[matrix, ampersand replacement=\&, node distance=6em, below=of l3,draw,anchor=west] (table3)         
      {
        \node[anchor=north] {\(g \tagat \PCT[_2]\)}; \&
        \node[anchor=north, fill=gray!20] {\(\mathtt{mm} \mapsto p \tagat \pt[_1]\) \\
          \(p:\fbox{\(1 \tagat \vt[_7] \tagat \lt[_2]\)}\) \\
          \(\mathtt{psk} \mapsto i \tagat \vt[_2] \)
        }; \&
        \node[anchor=north, fill=blue!10] {\(\vt[_5] \leftarrow \constt\) \\
          \(\vt[_6] \leftarrow \assigntname(\PCT[_2]
          ,\vt[_1],\vt[_5])\) \\
          \(\PCT[_3],\vt[_7],\lt[_2] \leftarrow \storetname(\PCT[_2],\pt[_1],\vt[_6],\lt[_1])\)}; \\
      };

  \draw[Circle-]
  (l1.south) -| (table1.west);

  \draw[Circle-]
  (l2.south) -| (table2.west);

  \draw[Circle-]
  (l3.south) |- (table3.west);  

\end{tikzpicture}
\caption{Second example showing tag rules and tag propagation.}
\label{fig:ex2}
\end{figure}

In addition to tags on values, Tagged C attaches tags to memory locations ({\em location tags}, ranged over by
\(\lt\)) and tracks a special global tag called the PC tag (ranged over by \(\PCT\), and attached to the
function name in our diagrams).
Tagged C initializes the tags on {\tt mm} with the \(\globaltname\) rule. The PC tag
at the point of call, \(\PCT[_0]\), is fed to \(\calltname\) to determine a new PC tag
inside of {\tt g}. And the if-statement consults the \(\splittname\) rule to update the PC tag
inside of its branch based on the value-tag of the expression {\tt psk < 0}. Once inside the
conditional, when the program assigns to {\tt mm}, it must consult both the
\(\assigntname\) rule as normal and the \(\storetname\) rule because it is storing
to memory.\apt{Could we just omit \(\assigntname\) again??? see next comment}

\Cref{fig:example2rules} shows an instantiation of these rules that extend our previous SIF policy.
The rule for globals initializes the location tag of {\tt mm} to \(\low\),
as a low-security output channel, and marks all other addresses \(\high\). Whenever execution branches on
a high-tagged value, the PC tag will be set to \(\high\). We modify the previous rules so that
assignments propagate the higher of the tag on the value being assigned and the PC tag, meaning that an
assignment under a high PC remains high.\apt{But this is not shown -- super confusing! 
  And I thought we agreed this was a bogus way
  to raise the PC anyway: consider something like {\tt if (hi) f(x+x);} -- here the {\tt x+x} is high, even though it is not assigned to anything. So instead PC tag should be ANDed into consts, binops, etc.}
\sna{We discussed that there are two ways to do this. The one shown, and the one you're describing.
  They should be equivalent. As for the call example, the PC tag really ought to remain high during the call,
  since other branches might not make a call at all, and the callee might make an output. So whether
  or not {\tt x+x} is high doesn't matter all that much. That said, I fell into the trap again of
  confusing storet with assignt, and your version of the policy doesn't have that trap, so that's nice.}
When an assignment is to a memory location, the store rule will check the tag on
that location against the value being written, 
and failstop if a high value would be written to a low location.
For this program, \(\splittname\) will set the PC tag to \high, as it branches on a value derived from {\tt psk}; 
then, at the write to {\tt mm}, \(\storetname\) will fail rather than write to a low address
in a high context.

\begin{figure}[t]
  \globaltruleblock{
    \(\vt':=\low\); \(\pt':=\low\) \\
    \caseoftwo{x}
              {\tt mm}{\(\lt':=\low\)}
              {\(\underline{~~~}\)}{\(\lt':=\high\)}}
  \truleblock{\(\splittname(\PCT,\vt)\)}{
    \caseoftwo{(\(\PCT,\vt\))}
              {(\(\low,\low\))}{\(\PCT':=\low\)}
              {\(\underline{~~~}\)}{\(\PCT':=\high\)}
  }
  \storetruleblock{
    \(\lt':=\lt\); \(\PCT':=\PCT\) \\
    \caseofthree{(\(\PCT,\vt,\lt\))}
                {(\(\high,\underline{~~},\high\)) \\
                  (\(\underline{~~},\high,\high\))
                }{\(\vt':=\high\)}
                {(\(\low,\low,\low\))}{\(\vt':=\low\)}
                {\(\underline{~~~}\)}{\(\fail\)}
  }
\caption{Tag rule instantiations for secure information flow (pt. 2)}
\label{fig:example2rules}
\end{figure}


\section{The Tagged C Language: Syntax and Semantics}
\label{sec:language}

\begin{table}[t]
  \begin{tabular}{|l|l|l|l|}
    \hline
    Rule Name & Inputs & Outputs & Control Points \\
    \hline
    \(\calltname\)      & \(\calltargs\)         & \(\calltres\)      & Update PC tag at call \\
    \(\argtname\)       & \(\argtargs\)          & \(\argtres\)       & Per argument at call \\
    \(\rettname\)       & \(\rettargs\)          & \(\rettres\)       & Handle PC tag, return value \\
    \(\loadtname\)      & \(\loadtargs\)         & \(\loadtres\)      & Memory oads \\
    \(\storetname\)     & \(\storetargs\)        & \(\storetres\)     & Memory stores \\
    \(\accesstname\)    & \(\accesstargs\)       & \(\accesstres\)    & Variable accesses \\
    \(\assigntname\)    & \(\assigntargs\)       & \(\assigntres\)    & Variable assignments \\
    \(\unoptname\)      & \(\unoptargs\)         & \(\unoptres\)      & Unary operation \\
    \(\binoptname\)     & \(\binoptargs\)        & \(\binoptres\)     & Binary operation \\
    \(\consttname\)     & \(\consttargs\)        & \(\consttres\)     & Applied to constants/literals \\
    \(\inittname\)      & \(\inittargs\)         & \(\inittres\)      & Applied to fresh variables \\
    \(\splittname\)     & \(\splittargs\)        & \(\splittres\)     & Control-flow split points in statements\\
    \(\labeltname\)     & \(\labeltargs\)        & \(\labeltres\)     & Labels/arbitrary code points \\
    \(\exprsplittname\) & \(\exprsplittargs\)    & \(\exprsplittres\) & Control-flow split points in expressions \\
    \(\exprjointname\)  & \(\exprjointargs\)     & \(\exprjointres\)  & Join points in expressions \\
    \(\globaltname\)    & \(\globaltargs\)       & \(\globaltres\)    & Program initialization \\
    \(\localtname\)     & \(\localtargs\)        & \(\localtres\)     & Stack allocation (per local) \\
    \(\dealloctname\)   & \(\dealloctargs\)      & \(\dealloctres\)   & Stack deallocation (per local) \\
    \(\extcalltname\)   & \(\extcalltargs\)      & \(\extcalltres\)   & Call to linked code \\
    \(\malloctname\)    & \(\malloctargs\)       & \(\malloctres\)    & Call to {\tt malloc} \\
    \(\freetname\)      & \(\freetargs\)         & \(\freetres\)      & Call to {\tt free} \\
    \(\fieldtname\)     & \(\fieldtargs\)        & \(\fieldtres\)     & Structure/union field access \\
    \(\picasttname\)    & \(\picasttargs\)       & \(\picasttres\)    & Cast from pointer to scalar \\
    \(\ipcasttname\)    & \(\ipcasttargs\)       & \(\ipcasttres\)    & Cast from scalar to pointer \\
    \(\ppcasttname\)    & \(\ppcasttargs\)       & \(\ppcasttres\)    & Cast between pointers \\
    \(\iicasttname\)    & \(\iicasttargs\)       & \(\iicasttres\)    & Cast between scalars \\
    \hline
  \end{tabular}

  \caption{Full list of tag-rule signatures and control points. Key to metavariables:
    \(\PCT\): PC tag, \(\vt\): value tag, \(\pt\): pointer tag, \(\lt\): location tag,
    \(\FN\): function identifier, \(\AN\): function argument, \(\GN\): global
    variable name, \(\LN\): label, \(\TN\): type.}
  \label{fig:controlpoints}
\end{table}

Tagged C contains almost all features of full ISO C 99.\footnote{
It inherits the limitations of CompCert C, primarily that {\tt setjump} and {\tt longjump}
may not work, and variable-length arrays are not supported.~\cite[Ch. 5]{Leroy22:CompCertManual}.}
Its semantics (given in full in the Appendix)
are based on that of CompCert C~\cite{Leroy09:CompCert},
a formalization of the C standard into a small-step reduction semantics.
Tagged C's semantics differ from CompCert C's in two key respects: tag support and memory model.

\paragraph{Tags}
First, Tagged C's values
and states are annotated with metadata tags, and its reductions contain
control points, which are hooks within the
operational semantics at which the tag policy is consulted and either tags are updated, or the system
failstops. A control point consists of the name of a {\em tag rule}
and the bindings of its inputs and outputs. For example, consider the expression step reduction
for binary operations:

\begin{minipage}[t]{0.37\textwidth}
  \binopsteptagless
\end{minipage}
\begin{minipage}[t]{0.6\textwidth}
  \binopstep
\end{minipage}

\noindent
On the left, the ordinary ``tagless'' version of the rule reduces a
binary operation on two inputs to a single value.
On the right, the Tagged C version adds tags to the operands and tags the result
based on the \(\binoptname\) rule. \sna{Instance of a tag rule?}

The tag rule itself is instantiated as a partial function; if a policy leaves a tag rule
undefined on some inputs, then those inputs violate the policy, sending
execution into a special failstop state. The names and signatures of all the tag rules,
and their corresponding control points, are listed in \Cref{fig:controlpoints}.
We briefly summarize the rules here, and give motivating examples of their use in \cref{sec:policies}

Nearly all the rules are parameterized by the current PC tag \(\PCT\), and the rules
for control points associated with changes in program state (variable or memory update,
change in control flow) can produce a changed \(\PCT'\) as a result.
\(\calltname\)
and \(\rettname\) update the PC tag on entry and exit from a function.
\(\calltname\) is parameterized by the function pointer being called.
\(\rettname\) is parameterized by both the caller's PC tag (\(\PCT[_{\color{blue} CLR}]\))
and the callee's (\(\PCT[_{\color{blue} CLE}]\)); it can also update the return value's tag.
\(\argtname\) updates tags on any arguments, based on the function and argument names.
\(\loadtname\) and \(\storetname\) deal with memory accesses, while \(\accesstname\) and
\(\assigntname\) are invoked on variable access and assignment regardless of whether the variable
is in memory.
\(\unoptname\) and \(\binoptname\) handle operations, \(\consttname\) is the default tag
on all constants, and \(\inittname\) is the initial tag in a fresh variable.
\(\splittname\), \(\labeltname\), \(\exprsplittname\), and \(\exprjointname\) 
update the PC tag based on changes in control flow in statements and expressions.
\(\fieldtname\) updates the tag on a pointer value when it is offset to access the field of a struct or union.
\(\globaltname\), \(\localtname\),
and \(\malloctname\) are each associated with the allocation of memory, and are
parameterized by the type of the allocated value. The latter
two have corresponding deallocation rules \(\dealloctname\) and \(\freetname\),
respectively. The cast rules are specialized based on whether the original type or
the new type is a pointer, or both.

\paragraph{Memory} The second major semantic distinction of Tagged C is that, unlike CompCert C,
it has no memory-related UB. CompCert C models memory as a collection of disjoint blocks,
and treats each variable as having its own block. Pointers are described by a (block, offset) pair,
and invalid pointer accesses (out-of-bounds, use after free, etc.) produce UB.
Tagged C instead separates variables
into public and private data. Public data (all heap data, globals, arrays, structs, and
address-taken locals) share a single flat address space (possibly with holes), and pointers are
offsets into this space. Pointer accesses outside of this space cause
an explicit failstop, rather than UB. 
Private data (non-address-taken locals, parameters) live in a separate, abstract environment.
Program-specified stores, e.g. writes through pointers, can cause arbitrary damage to public
data, but do not affect private data. 
This model is strong enough to support a reasonable
notion of semantics-preserving compilation, without making any commitment about fine-grained
memory safety, which is intentionally left for explicit tag policies to specify (see \cref{sec:memsafe}).
In an implementation that compiles to PIPE, the private data can be protected by a small number of
``built-in'' tags.
%In terms of exploits, it prevents control-only attacks,
%but allows data-only and data-bending attacks/

%Without memory safety, programs
%that exhibit memory-undefined behavior will act as their compiled equivalents would, potentially
%corrupting memory; we expect that a memory safety policy will be a standard default, but that the
%strictness of the policy may need to be tuned for programs that use low-level idioms.

%% APT: This seems out of place and superceded by discussion above.
%% \paragraph*{Parts of a policy}

%% A policy consists of instantiations of the tag type
%% and each of the tag rules associated with control points in the semantics. Table \cref{figcontrolpoints}
%% identifies the full collection of control points, their tag rules, and the inputs and outputs of the tag rules.
%% The tag type \(\tau\) must be inhabited by a default tag.

\paragraph{Combining Policies}

Multiple policies can be enforced in parallel. If policy \(A\) has tag type \(\tau_A\)
and policy \(B\) has \(\tau_B\), then policy \(A \times B\) should have tag type
\(\tau = \tau_A \times \tau_B\). Its tag rules should apply the rules of \(A\) to
the left projection of all inputs and the rules of \(B\) to the right projection
to generate the components of the new tag. If either side failstops, the entire
rule should failstop.

This process can be applied to any number of different policies, allowing, for instance,
a combination of a baseline memory safety policy with several more targeted
information-flow policies. Alternatively, a policy can call on the tag rules
from other, related policies, as illustrated in \cref{sec:compartments}, below.

\section{Example Policies}
\label{sec:policies}

In this section, we discuss concrete policy implementations and how 
they motivate Tagged C's control point design. Memory safety policies
inform our requirements for memory tags and type casts. Compartmentalization
policies depend on the call- and return-related control points, to keep track of the
active compartment. Secure information flow policies expose the many places
where the user may need to reference identifiers from their program in the policy itself.
Taken toogether, these example policies illustrate Tagged C's breadth of application.

\subsection{Memory Safety}
\label{sec:memsafe}

Tagged C can be used to enforce memory safety with respect to different {\em memory models}---formal
or informal descriptions of how C should handle memory. Here we discuss the CompCert C
memory model and two models proposed by Memarian et al. \cite{Memarian19:ExploringCSemantics}
for the purposes of supporting low-level idioms in the presence of compiler optimization, focusing in particular on how they handle
casts from pointers to integers and back.

While the idea of a valid pointer may seem obvious, the precise definition can vary. The C standard
does not support arbitrary arithmetic on pointers or their integer casts.  In practice, it is common for programs to violate the
C standard to various degrees; see \cref{fig:memsafe}. For example, if objects are known to be aligned to \(2^n\)-byte boundaries,
the low-order \(n\) bits of pointers can be ``borrowed'' to store other data~\cite{Memarian16:DeFacto}.
The possible presence of these low-level idioms means that there is no one-size-fits all memory safety policy.
CompCert C's definition of a valid pointer allows the pointer to be cast into an integer and back, but only if its value
does not change in the interim. This is very strict! Programs that use low-level idioms
would failstop if run under a policy that enforces this.

Memarian et al.'s first memory model, {\em provenance via integer} (PVI), treats memory
as a flat address space, and pointers as integers with additional provenance information
associating them to their objects. Pointers maintain this provenance even through casts to
integers and the application of arithmetic operations. When cast back, the pointers will still
be associated with the same object. This enables many low-level idioms, while still forbidding
memory-safety violations like buffer overflows.

On the other hand, their second model, {\em provenance not via integer} (PNVI), clears the
provenance of a pointer when it is cast to an integer. When an integer is cast to a pointer
(whether or not it was previously derived from a pointer), it takes on the provenance of whatever
it points to at that time. The security value of this memory model is questionable, but
it is a realistic option for a compiler to choose and can support idioms that PVI cannot.

\paragraph*{Implementation}

The basic idea for enforcing any of the above memory safety variants is a ``lock and key'' approach~\cite{Clause07:MemsafeTainting,Azevedo+15}.
Whenever an object is allocated, it is assigned a unique ``color,'' and its memory locations as well
as its pointer are tagged with that color, written \(\clr\).
The default tag \(\N\) indicates a non-pointer or non-allocated location.
The PC tag will also be \(\clr\),
tracking the next available color for new allocations. These rules are given in \cref{fig:memgen}.
Operations that are valid on pointers in a given memory model
maintain the pointer's color, and loads and stores are legal if the pointer tag matches the target memory
location tag.

The specific memory models (\cref{fig:memspecial})  behave differently when pointers are cast to integers and back.
The CompCert C variant marks that the integer has been cast from a valid pointer, and
restores that provenance when cast back. But, \(\binoptname\) will failstop if it is
actually modified between the casts. PVI simply keeps the provenance and allows all operations
between casts. PNVI accesses the memory pointed to by the (soon-to-be) pointer and takes its
location tag.

\begin{figure}[t]
  \small
\begin{tikzpicture}[every text node part/.style={align=left}]
  \node[matrix, ampersand replacement=\%, anchor=west] (code)
        {
          \node {\tt 1  int x[1],y[1];}; \%
          \node[fill=gray!20] {\(\mathtt{y} \mapsto a\tagat\pt_1\)}; \%
          \node[fill=blue!10] {\(\PCT_1,\pt_1,\lt_1 \leftarrow \localtname(\PCT[_0], \TN[int])\)}; \\
          \node {\tt 2  int p = (int) x;}; \%
          \node[fill=gray!20] {\(\mathtt{q} \mapsto a\tagat\vt[_1]\)}; \%
          \node[fill=blue!10] {\(\vt[_1] \leftarrow \picasttname(\PCT[_1],\pt[_1],\lt[_1], \TN[int])\)}; \\          
          \node {\tt 3  int q = (int) y;}; \%
          \%
          \node[fill=blue!10] {\(\vt[_2] \leftarrow \consttname(\PCT[_1])\)}; \\
          \node {\tt 4  int r = q | 0x1;}; \%
          \node[fill=gray!20] {\(\mathtt{r} \mapsto a\tagat\vt[_3]\)}; \%
          \node[fill=blue!10] {\(\vt[_3] \leftarrow \binoptname(\mid, \PCT[_1], \vt[_1], \vt[_2])\)}; \\
          \node {\tt 5  *(int *) p = 0;}; \%
          \%
          \node[fill=blue!10] {\(\vt[_4] \leftarrow \binoptname(\&, \PCT[_1], \vt[_3], \vt[_2]\)}; \\
          \node {\tt 6  *(int *) (r \& 0xfffffffe) = 0;}; \%
          \node[fill=gray!20] {\(a:\fbox{\(0 \tagat \vt[_5] \tagat \lt[_2]\)}\)}; \%
          \node[fill=blue!10] {\(\pt[_2] \leftarrow \ipcasttname(\PCT[_1],\vt[_4],\lt[_1],\TN[int *])\)}; \\
          \node {\tt 7  *(int *) (p + (q - p)) = 0;}; \%
          \%
          \node[fill=blue!10] {\(\PCT[_2],\vt[_5],\lt[_2] \leftarrow \storetname(\PCT[_1],\pt[_2],\vt[_2],\lt[_1]\))}; \\
          \node {\tt 8  x[1] = 0;}; \\
       };

\end{tikzpicture}

\caption{Memory Safety and Pointer Casts, Tracing {\tt y} and {\tt r}. (Assume {\tt int} and pointers are 32 bits.)
Line (5) is always legal, (6) is illegal in CompCert C, (7) is also illegal in PVI, and (8) is illegal in all models.}
\label{fig:memsafe}
\end{figure}

\begin{figure}[t]
  \color{blue}
  \begin{minipage}{0.3\textwidth}
    \(\begin{array}{lllr}
      \tau & ::= & \clr & c \in \mathbb{N} \\
      & | & \N \\
%      & | & \mathit{CAST}(\clr) & \textnormal{(CompCert only)} \\
    \end{array}\)
  \end{minipage}
  \scriptsize
  \begin{minipage}{0.22\textwidth}
    \localtruleblock
        {let \(\clr := \PCT\) in \\
          \(\PCT' := \clr[c+1]\) \\
          \(\pt' := \PCT\)\\
          \(\vt' := \N\);
          \(\lt' := \PCT\)
        }
    \loadtruleblock{\(\mathbf{assert} ~ \pt = \lt\) \\ \(\vt' := \vt\)}
  \end{minipage}
  \begin{minipage}{0.2\textwidth}
    \malloctruleblock
        {let \(\clr := \PCT\) in \\
          \(\PCT' := \clr[c+1]\) \\
          \(\pt' := \PCT\) \\
          \(\vt' := \N\);
          \(\lt' := \PCT\)
        }
    \storetruleblock{\(\mathbf{assert} ~ \pt = \lt\) \\
      \(\PCT' := \PCT\);
      \(\vt' := \vt\); 
      \(\lt' := \lt\)}
  \end{minipage}

  \caption{Generic Memory Safety Rules}
  \label{fig:memgen}
\end{figure}
\begin{figure}[t]
  \begin{subfigure}{\textwidth}
    \centering
    \color{blue}
    %
    \scriptsize
    %
    \begin{minipage}{0.4\textwidth}
      \picasttruleblock{\caseoftwo{\(\pt\)}{\(\clr\)}{\(\vt' := \mathit{CAST}(\clr)\)}{\(\underline{~ ~ ~}\)}{\(\vt' := \pt\)}}
      \ipcasttruleblock{\caseoftwo{\(\vt\)}{\(\mathit{CAST}(\clr)\)}{\(\pt' := \clr\)}{\underline{~ ~ ~}}{\(\vt' := \pt\)}}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
    \vspace{-2em}
    \(\color{blue} \tau ::= \ldots | \mathit{CAST}(\clr)\)

    \binoptruleblock{
      \caseofthree
          {\((\oplus, \vt_1,~ \vt_2)\)}
          {\((+,\clr,\N)\) \\ \((+,\N,\clr)\)}{\(\vt' := \clr\)}
          {\((\underline{~ ~},\N,\N)\) \\ \((-,\clr,\clr)\)}{\(\vt' := \N\)}
          {\(\underline{~ ~ ~}\)}{\(\fail\)}
    }
    \end{minipage}
    
    \caption{CompCert C Rules}
    \label{subfig:memcompcert}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \scriptsize

    \ipcasttruleblock{\(\pt' := \vt\)}

    \picasttruleblock{\(\vt' := \pt\)}

    \binoptruleblock{
      \caseofthree
          {\((\vt_1,~ \vt_2)\)}
          {\((\clr,\N)\) \\ \((\N,\clr)\)}{\(\vt' := \clr\)}
          {\((\N,\N)\)}{\(\vt' := \gentag\)}
          {\((\clr[c_1], \clr[c_2])\)}{\(\vt' := \N\)}
    }
    
    \caption{PVI Rules}
    \label{subfig:pvi}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \scriptsize
    
    \ipcasttruleblock{\(\pt' := \lt\)}

    \picasttruleblock{\(\vt' := \N\)}
    
    \binoptruleblock{
      \caseofthree
          {\((\oplus, \vt_1,~ \vt_2)\)}
          {\((+,\clr,\N)\) \\ \((+,\N,\clr)\)}{\(\vt' := \clr\)}
          {\((\underline{~ ~},\N,\N)\) \\ \((-,\clr,\clr)\)}{\(\vt' := \N\)}
          {\(\underline{~ ~ ~}\)}{\(\fail\)}
    }
    
    \caption{PNVI Rules}
    \label{subfig:pnvi}
  \end{subfigure}
    \label{fig:memspecial}
    \caption{Specialized Memory Safety Rules}
  \end{figure}

Memory safety also informs the design of control points related to allocating, deallocating, and
accessing memory. \(\malloctname\) and \(\freetname\) are special cases of the
\(\extcalltname\) control point. Drawing from CompCert C, Tagged C abstracts over
``external'' functions like {\tt malloc} and {\tt free}, rather than treat their implementation as
ordinary code. In a concrete system, these would be replaced by their library equivalents.
\(\extcalltname\) models the desired tag behavior of these libraries in the Tagged C semantics.

\paragraph*{Temporal Memory Safety}

The tag rules described so far only enforce spatial memory safety, but Tagged C also
supports enforcement of temporal safety. A full memory safety policy prevents use-after-free and
double-free errors by either retagging a deallocated region, or using the PC tag
to track live objects and revoking permissions on an object as soon as it is freed.

\subsection{Compartmentalization}
\label{sec:compartments}

In principle, the monitoring techniques in the previous section could be used
to detect all unintended memory safety violations (albeit only at run time) and ultimately to fix them.
But in reality, the cost and risk of regressions may make it
undesirable to fix bugs in older code \cite{Bessey10:Coverity}.  
%% In a perfect world, all C programs would be memory safe. In reality, it is common
%% for a codebase to contain undefined behavior that will not be fixed. Developers intentionally use 
%% low-level idioms that are UB \cite{Memarian16:DeFacto}, or the cost and risk of regressions may make it
%% undesirable to fix bugs in older code \cite{Bessey10:Coverity}. Running the CompCert C or even
%% the PVI policy described above might break such code, while the PNVI policy might not offer enough
%% protection.
%
A compartmentalization policy can isolate potentially risky code, such as code with unfixed
(or intentional) UB, from safety-critical code, and enforce the {\em principle of least privilege}. 
Even in the absence of language-level errors, compartmentalization can usefully 
restrict how code in one compartment may interact with another. External libraries are
effectively required for most software to function yet represent a supply-chain threat; isolating 
them prevents vulnerabilities in the library from compromising critical code,
and limits the tools available to attackers in the event of a compromise.

Let's assume that we have been given a compartmentalization policy, with at least two compartments, to add to the system
after development. The compartments and what belongs in them are represented in the policy by a set of compartment identifiers that 
are ranged over by \(C\), and a set of function and global identifiers mapped to compartments identified by \(\mathit{comp}(id)\).

\paragraph*{Implementation}

Compartmentalization requires the policy to keep track of the active compartment, which means
keeping track of function pointers. In Tagged C, function pointers are the exception to the
concrete memory model. They carry symbolic values that refer uniquely to their target functions.
If \(\mathtt{f}\) is located at the symbolic address \(\alpha\), then
% the expression {\(\var{\mathtt{f}}\) evaluates to \(\mathtt{f}\tagat\FN[f]\). 
the expression {\tt \&f} evaluates to \(\alpha\tagat\FN[f]\).
When the function pointer is called, Tagged C invokes \(\callt\), where \(\pt\) is the
function pointer's tag, to update the PC tag.
On return, in addition to handling the return value (if any), \(\rett\) determines a new PC tag
based on the one before the call (\(\PCT[_{CLR}]\)) and the one at the time of return (\(\PCT[_{CLE}]\)).

In our compartmentalization policy (\cref{fig:compartments}), we define a tag to be a compartment
identifier or the default \(\N\) tag. The PC tag always carries the compartment of the
active function, kept up to date by the \(\calltname\) and \(\rettname\) rules.

\begin{figure}[t]
  \color{blue}
  \begin{minipage}[t]{0.3\textwidth}
    \vspace{-2em}
    \(\color{blue} \tau ::= C | \N\)

    \calltruleblock{\(\PCT' := \mathit{comp}(f')\)}
  
    \rettruleblock{\(\PCT' := \PCT_{CLR};\vt':=\vt\)}
  \end{minipage}
  \scriptsize
  \begin{minipage}[t]{0.25\textwidth}
    \malloctruleblock{\(\PCT' := \PCT; \pt' := \N;\) \\ \(\vt' := \N; \lt' := \PCT\)}
    \localtruleblock{\(\PCT' := \PCT; \pt' := \N;\) \\ \(\vt' := \N; \lt' := \PCT\)}
  \end{minipage}
  \begin{minipage}[t]{0.25\textwidth}
    \loadtruleblock{\(\mathbf{assert} ~ \forall \lt \in \lt . \PCT = \lt\) \\ \(\vt' := \vt\)}
    
    \storetruleblock{\(\mathbf{assert} ~ \forall \lt \in \lt . \lt = \PCT\) \\
      \(\PCT' := \PCT; \vt' := \N; \lt' := \lt\)}
  \end{minipage}
    
  \caption{Simple Compartmentalization Policy}
  \label{fig:compartments}
\end{figure}

Once the policy knows which compartment is active, it must ensure that compartments do not interfere with
one another's memory. A simple means of doing so is given in \cref{fig:compartments}: any object allocated by
a given compartment, whether on the stack or via {\tt malloc}, is tagged with that compartment's identity,
and can only be accessed while that compartment is active.
This is very limiting, however! In practice, compartments need to be able to share memory, such as in the
common case where libraries have separate compartments from application code. One solution is to allow
compartments to share selected objects by passing their pointers, treating them as
{\em capabilities}---unforgeable tokens of privilege.

Distinguishing shareable memory from memory that is local to a compartment is difficult
without modifying source code. In order to be minimally intrusive, we
create a variant identifier for {\tt malloc}, {\tt malloc\_share}, which maps to the same
address (i.e., it still calls the same function) but has a different name tag and can therefore
be used to specialize the tag rule. (The need to do this is one of several limitations related
to {\tt malloc}; see \cref{sec:limitations}.) An engineer might manually select which allocations are
shareable, or perhaps rely on some form of escape analysis to detect shareable allocations automatically.

The policy in \cref{fig:sharing} essentially combines the simple compartmentalization policy
and a memory safety policy. The PC tag carries both the current compartment color, for tagging
unshared allocations, and the next free color, for tagging shared allocations.
\(\malloctname\) applies a color tag to shareable allocations, and \(\N\) to local ones.
During loads and stores, the location tag of the target address
determines which parent property applies.

\begin{figure}[t]
  \color{blue}
  \begin{minipage}{0.5\textwidth}
    \[\tau ::= \N \mid C \mid \clr \mid (C,\clr)\]
    \scriptsize
    \storetruleblock
        {let \((C,\clr) := \PCT\) in \\
          \caseoftwo{\(\lt\)}
                    {\(C'\)}{\(\mathbf{StoreT}_C(C,\N,\vt,C')\)}
                    {\(\clr'\)}{\(\mathbf{StoreT}_{\mathit{PVI}}(\clr,\pt,\vt,\clr')\)}}
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
    \scriptsize
    \malloctruleblock
      {let \((C,\clr) := \PCT\) in \\
        \caseoftwo{\(\pt\)}
                  {\(\FN[malloc]\)}{\(\mathbf{MallocT}_{C}(\PCT,\pt,\vt)\)}
                  {\(\FN[malloc\_share]\)}
                  {\\\multicolumn{3}{l}{~~\(\clr',\pt',\lt' \leftarrow \mathbf{MallocT}_{\mathit{PVI}}(\PCT,\pt,\vt)\)} \\
                    \multicolumn{3}{l}{~~\(\PCT':= (C,\clr');\pt' := \pt\)} \\
                    \multicolumn{3}{l}{~~\(\vt' := \N';\lt' := \clr\)} \\}
      }
  \end{minipage}
  
  \caption{Compartmentalization with Shared Capabilities (Selected Rules)}
  \label{fig:sharing}
\end{figure}

\paragraph*{Compartmentalization Variants}

Using program-specific tags for globals and functions, a compartmentalization policy
like the one above can be extended with a Mandatory Access Control (MAC) policy \cite{Lampson74:Protection}.
Here, a table explicitly identifies which compartments may call one another's functions,
which global variables they can access, and with which other compartments they can share
memory.

\subsection{Secure Information Flow}

Finally, we return to the family of 
{\em secure information flow} (SIF)~\cite{Denning77:SecureInformationFlow} policies
introduced in \cref{sec:example}. 
SIF deals entirely with enforcing
higher-level security concerns, regardless of whether the code that they protect contains
errors or undefined behaviors.

\begin{figure}[t]
\begin{tikzpicture}[every text node part/.style={align=left}]
  \node[matrix, ampersand replacement=\&, anchor=west] (code)
       {
         \node {\tt 1 void h(int id, int psk) \{}; \\
         \node (l1) {\tt 2 ~ int fmt = check\_format(psk);}; \\
         \node (l2) {\tt 3 ~ switch(fmt) \{}; \\
         \node {\tt 4 ~ ~ case OLD:}; \\
         \node {\tt 5 ~ ~ ~ psk = update(id, psk); break;}; \\
         \node {\tt 6 ~ ~ case INVALID:}; \\
         \node {\tt 7 ~ ~ ~ psk = 0; break;}; \\
         \node {\tt 8 ~ ~ case DEFAULT:}; \\
         \node {\tt 9 ~ \}}; \\
         \node (l3) {\tt 10 J:  printf("Updating user \%d", id); // join point}; \\
         \node {\tt 11 ~ update(id, psk);}; \\
         \node {\tt 12 \}}; \\
       };

    \node[matrix, ampersand replacement=\&, node distance=15em, right=of l2.north,draw] (table1)
         {
           \node[anchor=north] {\(\mathtt{h}\tagat\PCT[_1]\), \(\mathtt{fmt}\tagat\vt[_1]\)};\\
         };

    \node[matrix, ampersand replacement=\&, node distance=4.5em, below=of table1.west,draw,anchor=west] (table2)
         {
           \node[anchor=north] {\(\mathtt{h}\tagat\PCT[_2]\)}; \&
           \node[anchor=north] {\(\PCT[_2] \leftarrow \splittname(\PCT[_1], \vt_1)\) }; \\
         };

    \node[matrix, ampersand replacement=\&, node distance=4.5em, below=of table2.west,draw,anchor=west] (table3)  
         {
           \node[anchor=north] {\(\mathtt{h}\tagat\PCT[_3]\)}; \&
           \node[anchor=north] {\(\PCT[_3] \leftarrow \labeltname(\PCT[_2], \LN[J])\)}; \\
         };

    \draw[Circle-]
    (l1.south) -- (table1.west);

    \draw[Circle-]
    (l2.south) -| (table2.north);

    \draw[Circle-]
    (l3.north) |- (table3.west);  

\end{tikzpicture}
\caption{Not an Implicit Flow}
\label{fig:sifex3}
\end{figure}

In \cref{fig:sifex3}, the program checks the format of the passkey {\tt psk}, which is tagged  \(\high\),
and uses a switch statement to perform
operations on it based on the result. As in \cref{fig:ex2}, this means that the policy
should ``raise'' the PC tag to \(\high\) to indicated that the program's control-flow depends on {\tt psk}.
But in \cref{fig:sifex3}, after the branches of the switch statement have completed, this is no
longer necessary---no information can be gleaned from the store to {\tt psk} once execution has
reached label {\tt J}. {\tt J} is a {\em join point}: the point in a control-flow graph where all
possible routes from the split to a return have re-converged, which can be identified
statically as the immediate post-dominator of the split point \cite{Denning77:SecureInformationFlow}.

In order to support policies that reason about splits and joins, we introduce the \(\splittname\) and
 \(\labeltname\) tag rules. Every transition that tests a
value as part of a conditional or loop contains a control point that calls \(\splittname\), with an optional
label that is part of Tagged C's abstract syntax (optional both because some policies may not care about join
points and because some functions have multiple exits and no join points). This way, the policy can react when execution
reaches that label via the \(\labeltname\) rule. In the full SIF policy, we keep track of
the pending join points within the PC tag, and lower the PC tag when execution reaches the join point.
A similar approach applies to conditional expressions, but we omit the details here.

\begin{figure}[t]
  \begin{minipage}{0.17\textwidth}
    \color{blue}
    \(\begin{array}{lll}
      \tau & ::= & \high \\
      & | & \low \\
      & | & \pctaint{\LNS} \\
    \end{array}\)
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
    \[|\gentag| \triangleq
    \begin{cases}
      \low & \textnormal{if } \gentag = \low \textnormal{ or } \gentag = \pctaint{\FN}{\emptyset} \\
      \high & \textnormal{otherwise} \\
    \end{cases}\]
    %
    \[\gentag_1 \sqcup \gentag_2 \triangleq
    \begin{cases}
      \low & \textnormal{if } |\gentag_1| = |\gentag_2| = \low \\
      \high & \textnormal{otherwise} \\
    \end{cases}\]
  \end{minipage}
  \scriptsize
  \begin{minipage}{0.25\textwidth}
    \splittruleblock{
      \caseoftwo{\(\PCT, \vt\)}
                {\(\pctaint{\FN}{\LNS}, \high\)}
                { \\ \multicolumn{3}{l}{~ ~\(\PCT' := \pctaint{\FN}{(\LNS \cup \LN)}\)}}
                {\(\underline{~~~}, \low\)}{\(\PCT' := \PCT\)}
    }
    \labeltruleblock
        {let \(\pctaint{\FN}{\LNS} := \PCT\) in \\
          \(\PCT['] := \pctaint{\FN}{(\LNS-\LN)}\)
        }
    \assigntruleblock
        {\(\PCT[']:=\PCT\); \(\vt':=\PCT \sqcup \vt[_2]\)}
  \end{minipage}
  
  \caption{SIF Conditionals}
  \label{fig:SIFconditionals}
\end{figure}

In addition to \(\low\) and \(\high\), the SIF policy tracks a PC tag written using the
constructor {\sc \color{blue} pc}, which carries a
set of label identifiers to record the join points of tainted statement scopes.
Initially, the PC tag is \(\pctaint{\FN[f]}{\emptyset}\), which corresponds
to ``low'' security. The join operator, \(\cdot \sqcup \cdot\), takes the higher of its
arguments after reducing a PC tag into either \(\high\) or \(\low\).

In order to use this version of SIF, the program must undergo a minor automatic transformation
by the compiler or interpreter, introducing
the labels of all join points explicitly. Otherwise there is nothing in the program
syntax to attach the join rules to. So in the example {\tt J} becomes an explicit label in the code,
if it wasn't already. 
%This is a relatively minor transformation, and is necessary because\apt{don't follow the logic},
%in the presence of goto, break, and continue statements, the join point of a conditional might be
%arbitrarily distant from the split point.
The internal syntactic form of each conditional statement (if, switch, while, do-while, and for)
takes this label (optionally, since there might be a join point).
If the conditional branches on a high value, \(\splittname\) adds the label to the set
in the PC tag. Later, when execution reaches a label, \(\labeltname\) deletes it from the
set. If the set is non-empty, there is at least one high split point that has not
yet reached its join point, so we treat the PC tag as high. When execution reaches the
last join point and the set is empty, it is no longer possible to deduce which
path was taken, except by looking at values that updated in the interim, all of which
will themselves be tagged \(\high\).

\paragraph*{SIF Variants}

SIF can cover many different policies. We have shown an instance of
a confidentiality policy, but SIF can also support integrity
(``insecure inputs do not affect secure data''), intransive policies
(``data can flow from A to B and B to C, but not from A to C''), and policies with
more than two security levels.

To give a couple of more realistic examples, an intransitive integrity policy
can be used to protect against SQL injections by requiring unsafe inputs to pass through a sanitizer
before they can be appended to a query. Similarly, a more complex SIF policy could ensure that
data at rest is always encrypted, by setting a low security level to the outputs of an encryption
routine and a high level to the outputs of its corresponding decryption routine.
%      As SIF, with special rule for sanitization function \\  
%      & Guarantee Encrypted Data at Rest by requiring all stores to first pass through an encryption routine &
%      As SIF, with special rules for encryption and decryption functions \\ 

%% \section{Evaluation}
%% \label{sec:evaluation}

%% Tagged C aims to combine the flexibility of machine-level tag-based monitoring architectures with the abstraction
%% of a high-level language. In the last section, we demonstrated three classes of policies
%% with broad practical applicability and described how they can be tuned to the needs of a
%% particular program. They can be used alone or in conjunction. A brief summary of
%% policies and their use cases may be found in \cref{table:policies}.

%% The Tagged C semantics support the full complement of C language features, and advance
%% over our previous work. The underlying memory behavior gives definition to a wide range
%% of programs and is an interesting model in its own right.

%% In the remainder of this section, we explore some of the benefits and limitations of
%% our design choices.

%% %generic/program specific
%% %low-level/high-level

%% % Trying to just thread the table into each section rather than all at once
%% %\begin{table}
%% %  \begin{center}
%% %    %\begin{tabular}{ c| c |c }
%% %    \title{Further Policies and their Uses}
%% %    \begin{tabular}{  p{3cm} | p{5cm}| p{5cm}  } 
%% %      \textbf{Name} & \textbf{Example Use Cases} & \textbf{Tag Implementation} \\ 
%% %      \hline
%% %      SIF: Intransitive Integrity &
%% %      Protect agains SQL Injection by requiring outside data to pass through a sanitizer &
%% %      As SIF, with special rule for sanitization function \\  
%% %      & Guarantee Encrypted Data at Rest by requiring all stores to first pass through an encryption routine &
%% %      As SIF, with special rules for encryption and decryption functions \\ 
%% %      Temporal Memory Safety & Prevent double free & Assign unique color to tag at each free. Check for an existi%ng color before freeing. \\
%% %      & Prevent Use-after-free & Check pointers for color tag when dereferencing pointers  \\
%% %      Placeholder-name & Placeholder-use case & Placeholder policy \\
%% %      \hline
%% %    \end{tabular}
%% %  \end{center}
%% %\end{table}
  
%% \subsection{Tags vs. Values}

%% By committing to a tag-based mechanism, we do restrict the space of policies that Tagged C
%% can enforce. In general, a reference monitor can enforce any policy that constitutes a
%% {\em safety property}---any policy whose violation can be demonstrated by a single finite
%% trace. Some policies in this class cannot be enforced effectively by a tag-based monitor,
%% because tags can carry information about the provenance of values but not about the values
%% themselves: this rules out policies such as ``no integer overflow'' and
%% ``pointers are always in-bounds.'' As we have seen, there are plenty of useful policies that
%% engage only with the provenance of values. For such policies, tag-based enforcement is
%% also conceptually close to the trace-based definition: defining e.g. memory safety in terms
%% of normal states requires either manually keeping track of large amounts of history to
%% identify where each pointer comes from, or possibly some sort of temporal logic.\apt{These
%%   points could also (or instead) be made in the introduction, to justify why tag-based
%%   policies are generally interesting and worthwhile even in the absence of hardware support.}



\section{Related Work}
\label{sec:related}

Aspect-oriented Programming (AOP) aims to separate disparate concerns ({\em aspects}),
that cannot be localized inside modules, such as security and logging \cite{Kiczales97:AOP}. % OG paper
An AOP language distributes {\em advice points} throughout its semantics,
and the programmer separately writes {\em advice} in the form of
additional code that should execute before or after the advice point. The compiler
then {\em weaves} the advice together with the main code. 
Advice points are conceptually very similar to our notion of control points, 
but advice is arbitrary code that can affect the main program's state,
whereas tag rules are constrained to inspect tags and are evaluated separately
from the system being monitored; they cannot interfere in the execution except to cause a failstop.
This means that
Tagged C policies cannot ``correct'' bad behavior, but also
that attaching a given policy to any program in Tagged C will never result
in a regression, only potential failstops.

\apt{This paragraph needs more work if at all possible}
The notion of interleaving checks with normal execution extends to
C runtime monitors that are more directly comparable to Tagged C, such as
{\sc Rmor}~\cite{Havelund08:RVC} and SLIC~\cite{Ball02:slic}.
In these schemes, specified junctures in C execution are treated as events in a trace,
and the monitor as a state machine that steps alongside them: a ``security automaton
\cite{Schneider00:Automata}.''
Trace checking can be interleaved into the program as
an inline monitor \cite{Lundblad13:IRM}, or run offline on a log file \cite{Havelund22:LogScope}.
In general, all of these systems are more expressive than Tagged C, because the
monitor can access system values, not just keep track of provenance. But that expressiveness
requires software-based implementation, whereas we are focused on using PIPE hardware.

\section{Limitations and Future Work}
\label{sec:limitations}
\label{sec:futurework}

Although we believe that our examples validate the features of Tagged C, 
there are some limitations in the design and important tasks that we
hope to address.

\paragraph*{Compilation}
An interpreter is useful for testing policies, but our main goal has always been to
produce a compiler from Tagged C to machine code for a PIPE-equipped processor.
The basic strategy for compilation was outlined in the Tagine project~\cite{Chhak21:Tagine}.
We are currently working to extend the CompCert compiler to handle Tagged C, with the ultimate
goal of also extending CompCert's semantics preservation guarantees to cover tagged semantics.

\paragraph*{Fixed set of Control Points}
We deliberately designed Tagged C to rely on a fixed number of predefined
control points. This simplifies and organizes the task of the policy designer, but of course
new policies might arise for which our current set of
control points proves to be inadequate.  There is no conceptual reason why
control points cannot be added or given modified signatures as needed,
but extending the interpreter and (eventually) the compiler would be non-trivial.
Care needs to be taken in designing control points that are amenable
to compilation for PIPE: tag rule evaluation has a complicated interaction with
compiler optimization~\cite{Chhak21:Tagine}, and some potentially useful tag
rule signatures (such as updating tags on operation inputs to enforce uniqueness
constraints) would require the compiler to generate extra instructions to work
around limitations of the PIPE hardware.

\paragraph*{Policy DSL}
Currently, policies are written in Gallina, the language embedded in Coq~\cite{coq}. This is fine for a
proof-of-concept, but not satisfactory for real use by software engineers.
We plan to develop a domain-specific policy language to make it easier to write Tagged C policies.

\paragraph*{Heap Memory Tagging}
The way Tagged C currently handles {\tt malloc} is unsatisfactory. First, there is no
easy way to distinguish different static {\tt malloc} call locations; our use of
variant names (\cref{sec:compartments}) is something of a hack.
A more principled solution might draw on pointcuts to identify specific calls to {\tt malloc}
as in Havelund \cite{Havelund08:RVC}.
%  would probably involve building a general mechanism for identifying particular
%  static points within functions, but we have so far intentionally avoided this.
%  \apt{Need to add something earlier in the paper about our rationale for attaching rules
%    to ``externally visible'' things like function calls and globals.}
  Further, {\tt malloc} does not get access to type information;
  it takes just a size and returns a {\tt void *}, which the caller must
  cast to a pointer of the desired type (at an arbitrary future point).
  Therefore, Tagged C cannot easily
  enforce substructural memory safety (i.e. protecting fields within a single struct
  from overflowing into each other) or other properties that call for allocated
  regions to be tagged according to their types.
  This is a well-known impediment to improving C memory safety;
  previous work  (e.g. \cite{Michael23:MSWASM}) has often adopted non-standard
  versions of {\tt malloc} that take more informative parameters. This is
  not satisfactory for protecting legacy code, but we do not yet see a good alternative.


\paragraph*{Proofs}
One reason for prototyping Tagged C in the Coq Proof Assistant is to lay the groundwork
for formal proofs of its prooperties.  In particular, we would like to show that
(i) the Tagged C semantics and interpreter have equivalent behavior; (ii) Tagged C running
with a trivial ``do-nothing'' policy behaves like ordinary CompCert C, and (iii) Tagged C policies
do not change program behavior outside of potentially causing failstops.
%
Besides properties Tagged C itself, we aim to prove properties of the policies.
For each family of policies that we discuss, we will give a higher-level formal
specification (e.g., a non-interference property for SIF) and prove that it holds on all
programs run under that property.

\bibliographystyle{splncs04}
\bibliography{taggedc.bib}

\section{Tagged C, Formally}

Tagged C has the full complement of typical C expressions (\cref{fig:expr}). \(\val{v}{\vt}\),
\(\loc{p}{\pt}\), and \(\paren{\expr}{\type}\) are internal forms.
A constant \(c\) in the concrete syntax is transformed into \(\val{c}{\constt}\),
and in general \(\val{v}{\vt}\) is a fully-reduced right-hand value. \(\loc{p}{\pt}\)
is a fully-reduced left-hand value that represents the address of a variable.
\(\paren{\expr}{\type}\) is the result of a conditional or shortcutting
expression, with \(\type\) being a type annotation in case the result needs to
be cast.

\begin{figure}
  \[\begin{aligned}
  \expr ::= & \val{v}{\vt} & \textnormal{Value} \\
  | & \var{x} & \textnormal{Variable} \\
  | & \field{\expr}{id} & \textnormal{Field} \\
  | & \valof{\expr} & \textnormal{Load from Object} \\
  | & \deref{\expr} & \textnormal{Dereference Pointer} \\
  | & \addrof{\expr} & \textnormal{Address of Object} \\
  | & \unop{\odot}{\expr} & \textnormal{Unary Operator} \\
  | & \binop{\oplus}{\expr_1}{\expr_2} & \textnormal{Binary Operator} \\
  | & \cast{\expr}{ty} & \textnormal{Cast} \\
  | & \condition{\expr_1}{\expr_2}{\expr_3} & \textnormal{Conditional} \\
  | & \sizeof{ty} & \textnormal{Size of Type} \\
  | & \alignof{ty} & \textnormal{Alignment of Type} \\
  | & \assign{\expr_1}{\expr_2} & \textnormal{Assignment} \\
  | & \assignop{\oplus}{\expr_1}{\expr_2} & \textnormal{Operator Assignment} \\
  | & \postinc{\oplus}{\expr} & \textnormal{Post-Increment/Decrement} \\
  | & \comma{\expr_1}{\expr_2} & \textnormal{Expression Sequence} \\
  | & \call{\expr_f}{\overline{\expr}_{args}} & \textnormal{Function Call} \\
  | & \loc{l}{\lt} & \textnormal{Memory Location} \\
  | & \paren{\expr}{ty}{\gentag} & \textnormal{Parenthetical with Optional Cast} \\
  \end{aligned}\]
  \caption{Expression Syntax}
  \label{fig:expr}
\end{figure}

Some common C expressions are derived forms. An array index expression,
\(\expr_1[\expr_2]\) expands to \(\deref{\binop{+}{\expr_1}{\expr_2}}\).
The pre-increment  expression \(++\expr\) expands to
\(\assign{\expr}{\binop{+}{\expr}{1\tagat\constt}}\), and likewise for pre-decrement.

Similarly, statements cover the full C standard. Conditional statements
carry optional labels as internal forms, so that an if statement in the
concrete syntax becomes \(\sifthenelse{\expr}{\stmt_1}{\stmt_2}{\bot}\).

\begin{figure}
  \begin{subfigure}[t]{0.3\textwidth}
    \[\begin{aligned}
    \stmt ::= & \sskip \\
    | & \sdo{\expr} \\
    | & \sseq{\stmt_1}{\stmt_2} \\
    | & \sifthenelse{\expr}{\stmt_1}{\stmt_2}{L} \\
    | & \swhile{\expr}{\stmt}{L} \\
    | & \sdowhile{\expr}{\stmt}{L} \\
    | & \sfor{\stmt_1}{\expr}{\stmt_2}{\stmt_3} \\
    | & \sbreak \\
    | & \scontinue \\
    | & \sreturn \\
    | & \sswitch{\expr}{\overline{(L,\stmt)}} \\
    | & \slabel{L}{\stmt} \\
    | & \sgoto{L} \\    
    \end{aligned}\]
  \end{subfigure}
  \begin{subfigure}[t]{0.69\textwidth}
  \end{subfigure}
  \caption{Tagged C Abstract Syntax}
  \label{fig:syntax}
\end{figure}

\subsection{Atoms}

\subsection{Memory Model}

A memory configuration (\cref{fig:mem}) consists of the contents of memory, the permissions
of memory, the live regions (separated into a single region for globals, and
a list of allocated regions that can be deallocated), and the state of its
allocator. The allocator is kept abstract, and axiomatized to provide the
interface for allocation and deallocation of stack and heap memory.

\begin{figure}[t]
  \begin{align*}
    \mathit{frag} ::= & (v\tagat\vt)_n & n \in \mathbb{N} \\
    \mathit{perm} ::= & \mathit{Live} | \mathit{Free} | \mathit{Reserved} \\
    \mem \in \mathit{MEM} ::= & \left\{
    \begin{aligned}
      & \contents : \Int \rightarrow \mathit{frag}\tagat \tau, \\
      & \mathit{perms} : \Int \rightarrow \mathit{perm}, \\
      & \mathit{globals} : (\Int \times \Int), \\
      & \mathit{live} : \mathit{list} ~ (\Int \times \Int), \\
      & \mathit{allocator} : \AL
    \end{aligned} \right\} \\
  \end{align*}

%    \mathit{stkalloc} \in & \AL \rightarrow (\Int, \Int) \rightarrow (\AL \times \Int \times \Int) \\
%    \mathit{stkfree} \in & \AL \rightarrow (\Int, \Int) \rightarrow \AL \\
%    \mathit{heapalloc} \in & \AL \rightarrow (\Int, \Int) \rightarrow (\AL \times \Int \times \Int) \\
%    \mathit{heapfree} \in & \AL \rightarrow (\Int, \Int) \rightarrow (\AL \times \Int \times \Int) \\
 
  \caption{Components of Memory}
  \label{fig:mem}
\end{figure}

\begin{figure}[t]
  \[\mem[p]_{\type} \triangleq
  \begin{cases}
    v\tagat\vt\tagat\left[\lt[_0]\dots\lt[_n]\right] & \textnormal{if } \mem.\contents ~ (p+n) = (v\tagat\vt)_n\tagat\lt[_n], \\
    & \textnormal{and } \mem.\mathit{perm} ~ (p+n) \not = \mathit{Reserved}, \textnormal{ where } 0 \leq n < |\type| \\
    \vundef\tagat\vt\tagat\left[\lt[_0]\dots\lt[_n]\right] & \textnormal{else if } \mem.\contents ~ (p+n) = \underline{~~}\tagat\lt[_n] \\
    & \textnormal{and } \mem.\mathit{perm} ~ (p+n) \not = \mathit{Reserved}, \textnormal{ where } 0 \leq n < |\type| \\
    \bot & \textnormal{otherwise}
  \end{cases}\]

  \[\mem[p \mapsto v\tagat\vt\tagat\overline{\lt}]_{\type} \triangleq
  \begin{cases}
    \mem\left\langle\contents := \mem.\contents\llbracket p + n \mapsto (v\tagat\vt)_n\tagat(\mathit{nth} ~ n ~ \overline{\lt}) \mid 0 \leq n < |\type| \rrbracket \right\rangle \\ \hspace{4em} \textnormal{if } \mathit{perm} ~ (p+n) \not = \mathit{Reserved} \textnormal{ where } 0 \leq n < |\type| \\
    \bot \hspace{3.2em} \textnormal{otherwise} \\
  \end{cases}\]
  
  \caption{Memory Operations}
  \label{fig:memops}
\end{figure}

An address can have permissions of Live, Reserved, or Free. Live memory
is memory that has been allocation for program use. It is guaranteed to be
stable (unless it's volatile). Reserved memory is set aside for the compiler,
and is wholly inaccessible. Everything else is free.

Free memory can be written and read just like ordinary memory, but anytime the
allocator is invoked, it may allocate free memory as an object or reserve it for
the compiler. So the program will see a stable state of free memory
between allocator invocations, upon which its values may change or it
may become inaccessible, depending on the allocator.

A memory's contents is a map from machine integer addresses to tagged
byte-sized fragments, which must be combined for a load.
For a value \(v\) and tag \(\vt\), we write \(n\)th fragment of \(v\tagat\vt\)
as \((v\tagat\vt)_n\), and if \(v\) is of type \(\type\), the full value in memory
consists of \((v\tagat\vt)_0\) up to \((v\tagat\vt)_{|\type|}\).
Load and store operations are given in \cref{fig:memops}.

\paragraph{Globals and Environments}

\begin{figure}[t]
  \begin{align*}
    \genv ::= & \GN \rightharpoonup (\Int \times \Int \times \tau \times \type) \\
    \fenv ::= & \FN \rightharpoonup (\alpha \times \tau) \\
    \mathit{fdefs} ::= & \alpha \rightarrow (\mathit{list} ~ (\AN \times \type) \times \stmt \times \type) \\
    \lenv ::= & (\mathtt{x}_{loc} + \AN) \rightharpoonup (\Int \times \Int \times \tau \times \type) \\
    \tenv ::= & (\mathtt{x}_{loc} + \AN) \rightharpoonup (\mathit{val} \times \tau) \\
  \end{align*}
  
  \caption{Environments}
  \label{fig:genv}
\end{figure}
\sna{Define what a val is. Also, ident namespaces.}

Globals are stored in memory in a single contiguous region. The global
environment \(\genv\) is a partial map from identifiers to four-tuples
containing the base address of the variable in memory, its bound (one past
the end of its range), its pointer tag, and its type. The function map
is a partial map from identifiers to pairs of a function address---an
abstract symbol in the set \(\alpha\)---and a tag. And the function
\(\mathit{fdefs}\) maps function addresses to their definitions: a list
of arguments and their types, a body statement, and a return type.

\sna{Make these identifiers not blue when they aren't tags!}
The global environment and memory are initialized such that for each global variable
\(\GN\) of type \(\type\) and with initial value \(v\):
\begin{itemize}
\item \(\globaltres \leftarrow \globalt\)
\item \(\genv ~ \GN = (\mathit{base},\mathit{bound},\mathit{\pt'})\)
\item \(\mem.\contents ~ (\mathit{base}+n) = (v\tagat\vt')_n \tagat \lt'\) for \(0 \leq n < |\type|\)
\item \(\mem.\mathit{perms} ~ (\mathit{base}+n) = \mathit{LIVE}\) for \(0 \leq n < |\type|\)
\end{itemize}

Bases and bounds are non-overlapping and contiguous, and their total range covers
\(\mem.\mathit{globals}\).

\subsection{States}

States can be of several kinds, denoted by their script prefix: a {\em general state} \(\mathcal{S}(\dots)\),
an {\em expression state} \(\mathcal{E}(\dots)\), a {\em call state} \(\mathcal{C}(\dots)\), or a
{\em return state} \(\mathcal{R}(\dots)\). Finally, the special state {\em failstop} (\(\mathcal{F}(\dots)\))
represents a tag failure, and carries the state that produced the failure.
[Allison: to whatever degree you've figured out what is useful here by publication-time, we can
  tune this to be more specific.]

In the below definition, memories are ranged over by \(\mem\), local environments by
\(\lenv\), and continuations by \(\cont\).

\[\begin{aligned}
S ::= & \sstate{\PCT}{\mem}{\stmt}{\cont} \\
| & \estate{\PCT}{\mem}{\expr}{\cont} \\
| & \cstate{\PCT}{\mem}{f}{\overline{\val{v}{\vt}}}{\cont} \\
| & \rstate{\PCT}{\mem}{\val{v}{\vt}}{\cont} \\
| & \fstate{S} \\
\end{aligned}\]

\paragraph*{Pieces of a State}

States in general contain a memory, a local environment, and a continuation.
A memory \(\mem\) is a map from machine integers to 
A successful load, written \(\mem[l]\), yields a value with two tags, \(v\tagat\vt\tagat\lt\).
A local environment \(\lenv\) is a map from variable identifiers to tagged addresses,
\(p\tagat\pt\), and a temp environment \(\tenv\) is a map from identifiers to tagged values,
\(v\tagat\vt\). A global environment \(\genv\) maps an identifier to either a tagged address,
or a symbolic function pointer tagged with its own name.
The global environment is fixed at the start of execution, so we omit it from state tuples.

\paragraph*{Continuations}
\label{app:continuations}

A continuation acts like a stack of pending operations. The base of the stack is
\(\kemp\). \(\mathit{Kdo}\) indicates that a do statement is evaluating an expression.
\(\mathit{Kseq}\) with parameter \(\stmt\) indicates that, after the current statement
is done executing, \(\stmt\) is next. \(\mathit{Kif}\) means that execution is evaluating
the test expression of an if statement, and its parameters are the branches of the
if. Similarly, the test continuations for while, do-while, and for loops indicate that
the test expression is being evaluated. The associated loop continuations indicate that
execution is in the loop body. They continuations carry all of the information of the original
loop.

\[\begin{split}
\cont ::= & \kemp \\
| & \kdo{\cont} \\
| & \kseq{\stmt}{\cont} \\
| & \kif{\stmt_1}{\stmt_2}{L}{\cont} \\
| & \kwhiletest{\expr}{\stmt}{L}{\cont} \\
| & \kwhileloop{\expr}{\stmt}{L}{\cont} \\
| & \kdowhiletest{\expr}{\stmt}{L}{\cont} \\
| & \kdowhileloop{\expr}{\stmt}{L}{\cont} \\
| & \kfor{\expr}{\stmt_2}{\stmt_3}{L}{\cont} \\
| & \kforpost{\expr}{\stmt_2}{\stmt_3}{L}{\cont} \\
\end{split}\]

\section{Step Rules}
\label{app:rules}

\subsection{Sequencing rules}

\sequencing

\subsection{Conditional rules}

\conditionals

\subsection{Loop rules}

\loops

\subsection{Contexts}
\label{app:contexts}

Our expression semantics are contextual. A context \(\ctx[\expr]_k\) is a function from an
expression to an expression, with a ``kind'' flag \(k\) (left-hand or right-hand, \(\lh\) or \(\rh\)).

\[\begin{aligned}
\ctx{\expr}_\lh ::= \\
| & \expr & \\ % ctx_top
| & \deref{\ctx{\expr}_\rh} \\ % ctx_deref
| & \field{\ctx{\expr}_\rh}{id} \\ % ctx_field
\end{aligned}\]

\[\begin{aligned}
\ctx{\expr}_\rh ::= \\
| & \expr & \\ % ctx_top
| & \valof{\ctx{\expr}_\lh} \\ % ctx_rvalof
| & \addrof{\ctx{\expr}_\lh} \\ % ctx_addrof
| & \unop{\odot}{\ctx{\expr}_\rh} \\ % ctx_unop
| & \binop{\oplus}{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_binop_left
| & \binop{\oplus}{\expr_1}{\ctx{\expr_2}_\rh} \\ % ctx_binop_right
| & \cast{\ctx{\expr}_\rh}{\type} \\ % ctx_cast
| & \seqand{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_seqand
| & \seqor{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_seqor
| & \condition{\ctx{\expr_1}_\rh}{\expr_2}{\expr_3} \\ % ctx_condition
| & \assign{\ctx{\expr_1}_\lh}{\expr_2} \\ % ctx_assign_left
| & \assign{\expr_1}{\ctx{\expr_2}_\rh} \\ % ctx_assign_right
| & \assignop{\oplus}{\ctx{\expr_1}_\lh}{\expr_2} \\ % ctx_assignop_left
| & \assignop{\oplus}{\expr_1}{\ctx{\expr_2}_\rh} \\ % ctx_assignop_right
| & \postinc{\oplus}{\ctx{\expr}_\lh} \\ % ctx_postinc
| & \call{\ctx{\expr_1}_\rh}{\overline{\expr_2}} \\ % ctx_call_left
| & \call{\expr_1}{\ctx{\overline{\expr_2}}_\rh} \\ % ctx_call_right
% skipped builtins
| & \comma{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_comma
| & \paren{\ctx{\expr}_\rh}{\type}{} \\ % ctx_paren
\end{aligned}\]

A left-hand reduction \(\expr \Rightarrow_\lh \expr'\)
relates an expression to an expression. A right-hand reduction
\((\PCT,\mem,\expr) \Rightarrow_\rh (\PCT',\mem',\expr')\)
relates a triple of PC Tag, memory, and expression to another such triple.
Given these reduction relations, we construct step rules for contexts in
expressions.

%triple of a memory, an expression, and a tag
%might reduces to another such triple as a left-hand, right-hand, or call reduction, written
%\((\mem, \expr, \PCT) \Rightarrow_k (\mem', \expr', \PCT')\),
%based on rules given below. These reductions are embedded in states as follows.

\judgmenttwo{\(\ctx{\expr}_\lh\)}
            {\(\expr \Rightarrow_\lh \expr'\)}
            {\(\defestate{\ctx{\expr}} \longrightarrow \defestate{\ctx{\expr'}}\)}

\judgmenttwo{\(\ctx{\expr}_\rh\)}
            {\((\PCT, \mem, \expr) \Rightarrow_\rh (\PCT', \mem', \expr')\)}
            {\(\defestate{\ctx{\expr}} \longrightarrow \estate{\PCT'}{\mem'}{\ctx{\expr'}}{\cont}\)}
            
All that remains is to give the expression reductions themselves.

\expressions

\subsection{Call and Return Rules}

In order to make a call, we need to reduce the function expression to an \(\floc{\_}\) value, an
abstract location corresponding to a particular function. Then we can make the call.

\callexprstep

When we make an internal call, we need to allocated space for locals and arguments using the helper function
\(\mathit{frame}\).

\[\mathit{frame} ~ xs ~ as ~ \mem =
\begin{cases}
  (\mem''[p \mapsto \vundef\tagat\vt\tagat\lt]_{|ty|}, & \textnormal{if } xs = (id,ty)::xs' \\
  \lenv'[id \mapsto (\mathit{p, p+|ty|,ty,\pt})]) &
  \textnormal{where } (\mem',p) \leftarrow \mathit{stack\_alloc} ~ |ty| ~ \mem, \\
  & \trule{\localtres}{\localt}, \\
  & \textnormal{and } (\mem'',\lenv') = \mathit{frame} ~ xs' ~ as ~ m' \\ 
  \\
  (\mem''[p \mapsto v\tagat\vt'\tagat\lt]_{|ty|}, & \textnormal{if } as = (id,ty,v \tagat \vt)::as' \textnormal{ and } xs = \varepsilon \\
  \lenv'[id \mapsto (\mathit{p, p+|ty|,ty,\pt})]) &
  \textnormal{where } (\mem',p) \leftarrow \mathit{stack\_alloc} ~ |ty| ~ \mem, \\
  & \trule{\argtres}{\argt}, \\
  & \textnormal{and } (\mem'',\lenv') = \mathit{frame} ~ xs' ~ as ~ m' \\
  \\
  (\mem, \lambda x . \bot) & \textnormal{if } xs = \varepsilon \textnormal{ and } as = \varepsilon \\
\end{cases}\]

\callstep

On the other hand, when we make an external call, we step directly to a return state with some value
being returned and an updated memory. [TODO: talk more about how the tag policy applies in external
  functions, what they can and can't do with tags.]

\extcallstep

Special external functions, such as malloc, just get their own rules.

\mallocstep

And finally, we have the return rules.

\returnstep
\retvalstep
\retnovalstep

\end{document}
