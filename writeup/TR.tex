\documentclass{article}

\begin{document}

\section{Tagged C, Formally}

In this appendix, we will present the Tagged C semantics, focusing on those elements
that differ from the original CompCert C. A reader interested in exploring the
underlying CompCert C semantics should consult Blazy and Leroy \cite{Blazy09:CompCertClight}
on the Clight semantics, which is one step lower than CompCert C in the CompCert toolchain.

Chief among the areas that differ is the memory model. While still heavily based on the CompCert
memory model \cite{Leroy12:CompCertMM}, it is modified to use a flat address space
and to behave in correspondence to some underlying machine-compiler implementation.

Tagged C has the full complement of typical C expressions (\cref{fig:expr}). \(\val{v}{\vt}\),
\(\loc{p}{\pt}\), and \(\paren{\expr}{\type}\) are internal forms.
A constant \(c\) in the concrete syntax is transformed into \(\val{c}{\constt}\),
and in general \(\val{v}{\vt}\) is a fully-reduced right-hand value. \(\loc{p}{\pt}\)
is a fully-reduced left-hand value that represents the address of a variable.
\(\paren{\expr}{\type}\) is the result of a conditional or shortcutting
expression, with \(\type\) being a type annotation in case the result needs to
be cast.

\begin{figure}
  \[\begin{aligned}
  \expr ::= & \val{v}{\vt} & \textnormal{Value} \\
  | & \var{x} & \textnormal{Variable} \\
  | & \field{\expr}{id} & \textnormal{Field} \\
  | & \valof{\expr} & \textnormal{Load from Object} \\
  | & \deref{\expr} & \textnormal{Dereference Pointer} \\
  | & \addrof{\expr} & \textnormal{Address of Object} \\
  | & \unop{\odot}{\expr} & \textnormal{Unary Operator} \\
  | & \binop{\oplus}{\expr_1}{\expr_2} & \textnormal{Binary Operator} \\
  | & \cast{\expr}{ty} & \textnormal{Cast} \\
  | & \condition{\expr_1}{\expr_2}{\expr_3} & \textnormal{Conditional} \\
  | & \sizeof{ty} & \textnormal{Size of Type} \\
  | & \alignof{ty} & \textnormal{Alignment of Type} \\
  | & \assign{\expr_1}{\expr_2} & \textnormal{Assignment} \\
  | & \assignop{\oplus}{\expr_1}{\expr_2} & \textnormal{Operator Assignment} \\
  | & \postinc{\oplus}{\expr} & \textnormal{Post-Increment/Decrement} \\
  | & \comma{\expr_1}{\expr_2} & \textnormal{Expression Sequence} \\
  | & \call{\expr_f}{\overline{\expr}_{args}} & \textnormal{Function Call} \\
  | & \loc{l}{\lt} & \textnormal{Memory Location} \\
  | & \floc{\alpha}{\pt} & \textnormal{Abstract Function Address} \\
  | & \paren{\expr}{ty} & \textnormal{Result of Conditional} \\
  \end{aligned}\]
  \caption{Expression Syntax}
  \label{fig:expr}
\end{figure}

Some common C expressions are derived forms. An array index expression,
\(\expr_1[\expr_2]\) expands to \(\deref{\binop{+}{\expr_1}{\expr_2}}\).
The pre-increment  expression \(++\expr\) expands to
\(\assign{\expr}{\binop{+}{\expr}{1\tagat\constt}}\), and likewise for pre-decrement.

Similarly, statements cover the full C standard. Conditional statements
carry optional labels as internal forms, so that an if statement in the
concrete syntax becomes \(\sifthenelse{\expr}{\stmt_1}{\stmt_2}{\bot}\).

\begin{figure}
  \begin{subfigure}[t]{0.3\textwidth}
    \[\begin{aligned}
    \stmt ::= & \sskip \\
    | & \sdo{\expr} \\
    | & \sseq{\stmt_1}{\stmt_2} \\
    | & \sifthenelse{\expr}{\stmt_1}{\stmt_2}{L} \\
    | & \swhile{\expr}{\stmt}{L} \\
    | & \sdowhile{\expr}{\stmt}{L} \\
    | & \sfor{\stmt_1}{\expr}{\stmt_2}{\stmt_3} \\
    | & \sbreak \\
    | & \scontinue \\
    | & \sreturn \\
    | & \sswitch{\expr}{\overline{(L,\stmt)}} \\
    | & \slabel{L}{\stmt} \\
    | & \sgoto{L} \\    
    \end{aligned}\]
  \end{subfigure}
  \begin{subfigure}[t]{0.69\textwidth}
  \end{subfigure}
  \caption{Tagged C Abstract Syntax}
  \label{fig:syntax}
\end{figure}

Values \(v\) are drawn from the set \(\mathit{val}\). Identifiers belong to
disjoint namespaces, identified by a subscript, e.g. \(\mathtt{x}_{glb}\).

\subsection{Memory Model}

A memory configuration (\cref{fig:mem}) consists of the contents of memory, the permissions
of memory, the live regions (separated into a single region for globals, and
a list of allocated regions that can be deallocated), and the state of its
allocator oracle. The oracle is kept abstract, and axiomatized to provide the
interface for allocation and deallocation of stack and heap memory, as well as
the {\it scramble} operation, described below.

\begin{figure}[t]
  \begin{align*}
    \mathit{frag} ::= & (v\tagat\vt)_n & n \in \mathbb{N} \\
    \mathit{perm} ::= & \mathit{Live} | \mathit{Free} | \mathit{Reserved} \\
    \mem \in \mathit{MEM} ::= & \left\{
    \begin{aligned}
      & \contents : \Int \rightarrow \mathit{frag}\tagat \tau, \\
      & \mathit{perms} : \Int \rightarrow \mathit{perm}, \\
      & \mathit{globals} : (\Int \times \Int), \\
      & \mathit{live} : \mathit{list} ~ (\Int \times \Int), \\
      & \mathit{oracle} : \AL
    \end{aligned} \right\} \\
  \end{align*}
 
  \caption{Components of Memory}
  \label{fig:mem}
\end{figure}

\begin{figure}[t]
  \[\mem[p]_{\type} \triangleq
  \begin{cases}
    v\tagat\vt\tagat\left[\lt[_0]\dots\lt[_n]\right] & \textnormal{if } \mem.\contents ~ (p+n) = (v\tagat\vt)_n\tagat\lt[_n], \\
    & \textnormal{and } \mem.\mathit{perm} ~ (p+n) \not = \mathit{Reserved}, \textnormal{ where } 0 \leq n < |\type| \\
    \vundef\tagat\vt\tagat\left[\lt[_0]\dots\lt[_n]\right] & \textnormal{else if } \mem.\contents ~ (p+n) = \underline{~~}\tagat\lt[_n] \\
    & \textnormal{and } \mem.\mathit{perm} ~ (p+n) \not = \mathit{Reserved}, \textnormal{ where } 0 \leq n < |\type| \\
    \bot & \textnormal{otherwise}
  \end{cases}\]

  \[\mem[p \mapsto v\tagat\vt\tagat\overline{\lt}]_{\type} \triangleq
  \begin{cases}
    \mem\left\langle\contents := \mem.\contents\llbracket p + n \mapsto (v\tagat\vt)_n\tagat(\mathit{nth} ~ n ~ \overline{\lt}) \mid 0 \leq n < |\type| \rrbracket \right\rangle \\ \hspace{4em} \textnormal{if } \mathit{perm} ~ (p+n) \not = \mathit{Reserved} \textnormal{ where } 0 \leq n < |\type| \\
    \bot \hspace{3.2em} \textnormal{otherwise} \\
  \end{cases}\]
  
  \caption{Memory Operations}
  \label{fig:memops}
\end{figure}

An address can have permissions of \(\mathit{LIVE}\), \(\mathit{RESERVED}\), or \(\mathit{FREE}\).
Live memory is memory that has been allocated for program use. It is guaranteed to be
stable (unless it's volatile). Reserved memory is set aside for the compiler,
and is wholly inaccessible. Everything else is free.

Free memory can be written and read just like ordinary memory, but anytime the
allocator is invoked, it may allocate free memory as an object or reserve it for
the compiler. So the program will see a stable state of free memory
between allocator invocations, upon which its values may change or it
may become inaccessible, depending on the allocator.

A memory's contents is a map from machine integer addresses to tagged
byte-sized fragments, which must be combined for a load.
For a value \(v\) and tag \(\vt\), we write \(n\)th fragment of \(v\tagat\vt\)
as \((v\tagat\vt)_n\), and if \(v\) is of type \(\type\), the full value in memory
consists of \((v\tagat\vt)_0\) up to \((v\tagat\vt)_{|\type|}\).
Load and store operations are given in \cref{fig:memops}.

\paragraph{Allocator Oracle}

The role of the allocator oracle is to abstract away low-level details of memory
management that may affect execution of the program, but are not directly visible
to the source semantics. It defines a set of four operations:
\begin{align*}
  \mathit{stkalloc} \in & \AL \rightarrow (\Int, \Int) \rightharpoonup (\AL \times \Int \times \Int) \\
  \mathit{stkfree} \in & \AL \rightarrow (\Int, \Int) \rightharpoonup \AL \\
  \mathit{heapalloc} \in & \AL \rightarrow (\Int, \Int) \rightharpoonup (\AL \times \Int \times \Int) \\
  \mathit{heapfree} \in & \AL \rightarrow (\Int, \Int) \rightharpoonup (\AL \times \Int \times \Int) \\
\end{align*}

Allocating and freeing stack and heap memory are straightforward enough.
There is one final operation that is dependent on the oracle:
\[\mathit{scramble} \in \mem \rightharpoonup \mem\]

\(\mathit{scramble}\) is invoked at calls and returns to reflect the fact that compiler generated
code is manipulating memory, so non-\(\mathit{LIVE}\) regions might have their permissions
and/or their values changed. It is axiomatically guaranteed not to touch \(\mathit{LIVE}\)
regions, and that the regions it does touch are deterministic based on the oracle.

\paragraph{Globals, Locals, and Environments}

\begin{figure}[t]
  \begin{align*}
    \genv ::= & \mathtt{x}_{glb} \rightharpoonup (\Int \times \Int \times \tau \times \type) \\
    \fenv ::= & \mathtt{f}_{fun} \rightharpoonup (\alpha \times \tau) \\
    \mathit{fdefs} ::= & \mathtt{f}_{fun} \rightarrow (\mathit{list} ~ (\mathtt{x}_{loc} \times \mathtt{x}_{arg} \times \type) \times \stmt \times \type + EXT(spec)) \\
    \lenv ::= & (\mathtt{x}_{loc} + \mathtt{x}_{arg}) \rightharpoonup (\Int \times \Int \times \tau \times \type) \\
    \tenv ::= & (\mathtt{x}_{loc} + \mathtt{x}_{arg}) \rightharpoonup (\mathit{val} \times \tau) \\
  \end{align*}
  
  \caption{Environments}
  \label{fig:genv}
\end{figure}

Globals are stored in memory in a single contiguous region. The global
environment \(\genv\) is a partial map from identifiers to four-tuples
containing the base address of the variable in memory, its bound (one past
the end of its range), its pointer tag, and its type. The function map
is a partial map from identifiers to pairs of a function address---an
abstract symbol in the set \(\alpha\)---and a tag. And the function
\(\mathit{fdefs}\) maps function addresses to their definitions: a list
of arguments and their types, a body statement, and a return type.

The global environment and memory are initialized such that for each global variable
\(\GN\) of type \(\type\) and with initial value \(v\):
\begin{itemize}
\item \(\globaltres \leftarrow \globalt\)
\item \(\genv ~ \mathtt{x}_{glb} = (\mathit{base},\mathit{bound},\mathit{\pt'})\)
\item \(\mem.\contents ~ (\mathit{base}+n) = (v\tagat\vt')_n \tagat \lt'\) for \(0 \leq n < |\type|\)
\item \(\mem.\mathit{perms} ~ (\mathit{base}+n) = \mathit{LIVE}\) for \(0 \leq n < |\type|\)
\end{itemize}

Bases and bounds are non-overlapping and contiguous, and their total range covers
\(\mem.\mathit{globals}\).

Local variables and function arguments may or may not be stored in memory. Those
that are keep their base, bound, tag and type in a local environment, \(\lenv\).
Those that are not have their tagged values stored directly in a temp environment,
\(\tenv\).

Allocation of in-memory locals is performed by the \(\mathit{new\_loc}\) function,
which takes a memory, a local environment, a tag (the PC tag),
and a pair of the variable or identifier, and its type.

\[\begin{aligned}
& \mathit{new\_loc} ~ \mem ~ \lenv ~ \PCT ~ (\mathtt{x}_{loc}, \type) \triangleq \\
& ~~ \textnormal{let } (o,base,bound) := \mathit{stk\_alloc} ~ \mem.\mathit{oracle} ~ (0,|\type|) \textnormal{ in} \\
& ~~\textnormal{if } \trule{\localtres}{\localt}, \textnormal{ then} \\
& ~~~~ \textnormal{let } \mem' = \mem \left\langle \mathit{oracle} := o \right\rangle [base \mapsto \vundef\tagat\initt\tagat\lt[']]_{|ty|} \textnormal{ in} \\
& ~~~~ (\mem', \lenv[id \mapsto (\mathit{base, bound, \pt', \type})], \PCT[']) \\
& ~~ \textnormal{else } \fail(``LocalT",\PCT,\TN)
\end{aligned}\]

\sna{handle the multiple tags here}
The \(\mathit{new\_arg}\) function is similar, but it takes as argument an initial tagged value.

\[\begin{aligned}
& \mathit{new\_arg} ~ \mem ~ \lenv ~ \PCT ~ (\mathtt{x}_{arg}, (v\tagat\vt), \type)\triangleq \\
& ~~ \textnormal{let } (o,base,bound) := \mathit{stk\_alloc} ~ \mem.\mathit{oracle} ~ (0,|\type|) \textnormal{ in} \\
& ~~\textnormal{if } \trule{\localtres}{\localt}, \textnormal{ then} \\
& ~~~~ \textnormal{let } \mem' = \mem \left\langle \mathit{oracle} := o \right\rangle [base \mapsto v\tagat\vt\tagat\lt[']]_{|ty|} \textnormal{ in} \\
& ~~~~ (\mem', \lenv[id \mapsto (\mathit{base, bound, \pt', \type})], \PCT[']) \\
& ~~ \textnormal{else } \fail(``LocalT",\PCT,\TN)
\end{aligned}\]

\subsection{Expression Reductions}

Now that we've introduced memory and environments, we can look at some
expression reductions and where the control points fit into them.
A left-hand reduction \(\lenv,\expr \Rightarrow_\lh \expr'\)
relates an expression and local environment to an expression.
These are given in \cref{fig:lexprsteps}.
A right-hand reduction
\((\PCT,\mem,\tenv,\expr) \Rightarrow_\rh (\PCT',\mem',\tenv',\expr')\)
relates a tuple of PC Tag, memory, temp environment, and expression to another such triple.
The first batch to look at are in \cref{fig:rexprsteps1}. Note that,
whether kept in memory or not, variables are accessed with the \(\accesstname\)
rule and assigned with the \(\assigntname\) rule. If they are in memory,
\(\loadtname\) and \(\storetname\) apply as well.
%Given these reduction relations, we construct step rules for contexts in
%expressions.

\begin{figure}
  \varlocalstep
  \varglobalstep
  \funglobalstep
  \fieldstructstep

  \caption{Left-hand expression reductions}
  \label{fig:lexprsteps}
\end{figure}

\begin{figure}
  \derefstep
  \valofstep
  \valoftmpstep
  \addrofstep
  \addroffunstep
  \assignstep
  \assigntmpstep
  
  \caption{Right-hand expression reductions (Part 1)}
  \label{fig:rexprsteps1}
\end{figure}

\begin{figure}
  \unopstep
  \binopstep
  \seqandtruestep
  \seqandfalsestep
  \seqortruestep
  \seqorfalsestep
%  \assignopstep
%  \postincstep
  \conditionstep
  \commastep
  \parenstep
  \iicaststep
  \picaststep
  \ipcaststep
  \ppcaststep

  \caption{Right-hand expression reductions (Part 2)}
  \label{fig:rexprsteps2}
\end{figure}

\subsection{States}

States can be of several kinds, denoted by their script prefix: a {\em general state} \(\mathcal{S}(\dots)\),
an {\em expression state} \(\mathcal{E}(\dots)\), a {\em call state} \(\mathcal{C}(\dots)\), or a
{\em return state} \(\mathcal{R}(\dots)\). Finally, the special state {\em failstop} (\(\mathcal{F}(\dots)\))
represents a tag failure, and carries the name of the tag rule that produced the failure as well
as a list of tags for the arguments. States within functions carry the local and temp environments
for those functions; the global and function environments are always accessible and never
mutated.

\[\begin{aligned}
S ::= & \sstate{\PCT}{\mem,\lenv,\tenv}{\stmt}{\cont} \\
| & \estate{\PCT}{\mem,\lenv,\tenv}{\expr}{\cont} \\
| & \cstate{\PCT}{\mem}{f}{\overline{\val{v}{\vt}}}{\cont} \\
| & \rstate{\PCT}{\mem}{\val{v}{\vt}}{\cont} \\
| & \fstate{\mathit{rule},\overline{\gentag}} \\
\end{aligned}\]

\paragraph*{Contexts}

The Tagged C expression semantics are contextual. A context \(\ctx[\expr]_k\) is a function from an
expression to an expression, with a ``kind'' flag \(k\) (left-hand or right-hand, \(\lh\) or \(\rh\)).

\[\begin{aligned}
\ctx{\expr}_\lh ::= \\
| & \expr & \\ % ctx_top
| & \deref{\ctx{\expr}_\rh} \\ % ctx_deref
| & \field{\ctx{\expr}_\rh}{id} \\ % ctx_field
\end{aligned}\]

\[\begin{aligned}
\ctx{\expr}_\rh ::= \\
| & \expr & \\ % ctx_top
| & \valof{\ctx{\expr}_\lh} \\ % ctx_rvalof
| & \addrof{\ctx{\expr}_\lh} \\ % ctx_addrof
| & \unop{\odot}{\ctx{\expr}_\rh} \\ % ctx_unop
| & \binop{\oplus}{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_binop_left
| & \binop{\oplus}{\expr_1}{\ctx{\expr_2}_\rh} \\ % ctx_binop_right
| & \cast{\ctx{\expr}_\rh}{\type} \\ % ctx_cast
| & \seqand{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_seqand
| & \seqor{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_seqor
| & \condition{\ctx{\expr_1}_\rh}{\expr_2}{\expr_3} \\ % ctx_condition
| & \assign{\ctx{\expr_1}_\lh}{\expr_2} \\ % ctx_assign_left
| & \assign{\expr_1}{\ctx{\expr_2}_\rh} \\ % ctx_assign_right
| & \assignop{\oplus}{\ctx{\expr_1}_\lh}{\expr_2} \\ % ctx_assignop_left
| & \assignop{\oplus}{\expr_1}{\ctx{\expr_2}_\rh} \\ % ctx_assignop_right
| & \postinc{\oplus}{\ctx{\expr}_\lh} \\ % ctx_postinc
| & \call{\ctx{\expr_1}_\rh}{\overline{\expr_2}} \\ % ctx_call_left
| & \call{\expr_1}{\ctx{\overline{\expr_2}}_\rh} \\ % ctx_call_right
% skipped builtins
| & \comma{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_comma
| & \paren{\ctx{\expr}_\rh}{\type} \\ % ctx_paren
\end{aligned}\]

\judgmenttwo{\(\ctx{\expr}_\lh\)}
            {\(\lenv,\expr \Rightarrow_\lh \expr'\)}
            {\(\estate{\PCT}{\mem,\lenv,\tenv}{\ctx{\expr}}{\cont} \longrightarrow
              \estate{\PCT}{\mem,\lenv,\tenv}{\ctx{\expr'}}{\cont}\)}

\judgmenttwo{\(\ctx{\expr}_\rh\)}
            {\(\PCT, \mem, \tenv, \expr \Rightarrow_\rh \PCT', \mem', \tenv', \expr'\)}
            {\(\estate{\PCT}{\mem,\lenv,\tenv}{\ctx{\expr}}{\cont} \longrightarrow
              \estate{\PCT'}{\mem',\lenv,\tenv'}{\ctx{\expr'}}{\cont}\)}


\paragraph*{Continuations}
\label{app:continuations}

A continuation acts like a stack of pending operations. The base of the stack is
\(\kemp\). \(\mathit{Kdo}\) indicates that a do statement is evaluating an expression.
\(\mathit{Kseq}\) with parameter \(\stmt\) indicates that, after the current statement
is done executing, \(\stmt\) is next. \(\mathit{Kif}\) means that execution is evaluating
the test expression of an if statement, and its parameters are the branches of the
if. Similarly, the test continuations for while, do-while, and for loops indicate that
the test expression is being evaluated. The associated loop continuations indicate that
execution is in the loop body. They continuations carry all of the information of the original
loop.

\[\begin{split}
\cont ::= & \kemp \\
| & \kdo{\cont} \\
| & \kseq{\stmt}{\cont} \\
| & \kif{\stmt_1}{\stmt_2}{L}{\cont} \\
| & \kwhiletest{\expr}{\stmt}{L}{\cont} \\
| & \kwhileloop{\expr}{\stmt}{L}{\cont} \\
| & \kdowhiletest{\expr}{\stmt}{L}{\cont} \\
| & \kdowhileloop{\expr}{\stmt}{L}{\cont} \\
| & \kfor{\expr}{\stmt_2}{\stmt_3}{L}{\cont} \\
| & \kforpost{\expr}{\stmt_2}{\stmt_3}{L}{\cont} \\
| & \kreturn{\cont} \\
| & \kcall{\lenv}{\tenv}{\ctx}{\type}{\cont}
\end{split}\]

Now we present the step rules. These are essentially identical to their
CompCert C equivalents, so there will be little discussion: the important
detail is the presence or absence of control points. We omit the
rules that step to the fail state if a tag rule fails.

\subsection{Sequencing rules}

\sequencing

\subsection{Conditional rules}

\conditionals

\subsection{Loop rules}

\loops
           
\subsection{Call and Return Rules}

\callexprstep
\callstep
\extcallstep

Special external functions, such as malloc, just get their own rules.

\mallocstep

And finally, we have the return rules.

\returnstep
\retvalstep
\retnovalstep

\end{document}
