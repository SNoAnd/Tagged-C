\documentclass{article}

\usepackage{geometry}
\usepackage{xcolor, colortbl}
\usepackage[most]{tcolorbox}
\usepackage{amsmath, amssymb, stmaryrd}
\usepackage{subcaption}
\usepackage{multirow}

\title{An Abstract Model of Compartmentalization with Sharing}
\author{Sean Anderson}

\begin{document}
\maketitle

\input{macros.tex}
\input{tagrules.tex}

\section{Introduction}

This document describes the desired behavior of a compartmentalized C system in terms
of a correct-by-construction abstract machine. The model aims to fulfill a few key
criteria:

\begin{itemize}
\item Compartments are obviously and intuitively isolated from one another
  by construction
\item It is suitable for hardware enforcement without placing intensive constraints
  on the target
\item Inter-compartment interactions via shared memory are possible
\item Compartments can only access shared memory if they have first obtained a
  valid pointer to it, consistent with the C standard and ``capability reasoning''
\end{itemize}

To this last case: we don't necessarily care that compartments' internal behavior
conforms to the C standard. In fact the model explicitly gives compartments
a concrete view of memory, giving definition to code that would be undefined behavior
in the standard. But when it comes to shared memory, the standard has a clear
implication that the memory accessible to a piece of code is determined by
the provenance of pointers that code can access. This model embraces that principle.

\section{Abstract Semantics}

\begin{figure}
  \begin{minipage}[t]{0.49\textwidth}
    \vspace{0em}
    \(C \in \mathcal{C}~~~ b \in \mathit{block}~~~  m \in \mathit{mem}~~~ \alpha \in \mathit{oracle}\)
    \[\begin{aligned}
    \mathcal{C}^+ & ::= \mathbf{L}(C) \mid \mathbf{S}(b, \mathit{base}) &
    \mathit{base} \in \mathit{int} \\
    v \in \mathit{val} & ::= \ldots \mid \mathit{Vptr} ~ c ~ a &
    c \in \mathcal{C}^+, a \in \mathit{int} \\
    e & \in \mathit{ident} \rightharpoonup (\mathcal{C}^+ \times \mathit{int}) \\
    M & \in \mathcal{M} \subseteq \mathcal{C} + \mathit{block} \rightarrow \mathit{mem} \\
    \end{aligned}\]
  \end{minipage}
  \begin{minipage}[t]{0.49\textwidth}
    \vspace{0em}
    \begin{tabular}{l | l}
      \multicolumn{2}{r}{\(\mathit{state} ::= C, \alpha, M, e, \ldots \mid \mathtt{expr}\)} \\
      \hspace{4em} & \(C, \alpha, M, e, \ldots \mid \mathtt{stmt}\) \\
      \hspace{4em} & \(\mathit{CALL}(f, \alpha, M, \ldots)\)  \\
      \hspace{4em} & \(\mathit{RET}(\alpha, M, v, \ldots)\) \\
      \multicolumn{2}{l}{} \\
      \multicolumn{2}{l}{\hspace{1.5em}\((\longrightarrow) \in \mathit{state} \times \mathit{state}\)} \\
    \end{tabular}

  \end{minipage}
    \[\begin{split}
    \mathit{read} \in ~ & \mathit{oracle} \rightarrow \mathcal{C} + \mathit{block}
    \rightarrow \mathit{mem} \rightarrow \mathit{int} \rightharpoonup \mathit{val} \\
    \mathit{write} \in ~ & \mathit{oracle} \rightarrow \mathcal{C} + \mathit{block}
    \rightarrow \mathit{mem} \rightarrow \mathit{int} \rightarrow \mathit{val} \rightharpoonup
    \mathit{mem} \\
    \mathit{heap\_alloc} \in ~ & \mathit{oracle} \rightarrow
    \mathcal{C} + \mathit{block} \rightarrow
    \mathit{int} \rightharpoonup (\mathit{int} \times \mathit{oracle}) \\
    \mathit{heap\_free} \in ~ & \mathit{oracle} \rightarrow
    \mathcal{C}+\mathit{block} \rightarrow \mathit{int} \rightharpoonup
    \mathit{oracle} \\
    \mathit{stk\_alloc} \in ~ & \mathit{oracle} \rightarrow
    \mathcal{C} + \mathit{block} \rightarrow
    \mathit{int} \rightharpoonup (\mathit{int} \times \mathit{oracle}) \\
    \mathit{stk\_free} \in ~ & \mathit{oracle} \rightarrow \mathcal{C}+\mathit{block}
    \rightharpoonup \mathit{oracle} \\
    \mathit{perturb} \in ~ & \mathit{oracle} \rightharpoonup \mathit{oracle} \\
%    \mathit{baseof} \in ~ & \mathit{oracle} \rightarrow \mathit{block} \rightharpoonup \mathit{int} \\
    \end{split}\]

    \caption{Definitions}
    \label{subfig:defs}
  \label{fig:memmod}
\end{figure}
\begin{figure}

  \judgment[ValOfLocal]
           {\(\mathit{read} ~ \alpha ~ C ~ (M ~ C) ~ a = v\)}
           {\(C,\alpha,M,e \mid *(\mathit{Vptr} ~ \mathbf{L}(C) ~ a)
             \longrightarrow C,\alpha,M,e \mid v\)}

  \judgmenttwo[AssignLocal]
              {\(\mathit{write} ~ C ~ (M ~ C) ~ a ~ v = m'\)}
              {\(M' = M[C \mapsto m']\)}
              {\(C,\alpha,M,e \mid *(\mathit{Vptr} ~ \mathbf{L}(C) ~ a) := v
                \longrightarrow C,\alpha,M',e \mid v\)}

  \judgment[ValOfShare]
           {\(\mathit{read} ~ (M ~ b) ~ a = v\)}
           {\(C,\alpha,M,e \mid *(\mathit{Vptr} ~ \mathbf{S}(b, \mathit{base}) ~ a)
             \longrightarrow C,\alpha,M,e \mid v\)}

  \judgmenttwo[AssignShare]
              {\(\mathit{write} ~ (M ~ b) ~ a ~ v = m'\)}
              {\(M' = M[b \mapsto m']\)}
              {\(C,\alpha,M,e \mid *(\mathit{Vptr} ~ \mathbf{S}(b, \mathit{base}) ~ a) := v
                \longrightarrow C,\alpha,M',e \mid v\)}

  \judgment[MallocLocal]
           {\(\mathit{heap\_alloc} ~ \alpha ~ C ~ sz = (p, \alpha')\)}
           {\(C,\alpha,M,e\mid \mathtt{malloc}(\mathit{Vint} ~ sz) \longrightarrow
             C,\alpha',M,e \mid \mathit{Vptr} ~ \mathbf{L}(C) ~ p\)}

  \judgmenttwo[MallocShare]
              {\(\mathit{fresh} ~ b\)}
              {\(\mathit{heap\_alloc} ~ \alpha ~ b ~ sz = (p, \alpha')\)}
              {\(C,\alpha,M,e \mid \mathtt{malloc\_share}(\mathit{Vint} ~ sz) \longrightarrow C,\alpha',M,e \mid \mathit{Vptr} ~ \mathbf{S}(b,p) ~ p\)}

  \judgment[FreeLocal]
           {\(\mathit{heap\_free} ~ \alpha ~ C ~ a = \alpha'\)}
           {\(C,\alpha,M,e \mid \mathtt{free}(\mathit{Vptr} ~ \mathbf{L}(C) ~ a) \longrightarrow
             C,\alpha',M,e \mid \mathit{Vundef}\)}
              
  \judgment[FreeShare]
           {\(\mathit{heap\_free} ~ \alpha ~ b ~ a = \alpha'\)}
           {\(C,\alpha,M,e \mid \mathtt{free}(\mathit{Vptr} ~ (\mathbf{S}(b, \mathit{base})) ~ \mathit{base}) \longrightarrow
             C,\alpha',M,e \mid \mathit{Vundef}\)}
           
  \judgment[CastIntegerPointer]
           {}
           {\(C,\alpha,M,e \mid \mathtt{(t*)} (\mathit{Vint} ~ i) \longrightarrow
             C,\alpha,M,e \mid \mathit{Vptr} ~ \mathbf{L}(C) ~ \mathit{i}\)}

  \caption{Selected Memory Steps}
  \label{subfig:steps}
\end{figure}

We define a C semantics that separates the world into compartments, ranged over by
\(A\), \(B\), \(C\), etc., each with its own separate memory. The core memory model
is shown in Figure \ref{fig:memmod}. The allocator oracle, ranged over by \(\alpha\),
is an abstract state encapsulating information about how allocations
are arrayed inside compartments or as shared blocks. From the programmer's
perspective, \(\alpha\) should be opaque, but for purposes of proving correctness
of a given system it is instantiated to match the actual behavior of the
compiler-allocator-hardware combination. 

The \(\mathit{read}\) and \(\mathit{write}\) operations always operate on a single
abstract memory, which behaves as a flat address space accessed via machine integers
(\(\mathit{int}\)). Operations that access addresses outside of allocated blocks
may or may not failstop, determined by the oracle. If they are successful, they
behave consistently (multiple consecutive loads yield the same value, a load after
a store yields the stored value, etc.) Memories are kept totally
separate, fulfilling our first requirement: compartments' local memories are
definitely never accessible to other compartments.

A pointer value consists of a pair: a ``base'' drawn from the set \(\mathcal{C}^+\)
that determines which memory it accesses, and a machine integer address representing
their concrete position. A base is either \(\mathbf{L}(C)\), for local pointers into
the compartment \(C\), or \(\mathbf{S}(b,\mathit{base})\), where \(b\) is an
abstract block identifier and \(\mathit{base}\) is a machine integer. A
``super-memory'' \(M\) is a map from bases to memories.

Figure \ref{subfigs:steps} shows how loads and stores occur in this system.
The pointer's base determines which memory it accesses, and its value is treated
as the pointer into that memory. A pointer's base can never be changed via
arithmetic---all operations either preserve the base, or demote their result
to a plain integer.

\paragraph{Allocation}

The abstract operations \(\mathit{heap\_alloc}\) and \(\mathit{stk\_alloc}\)
yield addresses at which to locate a new block, either within a compartment's memory
or in its own isolated block. In the latter case, the address provided becomes
the new base of that block's base. It also updates the oracle to reflect that loads
and stores to the new block will not failstop (see Section \ref{sec:axioms}). Since
the \(\mathit{*\_alloc}\) operations are parameterized by the compartment
or block that they allocate, they are allowed to make decisions based on that
information, such as attempting to keep compartment-local allocations in designated
regions to protect using a page-table-based enforcement mechanism. When proving
program properties in this setting, one should quantify over all possible oracles,
but when proving correctness of an implementation we restrict ourselves to oracles
that reflect its actually behavior.

\paragraph{Arithmetic and Integer-Pointer Casts}

Most arithmetic operations are typical of C. The interesting operations are those
involving integers that have been cast from pointers. We give concrete definitions
to all such operations based on their address. As shown in \ref{fig:arith}, if they
involve only a single former pointer, the result will also be a pointer into the
same memory; otherwise the result is a plain integer. If the former pointer is cast
back to a pointer type, it retains its value and is once again a valid pointer.
Otherwise, if an integer value is cast to a pointer, the result is always a local
pointer to the active compartment, as shown in Figure \ref{subfig:steps}.

\begin{figure}
  \judgment[Unop]
           {}
           {\(C,\alpha,M,e \mid \odot (\mathit{Vptr} ~ I ~ a) \longrightarrow
             C,\alpha,M,e \mid \mathit{Vptr} ~ I ~ (\langle \odot \rangle a)\)}
           
  \judgment[BinopPointerInteger]
           {}
           {\(C,\alpha,M,e \mid (\mathit{Vptr} ~ I ~ a) \oplus
             (\mathit{Vint} ~ i) \longrightarrow
             C,\alpha,M,e \mid \mathit{Vptr} ~ I ~ (a \langle \oplus \rangle i)\)}

  \judgment[BinopIntegerPointer]
           {}
           {\(C,\alpha,M,e \mid (\mathit{Vint} ~ i) \oplus
             (\mathit{Vptr} ~ I ~ a) \longrightarrow
           C,\alpha,M,e \mid \mathit{Vptr} ~ I ~ (i \langle \oplus \rangle a)\)}

  \judgment[BinopPointers]
           {}
           {\(C,\alpha,M,e \mid (\mathit{Vptr} ~ I ~ a_1) \oplus
             (\mathit{Vptr} ~ I ~ a_2) \longrightarrow
             C,\alpha,M,e \mid \mathit{Vint} ~ (a_1 \langle \oplus \rangle a_2)\)}

  \caption{Arithmetic Operations Involving Pointers}
  \label{fig:arith}
\end{figure}

\paragraph{Calls and Returns}

There are two interesting details of the call and return semantics:
they allocate and deallocate memory, and they can cross compartment boundaries.
In the first case, we need to pay attention to which stack-allocated
objects are to be shared. This can again be done using escape analysis:
objects whose references never escape, can be allocated locally. Objects whose
references escape to another compartment must be allocated as shared.
Those that escape to another function in the same compartment can be treated
in either way; if they are allocated locally but are later passed outside the
compartment, the system will failstop at that later point
(see Section \ref{sec:interfaces}).

We assume that each local variable comes pre-annotated with how it should
be allocated, with a simple flag \(\mathbf{L}\) or \(\mathbf{S}\), so that
a function signature is a list of tuples \((id,\mathbf{L} \mid \mathbf{S},sz)\).
(Aside: there is a case to be made we should just allocate all stack objects locally
barring some critical use case for share them. Doing so would simplify the model
here.)

The allocation and deallocation of stack memory is shown in the step rules in
Section \ref{fig:callret}. In the full semantics, calls and returns step through
intermediate states, written \(\mathit{CALL}\) and \(\mathit{RET}\). During the
step from the intermediate callstate into the function code proper, the semantics
looks up the function being called and allocates its local variables before beginning
to execute its statement. And during the step from the {\tt return} statement into
the intermediate returnstate, the semantics likewise deallocates every variable it had
previously allocated.

\begin{figure}
  \[\mathit{alloc\_locals} ~ C ~ \alpha ~ \mathit{ls} =
  \begin{cases}
    (\alpha, \lambda \mathit{id}. \bot) & \textnormal{if } \mathit{ls} = [~]\\
    (\alpha'', e[\mathit{id} \mapsto (\mathbf{L}(C),i)]) &
    \textnormal{if } \mathit{ls} = (id,\mathbf{L},sz)::\mathit{ls}',\\
    & \textnormal{where } \mathit{alloc\_locals} ~ C ~ \alpha ~ \mathit{ls}' =
    (\alpha', e) \\
    & \textnormal{and } \mathit{stk\_alloc} ~ \alpha' ~ C ~ sz = (i, \alpha'') \\
    (\alpha'', e[\mathit{id} \mapsto (\mathbf{S}(b,i),i)]) &
    \textnormal{if } \mathit{ls} = (id,\mathbf{S},sz)::\mathit{ls}',\\
    & \textnormal{where } \mathit{alloc\_locals} ~ C ~ \alpha ~ \mathit{ls}' =
    (\alpha', e) \\
    & \textnormal{and for fresh } b, \mathit{stk\_alloc} ~ \alpha' ~ b ~ sz = (i, \alpha'') \\
  \end{cases}\]

  \[\mathit{dealloc\_locals} ~ \alpha ~ e =
  \begin{cases}
    \mathit{stk\_free} ~ \alpha' ~ C ~ i &
    \textnormal{if for some } id, e ~ id = (\mathbf{L}(C),i),\\
    & \textnormal{where } \mathit{dealloc\_locals} ~ \alpha ~ e[id \mapsto \bot] =
    \alpha' \\
    \mathit{stk\_free} ~ \alpha' ~ b ~ i &
    \textnormal{if for some } id, e ~ id = (\mathbf{S}(b,i),i),\\
    & \textnormal{where } \mathit{dealloc\_locals} ~ \alpha ~ e[id \mapsto \bot] =
    \alpha' \\
    \alpha & \textnormal{otherwise} \\
  \end{cases}\]
  
  \judgmenttwo[FromCallstate]
              {\(f = (C,\mathit{locals},s)\)}
              {\(\mathit{alloc\_locals} ~ C ~ \alpha ~ \mathit{locals} =
                (\alpha',e)\)}
              {\(\mathit{CALL}(f,\alpha,M) \longrightarrow
                C,\mathit{perturb} ~ \alpha',M,e \mid s\)}

  \judgment[Return]
           {\(\mathit{dealloc\_locals} ~ \alpha ~ e = \alpha'\)}
           {\(C,\alpha,M,e \mid \mathtt{return} ~ v \longrightarrow
             \mathit{RET}(\alpha,M,v)\)}
           
  \caption{Call and Return Semantics (Continuations omitted)}
  \label{fig:callret}
\end{figure}

\section{Axioms of the Oracle}
\label{sec:axioms}

\begin{figure}
  \begin{subfigure}{0.5\textwidth}
    \judgment[ReadWrite]
             {\(\mathit{write} ~ \alpha ~ B ~ m ~ a ~ v = m'\)}
             {\(\mathit{read} ~ \alpha ~ B ~ m' ~ a ~ v\)}
    \judgmenttwo[WriteStable]
                {\(a \not = a'\)}
                {\(\mathit{write} ~ \alpha ~ m ~ a' ~ v = m'\)}
                {\(\mathit{read} ~ \alpha ~ B ~ m ~ a =
                  \mathit{read} ~ \alpha ~ B ~ m' ~ a\)}
    \judgmentbr[ReadLiveH]
               {\(LiveH ~ \alpha ~ (B,a_1, a_2)\)}
               {\(a_1 \leq a < a_2\)}
               {\(\exists v . \mathit{read} ~ \alpha ~ B ~ a = v\)}
    \judgmentbr[WriteLiveH]
               {\(LiveH ~ \alpha ~ (B,a_1, a_2)\)}
               {\(a_1 \leq a < a_2\)}
               {\(\exists m' . \mathit{write} ~ \alpha ~ m ~ a ~ v = m'\)}
    \judgmentbr[ReadLiveS]
               {\((B,a_1, a_2) \in LiveS(\alpha)\)}
               {\(a_1 \leq a < a_2\)}
               {\(\exists v . \mathit{read} ~ \alpha ~ B ~ a = v\)}
    \judgmentbr[WriteLiveS]
               {\((B,a_1, a_2) \in LiveS(\alpha)\)}
               {\(a_1 \leq a < a_2\)}
               {\(\exists m' . \mathit{write} ~ \alpha ~ m ~ a ~ v = m'\)}

  \caption{Facts about Reads and Writes}
  \end{subfigure}
  \begin{subfigure}{0.49\textwidth}
    \judgment[HeapAlloc]
             {\(\mathit{heap\_alloc} ~ \alpha ~ B ~ s = (i, \alpha')\)}
             {\(LiveH ~ \alpha' ~ (B,i,i+s)\)}
    \judgmentbr[HeapAllocDisjH]
               {\(LiveH ~ \alpha ~ (B,a_1,a_2)\)} 
               {\(\mathit{heap\_alloc} ~ \alpha ~ B ~ s = (i, \alpha')\)}
               {\(i+s < a_1\) or \(a_2 \leq i\)}
    \judgmentbr[HeapAllocDisjS]
               {\((B,a_1,a_2) \in LiveS(\alpha)\)} 
               {\(\mathit{heap\_alloc} ~ \alpha ~ B' ~ s = (i, \alpha')\)}
               {\(i+s < a_1\) or \(a_2 \leq i\)}
    \judgmentbr[HeapAllocStabH]
               {\(LiveH ~ \alpha ~ (B,a_1,a_2)\)} 
               {\(\mathit{heap\_alloc} ~ \alpha ~ B' ~ s = (i, \alpha')\)}
               {\(LiveH ~ \alpha' ~ (B,a_1,a_2)\)}
    \judgment[HeapAllocStabS]
             {\(\mathit{heap\_alloc} ~ \alpha ~ B ~ s = (i, \alpha')\)}
             {\(LiveS(\alpha') = LiveS(\alpha)\)}
    \caption{Facts about Heap Alloc}  
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \judgment[StkAlloc]
             {\(\mathit{stk\_alloc} ~ \alpha ~ B ~ s = (i, \alpha')\)}
             {\(LiveS(\alpha') = (B,i,i+s)::LiveS(\alpha)\)}
    \judgmentbr[StkAllocDisjH]
               {\(LiveH ~ \alpha ~ (B,a_1,a_2)\)} 
               {\(\mathit{stk\_alloc} ~ \alpha ~ B' ~ s = (i, \alpha')\)}
               {\(i+s < a_1\) or \(a_2 \leq i\)}
    \judgmentbr[StkAllocDisjS]
               {\((B,a_1,a_2) \in LiveS(\alpha)\)} 
               {\(\mathit{stack\_alloc} ~ \alpha ~ B' ~ s = (i, \alpha')\)}
               {\(i+s < a_1\) or \(a_2 \leq i\)}
    \judgmentbr[StkAllocStabH]
               {\(LiveH ~ \alpha ~ (B,a_1,a_2)\)} 
               {\(\mathit{stk\_alloc} ~ \alpha ~ B ~ s = (i, \alpha')\)}
               {\(LiveH ~ \alpha' ~ (B,a_1,a_2)\)}
    \caption{Facts about Stack Alloc}
  \end{subfigure}
  \begin{subfigure}{0.49\textwidth}
    \judgment[HeapFreeSuccess]
             {\(LiveH ~ \alpha ~ (B,a_1,a_2)\)}
             {\(\mathit{heap\_free} ~ \alpha ~ B ~ a_1 = \alpha'\)}
    \judgment[HeapFreeStabS]
             {\(\mathit{heap\_free} ~ \alpha ~ B ~ a = \alpha'\)}
             {\(LiveS(\alpha') = LiveS(\alpha)\)}
    \judgmentbrbr[HeapFreeStabH]
                 {\(LiveH ~ \alpha ~ (B,a_1,a_2)\)}
                 {\(a < a_1\) or \(a_2 \leq a\)}
                 {\(\mathit{heap\_free} ~ \alpha ~ B' ~ a = \alpha'\)}
                 {\(LiveH ~ \alpha' ~ (B,a_1,a_2)\)}
    \judgment[StkFreeStabS]
             {\(\mathit{stk\_free} ~ \alpha ~ B' = \alpha'\)}
             {\(\underline{~~}::LiveS(\alpha') = LiveS(\alpha)\)}
    \judgmentbr[StkFreeStabH]
               {\(LiveH ~ \alpha ~ (B,a_1,a_2)\)}
               {\(\mathit{stk\_free} ~ \alpha ~ B' = \alpha'\)}
               {\(LiveH ~ \alpha' ~ (B,a_1,a_2)\)}
    \caption{Facts about Free}
  \end{subfigure}
  \begin{subfigure}{\textwidth}

    \begin{minipage}{0.5\textwidth}
      \judgmentbr[PerturbStabH]
                 {\(LiveH ~ \alpha ~ (B,a_1,a_2)\)}
                 {\(\mathit{perturb} ~ \alpha = \alpha'\)}
                 {\(LiveH ~ \alpha' ~ (B,a_1,a_2)\)}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
    \judgment[PerturbStabS]
             {\(\mathit{perturb} ~ \alpha = \alpha'\)}
             {\(LiveS(\alpha') = LiveS(\alpha)\)}
    \end{minipage}
    \judgmenttwobr[PerturbStabValH]
                  {\(\mathit{read} ~ \alpha ~ B ~ m ~ a = v\)}
                  {\(\mathit{perturb} ~ \alpha = \alpha'\)}
                  {\(LiveH ~ \alpha ~ (B,a_1,a_2)\)}
                  {\(a_1 \leq a < a_2\)}
                  {\(\mathit{read} ~ \alpha' ~ B ~ m ~ a = v\)}

    \judgmenttwobr[PerturbStabValS]
                  {\(\mathit{read} ~ \alpha ~ B ~ m ~ a = v\)}
                  {\(\mathit{perturb} ~ \alpha = \alpha'\)}
                  {\((B,a_1,a_2) \in LiveS(\alpha)\)}
                  {\(a_1 \leq a < a_2\)}
                  {\(\mathit{read} ~ \alpha' ~ B ~ m ~ a = v\)}
                 
    \caption{Facts about Perturb}
  \end{subfigure}
  
  \caption{Assertion Rules}
  \label{fig:asserts}
\end{figure}

The allocation oracle hides the behavior of the compiler behind an abstract
interface that produces addresses on command. Our semantics behaves
nondeterministically in a general sense, but all nondeterministic behaviors are
captured by the oracle. Given a particular oracle, the semantics is deterministic.

Here we axiomitize the oracle. We define two kinds of statements that we can make
about the locations of allocated regions. The proposition
\(\mathit{LiveH} ~ \alpha ~ (B, a_1, a_2)\) means that, according to \(\alpha\), the
region from \(a_1\) to \(a_2\) is allocated in the heap and belongs to the base
\(B\). \(\mathit{LiveS}(\alpha)\) is a list of triples \((B, a_1, a_2)\) representing
the stack, such that any \((B, a_1, a_2) \in \mathit{LiveS}(\alpha)\) designates
a stack allocated block in \(\alpha\). \(\mathit{LiveS}\) is map from an oracle
to a stack because calls to \(\mathit{stk\_free}\) should only ever deallocate
the most-recently-allocated object, so we must maintain the order.

The full set of axioms is found in Figure \ref{fig:asserts}. Importantly,
allocations are guaranteed to be disjoint from any prior allocations.
In fact, because all compartments share an oracle, this is the case even for
allocations from other compartments---convenient, because we assume that we are
targeting a system with a single address space, and this guarantees that any valid
allocator must be that can fit in that address space. Addresses in allocated regions
are guaranteed successful loads and stores, and loads following successful stores
are always successful (and return the stored value) even if outside of allocated
regions.

The \(\mathit{perturb}\) operation mutates the allocator oracle to represent the
possibility of compiler-generated code using unallocated memory and therefore changing
its value or rendering it inaccessible. The only facts that are maintained over a
call to perturb are those involving addresses in allocated regions. Perturb happens
during every function call and return, because the compiler needs to be free to
reallocate memory during those operations, but it may happen at other points in the
semantics as well.

\section{Cross-compartment interfaces}
\label{sec:interfaces}

In this system, each function is assigned to a compartment. A compartment interface
is a subset of the functions in the compartment that are publicly accessible.
At any given time, the compartment that contains the currently active function is
considered the active compartment. It is illegal to call a private function in an
inactive compartment.

Public functions may not receive \(L(\dots)\)-based pointer arguments.
Private functions may take either kind of pointer as argument. \(L(\dots)\) pointers
may also not be stored to shared memory. This guarantees that there can be no
confusion between shared pointers and a compartment's own local pointer that
escaped its control. Violations of a compartment interface exhibit failstop behavior.

As a consequence of these rules, a compartment can never obtain a
\(\mathbf{L}(\dots)\)-based pointer from a compartment other than itself.
It can recieve such a pointer if it is cast to an integer type. If the resulting
integer is cast back into a pointer, it will have the same behavior as if it were cast
from any other integer: accessing it may cause a failstop or else access the
appropriate address in the active compartment's block.

\section{Machine Constraints}

Now we consider the constraints that this system places on potential implementations.
In particular, in a tag-based enforcemen mechanism with a limited quantity of tags,
is this system realistic? In general it requires a unique tag per compartment,
as well as one for each shared allocation. In the extreme, consider a system along
the lines of ARM's MTE, which has four-bit tags. That could only enforce this
semantics for a very small program, or one with very little shared memory (fewer than sixteen tags, so perhaps two-four compartments and around a dozen shared objects.)

On the other hand, this semantics is a reasonable goal under an enforcement mechanism
with even eight-bit tags (512 compartments and shared objects.) If we go up to sixteen
bits, we can support programs with thousands of shared objects.

That said, it only takes a minor adjustment for this model to be enforceable in even
the smallest of tag-spaces. Instead of separate dynamic blocks for each shared
object, we let the base of each memory region consist of the set of compartments
that have permission to access it. We parameterize each instance of {\tt malloc}
with such a set, which will be the base of each pointer that it allocates. We write
the identifiers for these {\tt malloc} invocations \(\mathtt{malloc}_B\).
Then we replace the relevant definitions and step rules with those in
Figure \ref{fig:powerset}, with call and return steps changed similarly.

This version can be enforced with a number of tags equal to the number of different
sharing combinations present in the system---in the worst case this would be
exponential in the number of compartments, but in practice it can be tuned to be
arbitrarily small. (In extremis, all shared objects can be grouped together to run
on a machine with only two tags.) Sadly it strays from the C standard in its
temporal memory safety: under some circumstances a shared object can be accessed
by a compartment that it has not (yet) been shared with.

\begin{figure}
    \[\begin{aligned}
    \mathit{val} & ::= \ldots \mid \mathit{Vptr} ~ B ~ a &
    B \in 2^{\mathcal{C}}
    \end{aligned}\]
    %
    \[\begin{split}
    e & \in \mathit{ident} \rightharpoonup (2^{\mathcal{C}} \times \mathit{int}) \\
    M \in ~ & \mathcal{M} \subseteq 2^{\mathcal{C}} \rightarrow \mathit{mem} \\
    \mathit{heap\_alloc} \in ~ & \mathit{oracle} \rightarrow
    2^{\mathcal{C}} \rightarrow \mathit{int} \rightharpoonup
    (\mathit{int} \times \mathit{oracle}) \\
    \mathit{heap\_free} \in ~ & \mathit{oracle} \rightarrow 2^{\mathcal{C}} \rightarrow
    \mathit{int} \rightharpoonup \mathit{oracle} \\
    \mathit{stk\_alloc} \in ~ & \mathit{oracle} \rightarrow
    2^{\mathcal{C}} \rightarrow \mathit{int} \rightharpoonup
    (\mathit{int} \times \mathit{oracle}) \\
    \mathit{stk\_free} \in ~ & \mathit{oracle} \rightarrow 2^{\mathcal{C}}
    \rightharpoonup \mathit{oracle} \\
%    \mathit{baseof} \in ~ & \mathit{oracle} \rightarrow \mathit{block} \rightharpoonup \mathit{int} \\
    \end{split}\]
    \judgment[ValOf]
             {\(\mathit{read} ~ \alpha ~ B ~ (M ~ B) ~ a = v\)}
             {\(C,\alpha,M,e \mid *(\mathit{Vptr} ~ B ~ a)
               \longrightarrow C, \alpha, M \mid v\)}

             \judgmenttwo{\(\mathit{write} ~ \alpha ~ B ~ (M ~ B) ~ a ~ v = m'\)}
                {\(M' = M[B \mapsto m']\)}
                {\(C,\alpha,M,e \mid *(\mathit{Vptr} ~ B ~ a) := v
                  \longrightarrow C,\alpha,M',e \mid v\)}

    \judgment{\(\mathit{heap\_alloc} ~ \alpha ~ B ~ sz = (p, \alpha')\)}
             {\(C,\alpha,M,e \mid \mathtt{malloc}_B(\mathit{Vint} ~ sz)
               \longrightarrow C,\alpha',M,e \mid \mathit{Vptr} ~ B ~ p\)}
    \judgment{}
             {\(C,\alpha,M,e \mid \mathtt{(t*)} (\mathit{Vint} ~ i) \longrightarrow
               C,\alpha,M,e \mid \mathit{Vptr} ~ \{C\} ~ \mathit{i}\)}

  \caption{Memory With Explicit Sharing}
  \label{fig:powerset}
\end{figure}

\end{document}
