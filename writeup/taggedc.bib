@article{Denning77:SecureInformationFlow,
author = {Denning, Dorothy E. and Denning, Peter J.},
title = {Certification of Programs for Secure Information Flow},
year = {1977},
issue_date = {July 1977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {20},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/359636.359712},
doi = {10.1145/359636.359712},
abstract = {ertification mechanism for verifying the secure flow of information through a program. Because it exploits the properties of a lattice structure among security classes, the procedure is sufficiently simple that it can easily be included in the analysis phase of most existing compilers. Appropriate semantics are presented and proved correct. An important application is the confinement problem: The mechanism can prove that a program cannot cause supposedly nonconfidential results to depend on confidential input data.},
journal = {Commun. ACM},
month = {jul},
pages = {504–513},
numpages = {10},
keywords = {program certification, confinement, information flow, security, lattice, protection, security classes}
}

@inproceedings{Chhak21:Tagine,
author = {Chhak, CHR and Tolmach, Andrew and Anderson, Sean},
title = {Towards Formally Verified Compilation of Tag-Based Policy Enforcement},
year = {2021},
isbn = {9781450382991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3437992.3439929},
doi = {10.1145/3437992.3439929},
abstract = {Hardware-assisted reference monitoring is receiving increasing attention as a way to improve the security of existing software. One example is the PIPE architecture extension, which attaches metadata tags to register and memory values and executes tag-based rules at each machine instruction to enforce a software-defined security policy. To use PIPE effectively, engineers should be able to write security policies in terms of source-level concepts like functions, local variables, and structured control operators, which are not visible at machine level. It is the job of the compiler to generate PIPE-aware machine code that enforces these source-level policies. The compiler thus becomes part of the monitored system’s trusted computing base---and hence a prime candidate for verification. To formalize compiler correctness in this setting, we extend the source language semantics with its own form of user-specified tag-based monitoring, and show that the compiler preserves that monitoring behavior. The challenges of compilation include mapping source-level monitoring policies to instruction-level tag rules, preserving fail-stop behaviors, and satisfying the surprisingly complex preconditions for conventional optimizations. In this paper, we describe the design and verification of Tagine, a small prototype compiler that translates a simple tagged WHILE language to a tagged register transfer language and performs simple optimizations. Tagine is based on the RTLgen and Deadcode phases of the CompCert compiler, and hence is written and verified in Coq. This work is a first step toward verification of a full-scale compiler for a realistic tagged source language.},
booktitle = {Proceedings of the 10th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {137–151},
numpages = {15},
keywords = {tag-based secure hardware, reference monitors, verified compilers, Coq proof assistant},
location = {Virtual, Denmark},
series = {CPP 2021}
}

@inproceedings{Dhawan14:PUMP,
    title = {{PUMP: A Programmable Unit for Metadata Processing}},
    year = {2014},
    booktitle = {Proceedings of the Third Workshop on Hardware and Architectural Support for Security and Privacy},
    author = {Dhawan, Udit and Vasilakis, Nikos and Rubin, Raphael and Chiricescu, Silviu and Smith, Jonathan M and Knight Jr., Thomas F and Pierce, Benjamin C and DeHon, André},
    pages = {8:1–8:8},
    series = {HASP '14},
    publisher = {ACM},
    url = {http://doi.acm.org/10.1145/2611765.2611773},
    address = {New York, NY, USA},
    isbn = {978-1-4503-2777-0},
    doi = {10.1145/2611765.2611773},
    keywords = {control-flow integrity, memory safety, metadata, security, tagged architecture, taint tracking}
}

@INPROCEEDINGS{NWF20:Cornucopia,  author={Wesley Filardo, Nathaniel and Gutstein, Brett F. and Woodruff, Jonathan and Ainsworth, Sam and Paul-Trifu, Lucian and Davis, Brooks and Xia, Hongyan and Tomasz Napierala, Edward and Richardson, Alexander and Baldwin, John and Chisnall, David and Clarke, Jessica and Gudka, Khilan and Joannou, Alexandre and Theodore Markettos, A. and Mazzinghi, Alfredo and Norton, Robert M. and Roe, Michael and Sewell, Peter and Son, Stacey and Jones, Timothy M. and Moore, Simon W. and Neumann, Peter G. and Watson, Robert N. M.},  booktitle={2020 IEEE Symposium on Security and Privacy (SP)},   title={Cornucopia: Temporal Safety for CHERI Heaps},   year={2020},  volume={},  number={},  pages={608-625},  doi={10.1109/SP40000.2020.00098}}

@article{Skorstengaard19:stktokens,
  title={{StkTokens: Enforcing Well-bracketed Control Flow and Stack Encapsulation using Linear Capabilities}},
  author={Skorstengaard, Lau and Devriese, Dominique and Birkedal, Lars},
  journal={Proceedings of the ACM on Programming Languages},
  volume={3},
  number={POPL},
  pages={1--28},
  year={2019},
  publisher={ACM New York, NY, USA}
}

@techreport{Anderson72:PlanningStudy,
  added-at = {2014-05-27T19:25:15.000+0200},
  author = {Anderson, James P.},
  biburl = {https://www.bibsonomy.org/bibtex/25573401b3a88058a07c519b6b6e19bde/privtec},
  institution = {U.S. Air Force Electronic Systems Division},
  month = {10},
  title = {{C}omputer {S}ecurity {T}echnology {P}lanning {S}tudy},
  volume = 2,
  year = 1972
}

@inproceedings{Goguen82:SecurityPolicies,
  added-at = {2016-06-15T00:00:00.000+0200},
  author = {Goguen, Joseph A. and Meseguer, José},
  booktitle = {IEEE Symposium on Security and Privacy},
  ee = {http://doi.ieeecomputersociety.org/10.1109/SP.1982.10014},
  isbn = {0-8186-0410-7},
  keywords = {dblp},
  pages = {11-20},
  publisher = {IEEE Computer Society},
  title = {Security Policies and Security Models.},
  url = {http://dblp.uni-trier.de/db/conf/sp/sp1982.html#GoguenM82a},
  year = 1982
}

﻿@phdthesis{Lundblad13IRM:,
   author = {Lundblad, Andreas},
   institution = {KTH, Theoretical Computer Science, TCS},
   note = {QC 20130220},
   pages = {viii, 20},
   school = {KTH, Theoretical Computer Science, TCS},
   title = {Inlined Reference Monitors : Certification,Concurrency and Tree Based Monitoring},
   series = {Trita-CSC-A},
   ISSN = {1653-5723},
   number = {2013:01},
   keywords = {Runtime monitoring, policy enforcement, tree automata, monitor inlining, certification, concurrency},
   abstract = {Reference monitor inlining is a technique for enforcing security policies by injecting security checks into the untrusted software in a style similar to aspect-oriented programming. The intention is that the injected code enforces compliance with the policy (security), without adding behavior (conservativity) or affecting existing policy compliant behavior (transparency). This thesis consists of four papers which covers a range of topics including formalization of monitor inlining correctness properties, certification of inlined monitors, limitations in multithreaded settings and extensions using data-flow monitoring. The first paper addresses the problem of having a potentially complex program rewriter as part of the trusted computing base. By means of proof-carrying code we show how the inliner can be replaced by a relatively simple proof-checker. This technique also enables the use of monitor inlining for quality assurance at development time, while minimizing the need for post-shipping code rewrites. The second paper focuses on the issues associated with monitor inlining in a concurrent setting. Specifically, it discusses the problem of maintaining transparency when introducing locks for synchronizing monitor state reads and updates. Due to Java's relaxed memory model, it turns out to be impossible for a monitor to be entirely transparent without sacrificing the security property. To accommodate for this, the paper proposes a set of new correctness properties shown to be realistic and realizable. The third paper also focuses on problems due to concurrency and identifies a class of race-free policies that precisely characterizes the set of inlineable policies. This is done by showing that inlining of a policy outside this class is either not secure or not transparent, and by exhibiting a concrete algorithm for inlining of policies inside the class which is secure, conservative, and transparent. The paper also discusses how certification in the style of proof-carrying code could be supported in multithreaded Java programs. The fourth paper formalizes a new type of data centric runtime monitoring which combines monitor inlining with taint tracking. As opposed to ordinary techniques which focus on monitoring linear flows of events, the approach presented here relies on tree shaped traces. The paper describes how the approach can be efficiently implemented and presents a denotational semantics for a simple ``while'' language illustrating how the theoretical foundations is to be used in a practical setting. Each paper is concluded by a practical evaluation of the theoretical results, based on a prototype implementation and case studies on real-world applications and policies. },
   ISBN = {978-91-7501-654-2},
   year = {2013}
}

@article{Bessey10:Coverity,
author = {Bessey, Al and Block, Ken and Chelf, Ben and Chou, Andy and Fulton, Bryan and Hallem, Seth and Henri-Gros, Charles and Kamsky, Asya and McPeak, Scott and Engler, Dawson},
title = {A Few Billion Lines of Code Later: Using Static Analysis to Find Bugs in the Real World},
year = {2010},
issue_date = {February 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {53},
number = {2},
issn = {0001-0782},
url = {https://doi.org/10.1145/1646353.1646374},
doi = {10.1145/1646353.1646374},
abstract = {How Coverity built a bug-finding tool, and a business, around the unlimited supply of bugs in software systems.},
journal = {Commun. ACM},
month = {feb},
pages = {66–75},
numpages = {10}
}

@article{Leroy09:CompCert,
author = {Leroy, Xavier},
title = {Formal Verification of a Realistic Compiler},
year = {2009},
issue_date = {July 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/1538788.1538814},
doi = {10.1145/1538788.1538814},
abstract = {This paper reports on the development and formal verification (proof of semantic preservation) of CompCert, a compiler from Clight (a large subset of the C programming language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a verified compiler is useful in the context of critical software and its formal verification: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
journal = {Commun. ACM},
month = {jul},
pages = {107–115},
numpages = {9}
}

% nice to see this no longer requires an extra package to play nicely with acm bib
% https://www.acm.org/publications/authors/reference-formatting 
% https://www.acm.org/publications/authors/bibtex-formatting 
%Example from above 
% online{Thornburg01,
% author ={Harry Thornburg},
% year = {2001},
% title ={Introduction to Bayesian Statistics},
% url ={http://ccrma.stanford.edu/~jos/bayes/bayes.html},
% month ={mar},
% lastaccessed ={March 2, 2005},
%}

@online{apache97:main-site,
author ={The Apache Software Foundation},
year = {1997},
title ={Apache HTTP Server Project},
url ={https://httpd.apache.org/},
lastaccessed ={April 11, 2023},
}

% oldest comment appears to date from 2015, but I can't find an exact publication date
 @online{Munoz:PoweredbyC,
author ={Daniel Munoz},
year = {}, 
title ={After All These Years, the World is Still Powered by C Programming},
url ={https://www.toptal.com/c/after-all-these-years-the-world-is-still-powered-by-c-programming},
lastaccessed ={April 11, 2023},
}

 @online{stackoverflow22:dev-survey,
author ={Stack Overflow},
year = {2022},
title ={2022 Stack Overflow Annual Developer Survey},
url ={https://survey.stackoverflow.co/2022/},
lastaccessed ={April 11, 2023},
}

@InProceedings{Askarov08:TINILeaks,
author="Askarov, Aslan
and Hunt, Sebastian
and Sabelfeld, Andrei
and Sands, David",
editor="Jajodia, Sushil
and Lopez, Javier",
title="Termination-Insensitive Noninterference Leaks More Than Just a Bit",
booktitle="Computer Security - ESORICS 2008",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="333--348",
abstract="Current tools for analysing information flow in programs build upon ideas going back to Denning's work from the 70's. These systems enforce an imperfect notion of information flow which has become known as termination-insensitive noninterference. Under this version of noninterference, information leaks are permitted if they are transmitted purely by the program's termination behaviour (i.e., whether it terminates or not). This imperfection is the price to pay for having a security condition which is relatively liberal (e.g. allowing while-loops whose termination may depend on the value of a secret) and easy to check. But what is the price exactly? We argue that, in the presence of output, the price is higher than the ``one bit'' often claimed informally in the literature, and effectively such programs can leak all of their secrets. In this paper we develop a definition of termination-insensitive noninterference suitable for reasoning about programs with outputs. We show that the definition generalises ``batch-job'' style definitions from the literature and that it is indeed satisfied by a Denning-style program analysis with output. Although more than a bit of information can be leaked by programs satisfying this condition, we show that the best an attacker can do is a brute-force attack, which means that the attacker cannot reliably (in a technical sense) learn the secret in polynomial time in the size of the secret. If we further assume that secrets are uniformly distributed, we show that the advantage the attacker gains when guessing the secret after observing a polynomial amount of output is negligible in the size of the secret.",
isbn="978-3-540-88313-5"
}
