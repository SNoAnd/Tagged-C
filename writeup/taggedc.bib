@article{Denning77:SecureInformationFlow,
author = {Denning, Dorothy E. and Denning, Peter J.},
title = {Certification of Programs for Secure Information Flow},
year = {1977},
issue_date = {July 1977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {20},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/359636.359712},
doi = {10.1145/359636.359712},
abstract = {ertification mechanism for verifying the secure flow of information through a program. Because it exploits the properties of a lattice structure among security classes, the procedure is sufficiently simple that it can easily be included in the analysis phase of most existing compilers. Appropriate semantics are presented and proved correct. An important application is the confinement problem: The mechanism can prove that a program cannot cause supposedly nonconfidential results to depend on confidential input data.},
journal = {Commun. ACM},
month = {jul},
pages = {504–513},
numpages = {10},
keywords = {program certification, confinement, information flow, security, lattice, protection, security classes}
}

@inproceedings{Chhak21:Tagine,
author = {Chhak, CHR and Tolmach, Andrew and Anderson, Sean},
title = {Towards Formally Verified Compilation of Tag-Based Policy Enforcement},
year = {2021},
isbn = {9781450382991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3437992.3439929},
doi = {10.1145/3437992.3439929},
abstract = {Hardware-assisted reference monitoring is receiving increasing attention as a way to improve the security of existing software. One example is the PIPE architecture extension, which attaches metadata tags to register and memory values and executes tag-based rules at each machine instruction to enforce a software-defined security policy. To use PIPE effectively, engineers should be able to write security policies in terms of source-level concepts like functions, local variables, and structured control operators, which are not visible at machine level. It is the job of the compiler to generate PIPE-aware machine code that enforces these source-level policies. The compiler thus becomes part of the monitored system’s trusted computing base---and hence a prime candidate for verification. To formalize compiler correctness in this setting, we extend the source language semantics with its own form of user-specified tag-based monitoring, and show that the compiler preserves that monitoring behavior. The challenges of compilation include mapping source-level monitoring policies to instruction-level tag rules, preserving fail-stop behaviors, and satisfying the surprisingly complex preconditions for conventional optimizations. In this paper, we describe the design and verification of Tagine, a small prototype compiler that translates a simple tagged WHILE language to a tagged register transfer language and performs simple optimizations. Tagine is based on the RTLgen and Deadcode phases of the CompCert compiler, and hence is written and verified in Coq. This work is a first step toward verification of a full-scale compiler for a realistic tagged source language.},
booktitle = {Proceedings of the 10th ACM SIGPLAN International Conference on Certified Programs and Proofs},
pages = {137–151},
numpages = {15},
keywords = {tag-based secure hardware, reference monitors, verified compilers, Coq proof assistant},
location = {Virtual, Denmark},
series = {CPP 2021}
}

@inproceedings{Dhawan14:PUMP,
    title = {{PUMP: A Programmable Unit for Metadata Processing}},
    year = {2014},
    booktitle = {Proceedings of the Third Workshop on Hardware and Architectural Support for Security and Privacy},
    author = {Dhawan, Udit and Vasilakis, Nikos and Rubin, Raphael and Chiricescu, Silviu and Smith, Jonathan M and Knight Jr., Thomas F and Pierce, Benjamin C and DeHon, André},
    pages = {8:1–8:8},
    series = {HASP '14},
    publisher = {ACM},
    url = {http://doi.acm.org/10.1145/2611765.2611773},
    address = {New York, NY, USA},
    isbn = {978-1-4503-2777-0},
    doi = {10.1145/2611765.2611773},
    keywords = {control-flow integrity, memory safety, metadata, security, tagged architecture, taint tracking}
}

@INPROCEEDINGS{NWF20:Cornucopia,  author={Wesley Filardo, Nathaniel and Gutstein, Brett F. and Woodruff, Jonathan and Ainsworth, Sam and Paul-Trifu, Lucian and Davis, Brooks and Xia, Hongyan and Tomasz Napierala, Edward and Richardson, Alexander and Baldwin, John and Chisnall, David and Clarke, Jessica and Gudka, Khilan and Joannou, Alexandre and Theodore Markettos, A. and Mazzinghi, Alfredo and Norton, Robert M. and Roe, Michael and Sewell, Peter and Son, Stacey and Jones, Timothy M. and Moore, Simon W. and Neumann, Peter G. and Watson, Robert N. M.},  booktitle={2020 IEEE Symposium on Security and Privacy (SP)},   title={Cornucopia: Temporal Safety for CHERI Heaps},   year={2020},  volume={},  number={},  pages={608-625},  doi={10.1109/SP40000.2020.00098}}

@article{Skorstengaard19:stktokens,
  title={{StkTokens: Enforcing Well-bracketed Control Flow and Stack Encapsulation using Linear Capabilities}},
  author={Skorstengaard, Lau and Devriese, Dominique and Birkedal, Lars},
  journal={Proceedings of the ACM on Programming Languages},
  volume={3},
  number={POPL},
  pages={1--28},
  year={2019},
  publisher={ACM New York, NY, USA}
}

@techreport{Anderson72:PlanningStudy,
  author = {Anderson, James P.},
  title = {Computer security technology planning study},
  type = {Technical Report},
  number = {ESD-TR-73-51},
  institution = {U.S. Air Force Electronic Systems Division},
  month = oct,
  year = {1972},
  url = {http://csrc.nist.gov/publications/history/ande72.pdf},
}

                  
@inproceedings{Goguen82:SecurityPolicies,
  added-at = {2016-06-15T00:00:00.000+0200},
  author = {Goguen, Joseph A. and Meseguer, José},
  booktitle = {IEEE Symposium on Security and Privacy},
  ee = {http://doi.ieeecomputersociety.org/10.1109/SP.1982.10014},
  isbn = {0-8186-0410-7},
  keywords = {dblp},
  pages = {11-20},
  publisher = {IEEE Computer Society},
  title = {Security Policies and Security Models.},
  url = {http://dblp.uni-trier.de/db/conf/sp/sp1982.html#GoguenM82a},
  year = 1982
}

﻿@phdthesis{Lundblad13IRM:,
   author = {Lundblad, Andreas},
   institution = {KTH, Theoretical Computer Science, TCS},
   note = {QC 20130220},
   pages = {viii, 20},
   school = {KTH, Theoretical Computer Science, TCS},
   title = {Inlined Reference Monitors : Certification,Concurrency and Tree Based Monitoring},
   series = {Trita-CSC-A},
   ISSN = {1653-5723},
   number = {2013:01},
   keywords = {Runtime monitoring, policy enforcement, tree automata, monitor inlining, certification, concurrency},
   abstract = {Reference monitor inlining is a technique for enforcing security policies by injecting security checks into the untrusted software in a style similar to aspect-oriented programming. The intention is that the injected code enforces compliance with the policy (security), without adding behavior (conservativity) or affecting existing policy compliant behavior (transparency). This thesis consists of four papers which covers a range of topics including formalization of monitor inlining correctness properties, certification of inlined monitors, limitations in multithreaded settings and extensions using data-flow monitoring. The first paper addresses the problem of having a potentially complex program rewriter as part of the trusted computing base. By means of proof-carrying code we show how the inliner can be replaced by a relatively simple proof-checker. This technique also enables the use of monitor inlining for quality assurance at development time, while minimizing the need for post-shipping code rewrites. The second paper focuses on the issues associated with monitor inlining in a concurrent setting. Specifically, it discusses the problem of maintaining transparency when introducing locks for synchronizing monitor state reads and updates. Due to Java's relaxed memory model, it turns out to be impossible for a monitor to be entirely transparent without sacrificing the security property. To accommodate for this, the paper proposes a set of new correctness properties shown to be realistic and realizable. The third paper also focuses on problems due to concurrency and identifies a class of race-free policies that precisely characterizes the set of inlineable policies. This is done by showing that inlining of a policy outside this class is either not secure or not transparent, and by exhibiting a concrete algorithm for inlining of policies inside the class which is secure, conservative, and transparent. The paper also discusses how certification in the style of proof-carrying code could be supported in multithreaded Java programs. The fourth paper formalizes a new type of data centric runtime monitoring which combines monitor inlining with taint tracking. As opposed to ordinary techniques which focus on monitoring linear flows of events, the approach presented here relies on tree shaped traces. The paper describes how the approach can be efficiently implemented and presents a denotational semantics for a simple ``while'' language illustrating how the theoretical foundations is to be used in a practical setting. Each paper is concluded by a practical evaluation of the theoretical results, based on a prototype implementation and case studies on real-world applications and policies. },
   ISBN = {978-91-7501-654-2},
   year = {2013}
}

@article{Bessey10:Coverity,
author = {Bessey, Al and Block, Ken and Chelf, Ben and Chou, Andy and Fulton, Bryan and Hallem, Seth and Henri-Gros, Charles and Kamsky, Asya and McPeak, Scott and Engler, Dawson},
title = {A Few Billion Lines of Code Later: Using Static Analysis to Find Bugs in the Real World},
year = {2010},
issue_date = {February 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {53},
number = {2},
issn = {0001-0782},
url = {https://doi.org/10.1145/1646353.1646374},
doi = {10.1145/1646353.1646374},
abstract = {How Coverity built a bug-finding tool, and a business, around the unlimited supply of bugs in software systems.},
journal = {Commun. ACM},
month = {feb},
pages = {66–75},
numpages = {10}
}

@article{Leroy09:CompCert,
author = {Leroy, Xavier},
title = {Formal Verification of a Realistic Compiler},
year = {2009},
issue_date = {July 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/1538788.1538814},
doi = {10.1145/1538788.1538814},
abstract = {This paper reports on the development and formal verification (proof of semantic preservation) of CompCert, a compiler from Clight (a large subset of the C programming language) to PowerPC assembly code, using the Coq proof assistant both for programming the compiler and for proving its correctness. Such a verified compiler is useful in the context of critical software and its formal verification: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
journal = {Commun. ACM},
month = {jul},
pages = {107–115},
numpages = {9}
}

% nice to see this no longer requires an extra package to play nicely with acm bib
% https://www.acm.org/publications/authors/reference-formatting 
% https://www.acm.org/publications/authors/bibtex-formatting 
%Example from above 
% online{Thornburg01,
% author ={Harry Thornburg},
% year = {2001},
% title ={Introduction to Bayesian Statistics},
% url ={http://ccrma.stanford.edu/~jos/bayes/bayes.html},
% month ={mar},
% lastaccessed ={March 2, 2005},
%}

@online{apache97:main-site,
author ={The Apache Software Foundation},
year = {1997},
title ={Apache HTTP Server Project},
url ={https://httpd.apache.org/},
lastaccessed ={April 11, 2023},
}

% oldest comment appears to date from 2015, but I can't find an exact publication date
 @online{Munoz:PoweredbyC,
author ={Daniel Munoz},
year = {}, 
title ={After All These Years, the World is Still Powered by C Programming},
url ={https://www.toptal.com/c/after-all-these-years-the-world-is-still-powered-by-c-programming},
lastaccessed ={April 11, 2023},
}

 @online{stackoverflow22:dev-survey,
author ={{Stack Overflow}},
year = {2022},
title ={2022 Stack Overflow Annual Developer Survey},
url ={https://survey.stackoverflow.co/2022/},
lastaccessed ={April 11, 2023},
}

@InProceedings{Askarov08:TINILeaks,
author="Askarov, Aslan
and Hunt, Sebastian
and Sabelfeld, Andrei
and Sands, David",
editor="Jajodia, Sushil
and Lopez, Javier",
title="Termination-Insensitive Noninterference Leaks More Than Just a Bit",
booktitle="Computer Security - ESORICS 2008",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="333--348",
abstract="Current tools for analysing information flow in programs build upon ideas going back to Denning's work from the 70's. These systems enforce an imperfect notion of information flow which has become known as termination-insensitive noninterference. Under this version of noninterference, information leaks are permitted if they are transmitted purely by the program's termination behaviour (i.e., whether it terminates or not). This imperfection is the price to pay for having a security condition which is relatively liberal (e.g. allowing while-loops whose termination may depend on the value of a secret) and easy to check. But what is the price exactly? We argue that, in the presence of output, the price is higher than the ``one bit'' often claimed informally in the literature, and effectively such programs can leak all of their secrets. In this paper we develop a definition of termination-insensitive noninterference suitable for reasoning about programs with outputs. We show that the definition generalises ``batch-job'' style definitions from the literature and that it is indeed satisfied by a Denning-style program analysis with output. Although more than a bit of information can be leaked by programs satisfying this condition, we show that the best an attacker can do is a brute-force attack, which means that the attacker cannot reliably (in a technical sense) learn the secret in polynomial time in the size of the secret. If we further assume that secrets are uniformly distributed, we show that the advantage the attacker gains when guessing the secret after observing a polynomial amount of output is negligible in the size of the secret.",
isbn="978-3-540-88313-5"
}

@article{Memarian16:DeFacto,
author = {Memarian, Kayvan and Matthiesen, Justus and Lingard, James and Nienhuis, Kyndylan and Chisnall, David and Watson, Robert N. M. and Sewell, Peter},
title = {Into the Depths of C: Elaborating the de Facto Standards},
year = {2016},
issue_date = {June 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2980983.2908081},
doi = {10.1145/2980983.2908081},
abstract = {C remains central to our computing infrastructure. It is notionally defined by ISO standards, but in reality the properties of C assumed by systems code and those implemented by compilers have diverged, both from the ISO standards and from each other, and none of these are clearly understood. We make two contributions to help improve this error-prone situation. First, we describe an in-depth analysis of the design space for the semantics of pointers and memory in C as it is used in practice. We articulate many specific questions, build a suite of semantic test cases, gather experimental data from multiple implementations, and survey what C experts believe about the de facto standards. We identify questions where there is a consensus (either following ISO or differing) and where there are conflicts. We apply all this to an experimental C implemented above capability hardware. Second, we describe a formal model, Cerberus, for large parts of C. Cerberus is parameterised on its memory model; it is linkable either with a candidate de facto memory object model, under construction, or with an operational C11 concurrency model; it is defined by elaboration to a much simpler Core language for accessibility, and it is executable as a test oracle on small examples. This should provide a solid basis for discussion of what mainstream C is now: what programmers and analysis tools can assume and what compilers aim to implement. Ultimately we hope it will be a step towards clear, consistent, and accepted semantics for the various use-cases of C.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {1–15},
numpages = {15},
keywords = {C}
}

@article{Memarian19:ExploringCSemantics,
author = {Memarian, Kayvan and Gomes, Victor B. F. and Davis, Brooks and Kell, Stephen and Richardson, Alexander and Watson, Robert N. M. and Sewell, Peter},
title = {Exploring C Semantics and Pointer Provenance},
year = 2019,
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = 3,
number = {POPL},
url = {https://doi.org/10.1145/3290380},
doi = {10.1145/3290380},
abstract = {The semantics of pointers and memory objects in C has been a vexed question for many years. C values cannot be treated as either purely abstract or purely concrete entities: the language exposes their representations, but compiler optimisations rely on analyses that reason about provenance and initialisation status, not just runtime representations. The ISO WG14 standard leaves much of this unclear, and in some respects differs with de facto standard usage --- which itself is difficult to investigate. In this paper we explore the possible source-language semantics for memory objects and pointers, in ISO C and in C as it is used and implemented in practice, focussing especially on pointer provenance. We aim to, as far as possible, reconcile the ISO C standard, mainstream compiler behaviour, and the semantics relied on by the corpus of existing C code. We present two coherent proposals, tracking provenance via integers and not; both address many design questions. We highlight some pros and cons and open questions, and illustrate the discussion with a library of test cases. We make our semantics executable as a test oracle, integrating it with the Cerberus semantics for much of the rest of C, which we have made substantially more complete and robust, and equipped with a web-interface GUI. This allows us to experimentally assess our proposals on those test cases. To assess their viability with respect to larger bodies of C code, we analyse the changes required and the resulting behaviour for a port of FreeBSD to CHERI, a research architecture supporting hardware capabilities, which (roughly speaking) traps on the memory safety violations which our proposals deem undefined behaviour. We also develop a new runtime instrumentation tool to detect possible provenance violations in normal C code, and apply it to some of the SPEC benchmarks. We compare our proposal with a source-language variant of the twin-allocation LLVM semantics proposal of Lee et al. Finally, we describe ongoing interactions with WG14, exploring how our proposals could be incorporated into the ISO standard.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = 67,
numpages = 32,
keywords = {C}
}


@misc{arm-mte,
key="arm",
title= "Armv8.5-A Memory Tagging Extension White Paper",
url="https://developer.arm.com/-/media/Arm\%20Developer\%20Community/PDF/Arm_Memory_Tagging_Extension_Whitepaper.pdf"                  
}
                  
@INPROCEEDINGS {Gollapudi+23,
author = {R. Gollapudi and G. Yuksek and D. Demicco and M. Cole and G. N. Kothari and R. H. Kulkarni and X. Zhang and K. Ghose and A. Prakash and Z. Umrigar},
booktitle = {2023 IEEE Symposium on Security and Privacy (SP)},
title = {Control Flow and Pointer Integrity Enforcement in a Secure Tagged Architecture},
year = {2023},
volume = {},
issn = {},
pages = {2974-2989},
abstract = {Control flow attacks exploit software vulnerabilities to divert the flow of control into unintended paths to ultimately execute attack code. This paper explores the use of instruction and data tagging as a general means of thwarting such control flow attacks, including attacks that rely on violating pointer integrity. Using specific types of narrow-width data tags along with narrow-width instruction tags embedded within the binary facilitates the security policies required to protect against such attacks, leading to a practically viable solution. Co-locating instruction tags close to their corresponding instructions within cache lines eliminates the need for separate mechanisms for instruction tag accesses. Information gleaned from the analysis phase of a compiler is augmented and used to generate the instruction and data tags. A full-stack implementation that consists of a modified LLVM compiler, modified Linux OS support for tags and a FPGA-implemented CPU hardware prototype for enforcing CFI, data pointer and code pointer integrity is demonstrated. With a modest hardware enhancement, the execution time of benchmark applications on the prototype system is shown to be limited to low, single-digit percentages of a baseline system without tagging.},
keywords = {control-flow-integrity,-hardware-security,-pointer-integrity,-security-architectures,-security-and-privacy-policies},
doi = {10.1109/SP46215.2023.00102},
url = {https://doi.ieeecomputersociety.org/10.1109/SP46215.2023.00102},
publisher = {IEEE Computer Society},
address = {Los Alamitos, CA, USA},
month = {may}
}



@inproceedings{Dhawan+15,
 author = {Dhawan, Udit and Hritcu, Catalin and Rubin, Raphael and Vasilakis, Nikos and Chiricescu, Silviu and Smith, Jonathan M. and Knight,Jr., Thomas F. and Pierce, Benjamin C. and DeHon, Andre},
 title = {Architectural Support for Software-Defined Metadata Processing},
 booktitle = {Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems},
 series = {ASPLOS '15},
 year = {2015},
 isbn = {978-1-4503-2835-7},
 location = {Istanbul, Turkey},
 pages = {487--502},
 numpages = {16},
 url = {http://doi.acm.org/10.1145/2694344.2694383},
 doi = {10.1145/2694344.2694383},
 acmid = {2694383},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {CFI, memory safety, metadata, security, tagged architecture, taint tracking},
}
@article{Azevedo+16,
  author    = {Arthur {Azevedo de Amorim} and
               Nathan Collins and
               Andr{\'{e}} DeHon and
               Delphine Demange and
               Catalin Hritcu and
               David Pichardie and
               Benjamin C. Pierce and
               Randy Pollack and
               Andrew Tolmach},
  title     = {A verified information-flow architecture},
  journal   = {Journal of Computer Security},
  volume    = {24},
  number    = {6},
  pages     = {689--734},
  year      = {2016},
  url       = {http://dx.doi.org/10.3233/JCS-15784},
  doi       = {10.3233/JCS-15784},
  timestamp = {Thu, 08 Dec 2016 18:00:27 +0100},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/jcs/AmorimCDDHPPPT16},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@inproceedings{Azevedo+15,
  title = {Micro-Policies: Formally Verified, Tag-Based Security Monitors},
  author = {Arthur {Azevedo de Amorim} and Maxime Dénès and Nick Giannarakis and Catalin Hritcu and Benjamin C. Pierce and Antal Spector-Zabusky and Andrew P. Tolmach},
  year = {2015},
  doi = {10.1109/SP.2015.55},
  url = {http://dx.doi.org/10.1109/SP.2015.55},
  researchr = {https://researchr.org/publication/AmorimDGHPST15},
  cites = {0},
  citedby = {0},
  pages = {813-830},
  booktitle = {2015 IEEE Symposium on Security and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015},
  publisher = {IEEE Computer Society},
  isbn = {978-1-4673-6949-7},
}
                  
@inproceedings{Dhawan+14,
    title = {{PUMP: A Programmable Unit for Metadata Processing}},
    year = {2014},
    booktitle = {Proceedings of the Third Workshop on Hardware and Architectural Support for Security and Privacy},
    author = {Dhawan, Udit and Vasilakis, Nikos and Rubin, Raphael and Chiricescu, Silviu and Smith, Jonathan M and Knight Jr., Thomas F and Pierce, Benjamin C and DeHon, André},
    pages = {8:1–8:8},
    series = {HASP '14},
    publisher = {ACM},
    url = {http://doi.acm.org/10.1145/2611765.2611773},
    address = {New York, NY, USA},
    isbn = {978-1-4503-2777-0},
    doi = {10.1145/2611765.2611773},
    keywords = {control-flow integrity, memory safety, metadata, security, tagged architecture, taint tracking}
}

@misc{Dover20,
author="{Dover Microsystems}",
title="Coreguard Overview",
url="https://www.dovermicrosystems.com/solutions/coreguard/"
}

@InProceedings{Dover16,
  author =	 {
  Andr\'{e} DeHon and
    Eli Boling and
    Rishiyur Nikhil and
    Darius Rad and
    Julie Schwarz and
    Niraj Sharma and
    Joseph Stoy and
    Greg Sullivan and
    Andrew Sutherland
  },
  title =	 {{DOVER}: {A} {M}etadata-{E}xtended {RISC-V}},
  month =	 jan,
  year =	 2016,
  url = {http://riscv.org/wp-content/uploads/2016/01/Wed1430-dover_riscv_jan2016_v3.pdf},
  booktitle =	 {RISC-V Workshop},
  note = {Accompanying talk at \url{http://youtu.be/r5dIS1kDars}}
}


@inproceedings{RoesslerD18,
  author    = {Nick Roessler and
               Andr{\'{e}} DeHon},
  title     = {Protecting the Stack with Metadata Policies and Tagged Hardware},
  booktitle = {2018 {IEEE} Symposium on Security and Privacy, {SP} 2018, Proceedings,
               21-23 May 2018, San Francisco, California, {USA}},
  pages     = {478--495},
  year      = {2018},
  url       = {https://doi.org/10.1109/SP.2018.00066},
  doi       = {10.1109/SP.2018.00066},
  timestamp = {Wed, 16 Oct 2019 14:14:51 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/sp/RoesslerD18},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

