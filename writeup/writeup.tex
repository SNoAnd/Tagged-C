\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\setcopyright{none}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{stmaryrd}
\usepackage{subcaption}
\usepackage{cleveref}
\usepackage{tikz}

\usetikzlibrary{automata,positioning}

\title{Policies}
\author{Sean Anderson}
\affiliation{
  \department{Computer Science}
  \institution{Portland State University}
}

\begin{document}

\maketitle

\input{macros.tex}
\input{semantics.tex}

\section{Formal Semantics}

\begin{figure}
  \begin{subfigure}[t]{0.3\textwidth}
    \[\begin{aligned}
    \odot ::= & ~ ! \\
    | & \sim \\
    | & ~ \text{-} \\
    | & ~ \mathit{abs} \\ \\
    \oplus ::= & + \\
    | & - \\
    | & \times \\ \\
    \stmt ::= & \sskip \\
    | & \sdo{\expr} \\
    | & \sseq{\stmt_1}{\stmt_2} \\
    | & \sifthenelse{\expr}{\stmt_1}{\stmt_2}{L} \\
    | & \swhile{\expr}{\stmt}{L} \\
    | & \sdowhile{\expr}{\stmt}{L} \\
    | & \sfor{\stmt_1}{\expr}{\stmt_2}{\stmt_3} \\
    | & \sbreak \\
    | & \scontinue \\
    | & \sreturn \\
    | & \sswitch{\expr}{\overline{(L,\stmt)}} \\
    | & \slabel{L}{\stmt} \\
    | & \sgoto{L} \\    
    \end{aligned}\]
  \end{subfigure}
  \begin{subfigure}[t]{0.69\textwidth}
    \[\begin{aligned}
    \expr ::= & \val{v}{\vt} & \textnormal{Value} \\
    | & x & \textnormal{Variable} \\
    | & \expr [id] & \textnormal{Index} \\
    | & \valof{\expr} & \textnormal{R-value of Address} \\
    | & \deref{\expr} & \textnormal{Dereference} \\
    | & \addrof{\expr} & \textnormal{Address Of} \\
    | & \unop{\odot}{\expr} & \textnormal{Unary Operator} \\
    | & \binop{\oplus}{\expr_1}{\expr_2} & \textnormal{Binary Operator} \\
    | & \cast{\expr}{ty} & \textnormal{Cast} \\
    | & \binop{\land}{\expr_1}{\expr_2} & \textnormal{Sequential And} \\
    | & \binop{\lor}{\expr_1}{\expr_2} & \textnormal{Sequential Or} \\
    | & \condition{\expr_1}{\expr_2}{\expr_3} & \textnormal{Conditional} \\
    | & \sizeof{ty} & \textnormal{Size of Type} \\
    | & \alignof{ty} & \textnormal{Alignment of Type} \\
    | & \assign{\expr_1}{\expr_2} & \textnormal{Assignment} \\
    | & \assignop{\oplus}{\expr_1}{\expr_2} & \textnormal{Operator Assignment} \\
    | & \postincr{\oplus}{\expr} & \textnormal{Post-Increment/Decrement} \\
    | & \comma{\expr_1}{\expr_2} & \textnormal{Expression Sequence} \\
    | & \call{\expr_f}{\overline{\expr}_{args}} & \textnormal{Function Call} \\
    | & \loc{l}{\lt} & \textnormal{Memory Location} \\
    | & \paren{\expr}{ty} & \textnormal{Parenthetical Cast} \\
    \end{aligned}\]
  \end{subfigure}
  \caption{Syntax}
  \label{fig:syntax}
\end{figure}

\begin{figure}
  %% Bookkeeping rules %%
  \lredestep
  \rredestep
  \callredestep
  \stuckestep
  \caption{Bookkeeping rules}
\end{figure}

\begin{figure}
  %% Sequencing rules %%
  \dostepa
  \dostepb
  \seqstep
  \seqskipstep
  \seqcontinuestep
  \seqbreakstep
  \caption{Sequencing rules}
\end{figure}

\begin{figure}
  %% If-then-else %%
  \ifstepa
  \ifstepb

  \caption{Conditionals}
\end{figure}

\begin{figure}
  %% While %%
  \whilestep
  \whiletruestep
  \whilefalsestep
  \whileskipcontinuestep
  \whilebreakstep

  %% Do-while %%
  \dowhilestep
  \dowhileskiporcontinuestep
  \dowhilefalsestep
  \dowhiletruestep
  \dowhilebreakstep

  %% For %%
  \forinitstep
  \forstep
  \forfalsestep
  \fortruestep
  \forskiporcontinuestep
  \forbreakstep
  \forskippoststep
  
  \caption{Loops}
\end{figure}

\begin{figure}
  %% Expression rules %%
  \allocstep
  \valofstep
  \assignopstep
  \postincstep
  \assignstep
  \varstep
  \unopstep
  \binopstep
  
  \caption{Expression rules}
\end{figure}

Tagged C uses a small-step reduction semantics, given in full in \cref{fig:semantics}.

Values are ranged over by \(v\), variable identifiers by \(x\), and function identifiers by \(f\).
Tags use a number of metavariables: \(t\) ranges over all tags, while we will use
\(\vt\) to refer to the tags associated with values, \(\pt\) for tags on pointer values
and memory-location expressions, \(\lt\) for tags associated with memory locations themselves,
\(\nt\) for ``name tags'' automatically derived from identifiers, and \(\PCT\) for the
global ``program counter tag'' or PC Tag.
An {\it atom} is a pair of a value and a tag, \(\val{v}{\vt}\); the @ symbol should be read
as a pair in general, and is used when the second object in the pair is a tag.
Expressions are ranged over by \(\expr\) (Figure \ref{fig:syntax}),
statements by \(\stmt\), and continuations by \(\cont\).
The continuations are defined inductively:

\[\begin{split}
\cont ::= & \kemp \\
| & \kdo{\cont} \\
| & \kseq{\stmt}{\cont} \\
| & \kif{\stmt_1}{\stmt_2}{L}{\cont} \\
| & \kwhiletest{\expr}{\stmt}{L}{\cont} \\
| & \kwhileloop{\expr}{\stmt}{L}{\cont} \\
| & \kdowhiletest{\expr}{\stmt}{L}{\cont} \\
| & \kdowhileloop{\expr}{\stmt}{L}{\cont} \\
| & \kfor{\stmt}{\cont} \\
| & \kforpost{\stmt}{\cont} \\
\end{split}\]

Many continuations contain a context \(\mathit{ctx}\), which is a function from expressions
to expressions.

Global environments, ranged over by \(\genv\), map identifiers to either function
or global variable definitions (including the variable's location in memory. Local environments,
ranged over by \(\lenv\), map identifiers to atoms.
Memories \(\mem\) map integers to
triples: a value, a ``value tag'' \(\vt\), and a list of ``location tags'' \(\lts\).

A memory is an array of bytes, and a load or store will access some number of bytes. I write
\(\mem[l]_s = v@\vt @\lts\) to denote loading \(s\) bytes,
starting at location \(l\), and interpreting them as a value \(v\), a value tag \(\vt\), and a list of
\(s\) location tags. Likewise, \(\mem[l \mapsto v@\vt @ \lts]_s\)
denotes storing that many bytes. \(\vt\) is tied to a full value, which may consist of
multiple bytes, while each tag in \(\lts\) is tied to an individual byte.
When writing multiple contiguous values, I will write a range of locations. So
in the case of an array of 10 integers, \(s\) would be 4, and
\(\mem[l \dots l+10 \mapsto v@\vt @ \lts]_4\) would write \(v@\vt\) to ten words starting at \(l\),
with the four bytes of each word tagged with \(\lts\)'s four tags.
This guarantees that even misaligned loads and stores always have a valid location tag to check
(possibly multiple, mismatched location tags, in which case the policy can failstop if needed.)

State can be of several kinds, denoted by their script prefix: a {\em general state} \(\mathcal{S}(\dots)\),
an {\em expression state} \(\mathcal{E}(\dots)\), a {\em call state} \(\mathcal{C}(\dots)\), or a
{\em return state} \(\mathcal{R}(\dots)\). Finally, the special state {\em failstop} (\(\mathcal{F}(\dots)\))
represents a tag failure, and carries an arbitrary list of tags

\[\begin{aligned}
S ::= & \sstate{\PCT}{\mem}{\genv}{\lenv}{\stmt}{\cont} \\
| & \estate{\PCT}{\mem}{\genv}{\lenv}{\expr}{\type}{\cont} \\
| & \cstate{\PCT}{\mem}{\genv}{\lenv}{f}{\overline{\val{v}{\vt}}}{\cont} \\
| & \rstate{\PCT}{\mem}{\genv}{\lenv}{\val{v}{\vt}}{\cont} \\
| & \fstate{\overline{t}} \\
\end{aligned}\]

\paragraph*{Control Points with Side-effects and Optional Arguments}

Most control points can be mapped cleanly onto one or more instructions in a compiled
program. For example, the \(\mathbf{BinopT}\) control point takes as input the tags on the parameters
of an operation (as well as the PC tag) and yields a tag for the result, so the target-level
rule, which does the same, can be identical. Other control points may correspond to multiple
target-level instructions, requiring a more complicated mapping. I will not call these out
unless they are particularly noteworthy. From a performance standpoint, the most problematic
situation is when a Tagged-C control point requires a tag from a location that is not read under
a normal compilation scheme, which must update tags in locations that are not written, or in which
the source construct does not have corresponding instructions in the target.

These situations require the compiler to add instructions to manipulate tags.
If the tag rules that instantiate those control points do not make use of them, these instructions
are needless overhead. In these cases, the control points will take optional parameters or return
optional results, and I will explain how the rule should be implemented in the target if the
options are used. If compiling with a known policy that does not make use of the options, it will
be sound to eliminate the extra instructions. If {\it all} of the control point's outputs are
optional and unused, the control point need not be compiled at all. In this document, optional inputs
and outputs will be marked with \(\optional{boxes}\).

\paragraph*{Name Tags}

When we want to define a per-program policy, we need to be able to attach tags to the program's
functions, globals, and so on. We do this by automatically embedding their identifiers in tags,
which are available to all policies. These are called {\em name tags} and are ranged over by
\(\nt\). The complete list of such tags is as follows:
\begin{itemize}
\item Function identifiers
\item Function arguments, written {\tt f.x}
\item Global variables
\end{itemize}

\section{Memory safety basics}

Memory safety policies operate on under a ``lock and key'' model, in which objects in memory
are tagged with a unique identifier (the ``lock'') and may only be accessed via a pointer tagged
with the same identifier (the ``key.'') For a simple example, consider the following code:
%
\vspace{\abovedisplayskip}
\begin{verbatim}
void main() {
  int a[10];
  int b[10];
  a[10] = 42;    
}
\end{verbatim}
\vspace{\belowdisplayskip}
%
In a typical stack allocator---such as the one used by my interpreter---{\tt a} and {\tt b} will
be allocated next to one another on the stack, like this:

\includegraphics[width=.5\textwidth]{example.png}

To prevent the expression {\tt a[10] = 42} from overwriting {\tt b[0]}, we give {\tt a} and {\tt b}
unique {\it color tags} when they are allocated. In this case, we'll tag {\tt a} with \(\mathit{dyn ~ 0}\),
indicating that it's the first dynamically allocated object, and {\tt b} with \(\mathit{dyn ~ 1}\).
Then, when we evaluate the left-hand expression {\tt a} into its memory location \(l\), we tag
\(l\) with \(\mathit{dyn ~ 0}\). When we take the offset \(l + 10\), we keep that tag. And when we
perform the assignment, we check that the location tag at \(l\) matches. It doesn't, so we failstop.

The same principle applies for this code:

\vspace{\abovedisplayskip}
\begin{verbatim}
void main() {
  int* a = malloc(10 * sizeof(int));
  int* b = malloc(10 * sizeof(int));
  *(a + (b - a)) = 42;
}
\end{verbatim}
\vspace{\belowdisplayskip}

In this case, {\tt a} and {\tt b} could be allocated anywhere in the heap, and in Tagged C
the expression {\tt *(a + (b - a)) = 42} will always write to {\tt *b}. While this might be intentional
on the part of the programmer, it is also undefined behavior in the C standard, and in some
(but not all; see below) formal C semantics. Likewise, if {\tt a} and {\tt b} are next to each other
or in some other predictable arrangement, arithmetic like our first example can apply.
The memory safety policy works just the same in this scenario, with the tags being attached
by the call to malloc, once again using the \(\mathit{dyn}\) label in a global count of allocated blocks.
Meanwhile, values that are not derived from valid pointers at all are tagged \(X\), and can never
be read or written through, to avoid pointer forging, like this:

\vspace{\abovedisplayskip}
\begin{verbatim}
void main() {
  int* a = malloc(10 * sizeof(int));
  // I happen to know that a will be at address 1000
  *1000 = 42;
}
\end{verbatim}
\vspace{\belowdisplayskip}

Both stack and heap allocations use the \(\mathit{dyn}\) label and have a color that can grow arbitrarily
high. This is because over a program's execution, it might allocate an unbounded number of heap- or
stack-allocated objects, and each needs a unique identifier. Existing work has shown that in practice,
tag colors can be ``garbage collected'' and reused, but in Tagged C we assume them to be infinite and unique.

Lastly, we have global variables. While ``global safety'' is not as prominent a topic as heap or
stack safety, overrunning a global buffer is still a problem. It is also easy to forge a pointer to a global,
and when this happens it can undermine assumptions about the behavior of linked libraries whose globals
are not exported. Globals do not need dynamic colors, but can use their identifiers as tags, of the form
\(\mathit{glob} ~ id\).

\section{Memory Safety: PVI and PNVI}

Our policies aim to enforce two memory models in particular: {\it PVI} (provenanace via integer) and
{\it PNVI} (provenance not via integer) from Memarian et al. \cite{???}. They propose PVI and PNVI
as memory models that support common idioms that are undefined in the C standard, but are still restrictive
enough as to support useful alias analysis for optimization. This application is orthogonal to
security, and violations of either memory model are treated as undefined behavior, just as in the
C standard. Our goal is to turn that UB into failstop behavior, so that undefined programs cannot accidentally
undermine their own security.

Both memory models represent pointers as integers, just as Tagged C does, with additional provenance
associated with each object. An integer cast to a pointer in PVI retains this provenance, enabling
integer operations to be performed on it prior to it being cast back to a pointer.
In PNVI, by contrast, an integer cast to a pointer gains the provenance of the object it points
to when the cast occurs. While PNVI supports a wider range of programs, it is inconsistent with important
assumptions of the C memory model, in ways that may have serious security consequences.
The difference between PVI and PNVI is illustrated in Figure \ref{fig:PVI-PNVI}.

\begin{figure}
  \includegraphics[width=.6\textwidth]{PVIvsPNVI.png}
  \caption{Integer-pointer casts in PVI and PNVI}
  \label{fig:PVI-PNVI}
\end{figure}

We will aim to prove that for any program, if it is run in both the PVI semantics
and in Tagged C with our PVI policy, it either produces identical output, or it is both
undefined in the PVI semantics and failstops in Tagged C. Likewise for PNVI, except that
some UB in PNVI is non-deterministic, and we only require that it failstop in an execution
that would {\it reach} the UB.

\subsection{PVI Definitions}

Here we give the relevant tag rules for the PVI policy, and describe the control points that
they attach to. We will, for each rule, first give the control point(s) that use it, along
with a brief explanation of what the surrounding semantics rules do, and then give the rule.
For these policies, all control points appear in expression reduction steps.
The machine state consists of the PC tag \(\PCT\), a memory \(\mem\),
the global environment \(\genv\), and a local environment \(\lenv\). These are contextual semantics,
so each expression is situated in some context \(\mathit{ctx}\).

The core of the PVI policy is the {\it provenance color}, represented
by a natural number.
%
\begin{align*}
  T ::= & \mathit{glob} ~ id & id \in \mathit{ident} \\
  & \mathit{dyn} ~ \tagcolor & \tagcolor \in \mathbb{N} \\
\end{align*}

\paragraph*{Color generation}

New colors are generated when objects are allocated. When exactly that occurs
depends on where the object lives. Global variables are a special case: they are
allocated during program initialization, before execution begins. As such they
do not have a control point per se, but a rule that functions similarly, while
being more expressive.

%All of our allocation control points differ from the normal ones in that they
%pass a type as a parameter and recieve a list of tags that they apply to
%a memory region of the size of that type.

Given a list \(xs\) of variable identifiers \(id\) and types
\(ty\), a program's initial memory is defined by iteratively allocating each one
in memory and updating the global environment with its base address, bound, type,
and a static identity tag. Let \(|ty|\) be a function from types to their sizes
in bytes. The memory is initialized \(\vundef@\vt@\overline{\lt}\)
for some \(\vt\) and \(\overline{\lt}\), unless given an initializer.
Let \(\mem_0\) and \(\genv_0\) be the initial (empty) memory and environment.
The parameter \(b\) marks the start of the global region.

%Since we don't need to initialize tags in memory dynamically, our rule for
%selecting these tags can cover the entire initialization of the memory with arbitrary
%granularity. We represent this as a list of tags of length \(|ty|\).

\[\mathit{globals} ~ xs ~ b =
\begin{cases}
  (\mem_0, \genv_0) & \textnormal{if } xs = \varepsilon \\
  (\mem[p \dots p+|ty| \mapsto \vundef@\vt@\overline{\lt}]_{|ty|}, & \textnormal{if } xs = (id,ty)::xs' \\
  ~ \genv[id \mapsto (\mathit{p, p+|ty|,ty,\pt})]) & \textnormal{and } \trule{\pt,\vt,\overline{\lt}}{\globalt{id}{|ty|}} \\
  & \textnormal{where } (\mem,\genv) = \mathit{globals} ~ xs' ~ (b + |ty|) \\
\end{cases}\]

\[\begin{aligned}
\truledef{\globalt{id}{s}}
\settag{\pt}{\mathit{glob ~ id}}
\settag{\vt}{X}
\settag{\overline{\lt}}{\left[\mathit{glob} ~ id \mid 0 \leq i < s\right]}
\end{aligned}\]

Stack-allocated locals are allocated at the start of a function call. Like a global environment,
a local environment maps indentifiers to base, bound, type, and tag. The rule is almost identical
to allocation of globals, except that the stack allocator, \(\mathit{stack\_alloc}\) will be more
complex in order to support deallocation (in practice, it uses a normal stack structure and allocates
and deallocates by increasing and decreasing a ``stack pointer''.)

Since allocations occur at runtime, the value and location tags that initialize the allocated memory
are optional. They would be realized by initializing the entire allocated object at allocation-time,
which adds linear overhead if the object was not otherwise being initialized.

\[\mathit{locals} ~ xs ~ \mem ~ \lenv =
\begin{cases}
  (\mem, \lenv) & \textnormal{if } xs = \varepsilon \\
  \mathit{locals} ~ xs' ~ \mem'' ~ \lenv' & \textnormal{if } xs = (id,ty)::xs' \\
  & \textnormal{where } (\mem',p) \leftarrow \mathit{stack\_alloc} ~ |ty| ~ \mem, \\
  & \mem'' = \mem'[p \dots p+|ty| \mapsto \vundef@\vt@\overline{\lt}]_{|ty|}, \\
  & \trule{\pt,\vt,\overline{\lt}}{\globalt{id}{|ty|}}, \\
  & \textnormal{and } \lenv' = \lenv[id \mapsto (\mathit{p, p+|ty|,ty,\pt})]) \\
\end{cases}\]
              
In the tag rule, the PC Tag carries the ``next'' color to be assigned. We mark both the pointer tag
(which is stored in the local environment) with that color, along with the location tags on the
allocated memory. Then we increment the PC Tag to give the next allocation a unique color.

\[\begin{aligned}
\truledef{\localt{\PCT}{id}{s}}
\settag{\pt}{dyn ~ \PCT}
\settagopt{\vt}{X}
\settagopt{\overline{\lt}}{\left[dyn ~ \PCT \mid 0 \leq i < s\right]}
\settag{\PCT'}{\PCT+1}
\end{aligned}\]
         
Heap objects are the most interesting: they are allocated via calls to malloc.
In Tagged C, malloc is modeled as an external call to a built-in, so this takes the form
of a special case of that expression. Where \(\mathit{heap\_alloc}\) is some allocation
function (a parameter of the memory model) that takes a size and a memory and returns an address:

\allocstep

And the tag rule is identical to \(\mathbf{LocalT}\), except that it always treats the allocated
object as an array of bytes (making the location tags are always identical.)

\[\begin{aligned}
\truledef{\malloct{\PCT}{st}}
\settag{\pt}{dyn ~ \PCT}
\settagopt{\vt}{X}
\settagopt{\overline{\lt}}{\left[dyn ~ \PCT\right]}
\settag{\PCT'}{\PCT + 1}
\end{aligned}\]

\paragraph*{Color Checking}

When we perform a memory load or store, we check that the pointer tag on the left hand
of the assignment matches the location tag on all of the bytes being loaded or stored.
For instance, in a normal {\it valof} expression, which accesses a left-hand value:

\valofstep

We want to both check that the pointer tag matches all of the location tags, and propagate the
value tag on the value in memory alongside that value.

\[\begin{aligned}
\truledef{\loadt{\PCT}{\pt}{\vt}{\overline{\lt}}}
\assert{\forall \lt \in \overline{\lt} . \pt = \lt}
\settag{\vt'}{\vt}
\end{aligned}\]

There are two other expressions that load from memory, and which therefore invoke
this same rule, {\it assignop} and {\it postincr}. Note that the C spec has the order
of evaluation for {\it assignop} ``unsequenced''; I follow CompCert in evaluating both the left
and right completely before performing the load. Intuitively, assignment-with-an-operator is
classed along with the standard assignment in the spec, so it is appropriate that it be ordered
in the same way.

\assignopstep

\postincstep

On the flip side, we store values to memory using the {\it assign} expression:

\assignstep

As before, we check that the pointer tag matches the locations tags, and then propagate the
value tag (ignoring and overwriting the original value tag.) In addition, we propagate the PC Tag.
                  
\[\begin{aligned}
\truledef{\storet{\PCT}{\pt}{\vt_1}{\vt_2}{\overline{\lt}}}
\assert{\forall \lt \in \overline{\lt} . \pt = \lt}
\settag{\PCT'}{\PCT}
\settag{\vt'}{\vt_2}
\settag{\overline{\lt'}}{\overline{\lt}}
\end{aligned}\]

\paragraph*{Color Propagation}

When a value moves from one location to another, it carries the same tag.
We already saw this in the load and store rules: they maintain the relationship
between the pointer and its tag. Of note here is the \(\mathbf{VarT}\) control point,
which transmits the pointer tag from the environment onto the location expression.
In this policy, it propagates the color unchanged.

\varstep

%In PVI semantics, a pointer cast to an integer maintains its provenance, so the
%cast rule should not change its tag. When cast in this way, integer operations
%are defined on them. Our semantics convert a pointer value to an integer and back
%on cast.

Then the color is propagated via all unary operations and all binary operations
where exactly one argument has a color. Performing an operation with two values
with color tags (i.e., two cast pointers) clears the tag on the result. It can still
be used as an integer, but if cast back to a pointer it will be invalid.

\unopstep

\binopstep

\vspace{\abovedisplayskip}
            
\begin{minipage}[t]{.49\textwidth}            
  \[\begin{aligned}
  \truledef{\unopt{\PCT}{\vt}}
  \settag{\PCT'}{\PCT}
  \settag{\vt'}{\vt}
  \end{aligned}\]
\end{minipage}
\begin{minipage}[t]{.49\textwidth}           
  \[\begin{aligned}
  \truledef{\binopt{\PCT}{\vt_1}{\vt_2}}
  \settag{\PCT'}{\PCT}
  \settag{\vt'}{\caseof{(\vt_1,~ \vt_2)}}
  \caseentry{\mathit{dyn ~ n},X}{\mathit{dyn ~ n}} \\
  \caseentry{\mathit{glob ~ id},X}{\mathit{glob ~ id}} \\
  \caseentry{X,t}{t} \\
  \end{aligned}\]
\end{minipage}

\subsection{PNVI Definitions}

In PNVI, the basic provenance model remains the same as PVI, so we can reuse most of the
same rules. The primary difference is what happens when we cast a pointer to an integer.
In PVI, tags are propagated as normal.

To support PNVI, we need the {\it cast} expression to update the tags of a pointer
being cast to an integer and vice versa. We add two special-case steps to reflect this.

\judgmenttwo{\optional{\(\mem[p]_{|ty|} = \_@\vt_2 @ \overline{\lt}\)}}
            {\(\trule{\PCT',\vt}{\picastt{\PCT}{\pt}{\vt}{\overline{\lt}}}\)}
            {\(\defestate{\cast{int}{\val{p}{\pt}}}{\tptr{ty}} \longrightarrow
              \defestate{\val{p}{vt}}{int}\)}

\judgmenttwo{\optional{\(\mem[p]_{|ty|} = \_@\vt_2 @ \overline{\lt}\)}}
            {\(\trule{\PCT',\pt}{\ipcastt{\PCT}{\vt_1}{\vt_2}{\overline{\lt}}}\)}
            {\(\defestate{\cast{int}{\val{p}{\pt}}}{\tptr{ty}} \longrightarrow
              \defestate{\val{p}{vt}}{int}\)}

For casting an integer to a pointer, we don't need the optional ``peek'' at the memory that it points to.
We simply clear the tag on the resulting integer.
\[\begin{aligned}
\truledef{\picastt{\PCT}{\pt}{-}{-}}
\settag{\PCT'}{\PCT}
\settag{\vt}{X}
\end{aligned}\]

On the other hand, when casting back to a pointer, we need to check the color
of the object that it points to.

\[\begin{aligned}
\truledef{\ipcastt{\PCT}{\vt_1}{\vt_2}{\overline{\lt}}}
\assert{\exists t . \forall \lt \in \overline{\lt} . \lt = t \land t \not = X}
\settag{\PCT'}{\PCT}
\settag{\pt}{t}
\end{aligned}\]

\paragraph{Realizing the Integer-Pointer Cast}

The pointer cast rules take as input the tags on the location pointed to by the
argument being cast. This requires the compiler to add extra instructions to retrieve that tag.
On RISCV, the sequence would be as follows, assuming that {\tt a0} contains the
value being cast. The meaning of instruction tags will be explained below.

\begin{verbatim}
lw a1 a0 0 @ RETRIEVE
sub a1 a1 a1 @ L
add a0 a1 a0 @ IPCAST
\end{verbatim}

In the underlying assembly, we use instruction tags to inform the low-level monitor
of the purpose of each instruction. {\tt RETRIEVE} indicates a special load
whose job is retrieve value and location tags from a location in memory. When it sees
a {\tt RETRIEVE} tag, the monitor allows the load even if it should failstop under the
Concrete C backstop policy. If the load should failstop, however, it is given a default
tag rather than the tags on the memory. A legal load recieves both the value and the location
tags.

The {\tt L} instruction tag simply denotes taking the left-operand's tag on the result of a
binary operation. In this case both operations are identical, but we still need to pick one.
Finally, the {\tt IPCAST} tag declares that this instruction should mimic the Tagged-C-level
rule.

\section{Information Flow Control}

Next we will discuss {\em information flow control} (IFC), specifically {\em partial IFC} (pIFC)
or {\em taint-tracking}. In pIFC, we define a limited set of rules for how information is allowed
to flow from {\em sources} to {\em sinks}. A source \(\sigma\) can be an argument of a function or
its return value. A sink \(\psi\) can be a global variable, a function, or the set of heap objects
allocated by a given function. If we identify a source as carrying high-privilege secrets,
and a sink as lacking the privilege to recieve those secrets, then we would define a {\em no-flow}
rule between them, written \(\sigma \not \rightsquigarrow \psi\).
Likewise if the source is untrusted, and the sink highly sensitive.
Additionally, an IFC policy may contain ``declassification'' rules, \(\sigma / \sigma'\), which
means that if a value comes from the source \(\sigma'\), we may safely ignore its original source
\(\sigma\). We will often write \(* / \sigma\) to say that \(\sigma\) declassifies anything.
We model multiple sources and sinks simultaneously, and absent a no-flow rule, they
can interact freely.

For example, suppose that in the following code, we have a no-flow rule between
the argument {\tt x} of {\tt f} and the global variable {\tt z}
(\(\mathtt{f.x} \not \rightsquigarrow \mathtt{z}\)), and a declassification rule
\(* / \mathtt{g.a}\).

\begin{verbatim}
  int z;

  int g(int a);

  void f(int x, int y) {
    z = x;                    // violation
    z = x + y;                // violation
    if(x) z = 1; else z = 0;  // violation
    z = g(x);                 // legal
  }
\end{verbatim}

The first three lines of {\tt f} violate the no-flow relation by storing values derived from
{\tt x} into {\tt z}. The third line is especially interesting: although {\tt x} is not stored
directly, the value that is stored is conditioned upon it, and can be used to deduce information
about the original value. This is termed an {\em implicit flow}. Finally, in the last line,
while the value of {\tt g(x)} may depend on {\tt x}, it is subject to the declassification rule,
and so it is permissible.

\paragraph{Tagging Taint}

We track the influence of a particular source, or ``taint,'' through the system in the form
of tags on values. We identify sinks through static tags on functions and through memory location tags,
that encode the ``forbidden'' sources. So, our tag set is as follows, with \(X\) being the
default tag that indicates no (interesting) source has tainted the value. Note that our
tags may carry multiple sources.
%
\begin{align*}
  T ::= & \mathit{taint} ~ \overline{\sigma} \\
  & \mathit{forbid} ~ \overline{\sigma} \\
  & X \\
\end{align*}
%
We define three important operations on tags: {\em merge} (\(\sqcup\)), {\em minus} (\(-\)),
and {\em check} (\(\sqsubseteq\)), all partial functions.
%
\[t_1 \sqcup t_2 \triangleq
\begin{cases}
  \mathit{taint} ~ (\overline{\sigma}_1 \cup \overline{\sigma}_2) &
  \textnormal{if } t_1 = \mathit{taint} ~ \overline{\sigma}_1 \textnormal{ and }
  t_2 = \mathit{taint} ~ \overline{\sigma}_2\\
  \bot & \textnormal{otherwise} \\
\end{cases}\]
%
\[t - \sigma \triangleq
\begin{cases}
  \mathit{taint} ~ (\overline{\sigma}' - \sigma) &
  \textnormal{if } t = \mathit{taint} ~ \overline{\sigma}' \\
  \bot & \textnormal{otherwise} \\
\end{cases}\]
%
\[t_1 \sqsubseteq t_2 \triangleq
\begin{cases}
  \mathbf{t} & \textnormal{if } t_1 = \mathit{taint} ~ \overline{\sigma}_1,
  t_2 = \mathit{forbid} ~ \overline{\sigma}_2, \textnormal{ and }
  \overline{\sigma}_1 \cap \overline{\sigma}_2 = \emptyset \\
  \mathbf{f} & \textnormal{else if } t_1 = \mathit{taint} ~ \overline{\sigma}_1 \textnormal{ and }
  t_2 = \mathit{forbid} ~ \overline{\sigma}_2 \\
  \bot & \textnormal{otherwise} \\
\end{cases}\]

\paragraph{Introducing Taint}

Each no-flow rule specifies a source that is either a function argument or return
value. These attach to the {\em call-state} and {\em return-state} rules, respectively.
The call-state rule executes at the beginning of a call, moving all of its arguments into
the local environment, using the \(\mathbf{ArgT}\) tag rule.

\judgmentbr{\(\mathit{def}(f) = (xs, \stmt)\)}
           {\(\lenv' = \lenv \llbracket x \mapsto v@\vt' \mid
             (x,v@\vt) \leftarrow \mathit{zip}(xs,args), \vt' \leftarrow \argt{I}{\PCT}{\vt}{x} \rrbracket\)}
           {\(\cstate{\PCT}{\mem}{\genv}{\lenv}{f}{args}{\cont} \longrightarrow
             \sstate{\PCT}{\mem}{\genv}{\lenv'}{\stmt}{\cont}\)}

And the return-state rule executes after the call returns, inserting the result into the
context saved in the continuation. The program counter on return and the result's tag are
set by the \(\mathbf{CallerRetT}\) tag rule.
           
\judgmenttwo{\(\cont = \mathit{Kcall} ~ \lenv' ~ \mathit{ctx} ~ \cont'\)}
            {\(\PCT'',\vt' \leftarrow \callerrett{\PCT}{\PCT'}{\vt}\)}
            {\(\rstate{\PCT}{\mem}{\genv}{\lenv}{\val{v}{\vt}}{\cont} \longrightarrow
              \sstate{\PCT'}{\mem}{\genv}{\lenv'}{\mathit{ctx}[\val{v}{\vt'}]}{\cont'}\)}

In the case of an IFC policy, both control points are parameterized by a set of IFC rules, \(I\).

\begin{minipage}[t]{.49\textwidth}            
  \[\begin{aligned}
  \truledef{\argt{I}{\PCT}{\vt}{\nt}}
  \letin{\vt' := \vt - \{\sigma \mid \sigma / \nt \in I \}}
  \letin{\vt'' := \vt' \sqcup \mathit{tainted} ~ \{\nt \mid \nt \not \rightsquigarrow \_ \in I\}}
  \settag{\vt'}{\vt''}
  \end{aligned}\]
\end{minipage}

\paragraph{Propagating Taint Through Expressions}

It is simple enough to determine when a value is tainted: at a function
call, all function arguments are tagged with their source identity, and the result
of any expression is tagged with the union of the sources of its operands. If the
expression involves a store or function call itself, we must check the taints on
the value being stored or passed against the forbidden list of the target.

Unary and binary operations:

\begin{minipage}[t]{.49\textwidth}            
  \[\begin{aligned}
  \truledef{\unopt{\PCT}{\vt}}
  \settag{\PCT'}{\PCT}
  \settag{\vt'}{\vt}
  \end{aligned}\]
\end{minipage}
\begin{minipage}[t]{.49\textwidth}           
  \[\begin{aligned}
  \truledef{\binopt{\PCT}{\vt_1}{\vt_2}}
  \settag{\PCT'}{\PCT}
  \settag{\vt'}{
    \vt_1 \sqcup \vt_2
  }
  \end{aligned}\]
\end{minipage}

Loads and stores:

\begin{minipage}[t]{.4\textwidth}     
\[\begin{aligned}
\truledef{\loadt{\PCT}{\pt}{\vt}{\overline{\lt}}}
\settag{\vt'}{\PCT \sqcup \pt \sqcup \vt}
\end{aligned}\]
\end{minipage}
\begin{minipage}[t]{.59\textwidth}
\[\begin{aligned}
\truledef{\storet{\PCT}{\pt}{\vt_1}{\vt_2}{\overline{\lt}}}
\assert{\forall \lt \in \overline{\lt} . \PCT \sqcup \pt \sqcup \vt_2 \sqsubseteq \lt}
\settag{\PCT'}{\PCT}
\settag{\vt'}{\PCT \sqcup \pt \sqcup \vt_2}
\settag{\overline{\lt'}}{\overline{\lt}}
\end{aligned}\]            
\end{minipage}

\paragraph{Implicit Flows}

Things become trickier when control-flow itself can be tainted. This can occur in
any of our semantics' steps that can produce different statements and continuations
depending on the tained value. At that point, any change to the machine state constitutes
an information flow.

To be more specific, consider a statement that contains an expression, \(\stmt(\expr)\),
such that when filled in with a tainted value:
%
\[\sstate{\PCT}{\mem}{\genv}{\lenv}{\stmt\val{v_1}{\mathit{taint} ~ \sigma}}{\cont} \longrightarrow
\sstate{\PCT_1}{\mem_1}{\genv_1}{\lenv_1}{\stmt_1}{\cont_1}\]
%
while
%
\[\sstate{\PCT}{\mem}{\genv}{\lenv}{\stmt\val{v_1}{\mathit{taint} ~ \sigma}}{\cont} \longrightarrow
\sstate{\PCT_2}{\mem_2}{\genv_2}{\lenv_2}{\stmt_2}{\cont_2}\]
%
and where \(\stmt_1 \not = \stmt_2\) or \(\cont_1 \not = \cont_2\). Taking either step
should taint the program state itself! We represent this as a taint on the PC Tag.
When the PC Tag is tainted, all stores to memory and all updates to environments must
also be tainted.

This presents a problem if the program counter must remain tainted indefinitely.
Fortunately, it is safe to remove the taint if all branches eventually rejoin.
We term this a {\it join point}. In terms of the program's control-flow graph, the
join point of a branch is its immediate post-dominator.

In many simple programs, the join point of a conditional or loop is obvious:
the point at which the chosen branch is complete, or the loop has ended.
Such a simple example can be seen in \cref{fig:ifthenelse}; {\tt public1} must be
tagged with the taint tag of {\tt secret}, while it is safe to tag {\tt public2}
\(X\), because that is after the join point, {\tt J}. The same goes for \cref{fig:while}.

But in the presence of unrestricted go-to statements, a join point may not be
local---and sometimes may not exist. Consider \cref{fig:forbreak}, which
uses go-to statements to create an approximation of an if-statement whose join-point
is far removed from the for-loop. The label {\tt J} now has nothing to do with the
semantics of any particular statement.

Luckily this can still be determined statically
from a function's full control-flow graph. So, we annotate our programs with this
information via additional labels. Every statement that branches can carry an
optional label indicating its corresponding join point. If it doesn't have such
a label, that indicates that there is no join point---once the PC Tag is tainted,
it must remain so until a return.

\begin{figure}
  \begin{subfigure}{0.5\textwidth}
\begin{verbatim}
int f(bool secret) {
    int public1, public2;

S:  if (secret) {
b1:     public1 = 1;
    } else {
b2:     public1 = 0;
    }

J:  public2 = 42;

    return public2;
}
\end{verbatim}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \begin{tikzpicture}
      [ initial text={}, initial distance=4em,
        accepting/.style=accepting by arrow,
        accepting distance=4em
      ]
      \node[state,initial]    (S)                        {$S$};
      \node[state]            (b_1) [above right=of S]   {$b_1$};
      \node[state]            (b_2) [below right=of S]   {$b_2$};
      \node[state,accepting]  (J)   [below right=of b_1] {$J$};

      \path[->] (S)   edge              node  {}  (b_1)
                      edge              node  {}  (b_2)
                (b_1) edge              node  {}  (J)
                (b_2) edge              node  {}  (J);
    \end{tikzpicture}
  \end{subfigure}
  
  \caption{Leaking via if statements}
  \label{fig:ifthenelse}
\end{figure}

\begin{figure}
  \begin{subfigure}{0.5\textwidth}
\begin{verbatim}
int f(bool secret) {
    int public1=1;
    int public2;

S:  while (secret) {
b1:     public1 = 1;
        secret = false;
    }

J:  public2 = 42;

    return public2;
}
\end{verbatim}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \begin{tikzpicture}
      [ initial text={}, initial distance=4em,
        accepting/.style=accepting by arrow,
        accepting distance=4em
      ]
      \node[state,initial]    (S)                        {$S$};
      \node[state]            (b_1) [above right=of S]   {$b_1$};
      \node[state,accepting]  (J)   [below right=of b_1] {$J$};

      \path[->] (S)   edge               node  {}  (b_1)
                      edge               node  {}  (J)
                (b_1) edge [bend right] node  {}  (S);
    \end{tikzpicture}
  \end{subfigure}
  
  \caption{Leaking via while statements}
  \label{fig:while}
\end{figure}

\begin{figure}
  \begin{subfigure}{0.3\textwidth}
\begin{verbatim}
int f(bool secret) {
    int public1, public2;

    while (secret) {
        goto b1;
    }

b2: public1 = 1;
    goto J;

b1: public1 = 1;

J:  public2 = 42;
    return public2;
}
\end{verbatim}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \begin{tikzpicture}
      [ initial text={}, initial distance=4em,
        accepting/.style=accepting by arrow,
        accepting distance=4em
      ]
      \node[state,initial]    (S)                              {$S$};
      \node[state]            (inside) [above right=of S]      {};
      \node[state]            (b_2)    [below right=of inside] {$b_2$};
      \node[state]            (b_1)    [right=of b_2]          {$b_1$};
      \node[state,accepting]  (J)      [right=of b_1]          {$J$};

      \path[->] (S)   edge              node  {}  (inside)
                      edge              node  {}  (b_2)
                (inside) edge [bend left] node {} (b_1)
                (b_1) edge              node  {}  (J)
                (b_2) edge [bend right] node  {}  (J);
    \end{tikzpicture}
  \end{subfigure}
  
  \caption{Cheating with go-tos}
  \label{fig:forbreak}
\end{figure}

When we step into a conditional or loop, we need to record its join point for later.
The join point will always be represented by a label, which is an identifier,
so we can simply store it in the local environment.

\judgmenttwo
    {\(\stmt' =
      \begin{cases}
        \stmt_1 & \textnormal{if } \mathit{boolof}(v) = \mathbf{t} \\
        \stmt_2 & \textnormal{if } \mathit{boolof}(v) = \mathbf{f} \\
      \end{cases}\)}
    {\begin{tabular}{l r}
      \multicolumn{2}{c}{\(\PCT'',\PCT''' \leftarrow \splitt{\PCT}{\vt}{\PCT'} \)} \\
      \(\lenv[L] = \val{\_}{\PCT'}\) & \(\lenv' = \lenv[L \mapsto \val{\vundef}{\PCT''}]\) \\
      \end{tabular}}
            {\(\sstate{\PCT}{\mem}{\genv}{\lenv}
              {\mathit{if}(\val{v}{\vt}) ~ \mathit{then} ~ \stmt_1 ~ \mathit{else} ~ \stmt_2 ~ \mathit{join} ~ L}{\cont} \longrightarrow
              \sstate{\PCT'}{\mem}{\genv}{\lenv'}{\stmt'}{\cont}\)}

The label carries a record of all sources that might currently taint the program's
control flow, but will be safe once that label is reached. So, just as \(\PCT\) is merged with
\(\vt\) to produce \(\PCT''\), \(\PCT'\) will be merged with \(\vt\) to produce \(\PCT'''\), a new tag
for \(L\). Then, when we reach the label \(L\), we will retrieve the stored tag and subtract its
sources from the PC Tag at that time.

\begin{minipage}{.4\textwidth}
\[\begin{aligned}
\truledef{\splitt{\PCT}{\vt}{\optional{\(\PCT'\)}}}
\settag{\PCT''}{\PCT \sqcup \vt}
\settag{\optional{\(\PCT'''\)}}{\PCT' \sqcup \vt}
\end{aligned}\]
\end{minipage}
\begin{minipage}{.4\textwidth}
\[\begin{aligned}
\truledef{\joint{\PCT}{\optional{\(\PCT'\)}}}
\letin{\PCT'' := \PCT - \{\sigma \mid \sigma'\}}
\settag{\PCT''}{\PCT \sqcup \vt}
\settag{\optional{\(\PCT'''\)}}{\PCT' \sqcup \vt}
\end{aligned}\]
\end{minipage}

The \(\mathbf{JoinT}\) control point applies whenever we reach a labeled statement, like so:

\judgmentthree
    {\(\lenv[L] = \val{\_}{\PCT'}\)}
    {\(\PCT'',\PCT''' \leftarrow \joint{\PCT}{\PCT'} \)}
    {\(\lenv' = \lenv[L \mapsto \val{\vundef}{\PCT'''}]\)}
    {\(\sstate{\PCT}{\mem}{\genv}{\lenv}
      {L: \stmt}{\cont} \longrightarrow
      \sstate{\PCT''}{\mem}{\genv}{\lenv'}{\stmt}{\cont}\)}

The remaining branching constructs are rather complicated, involving multiple steps
and manipulations of the continuation that are not that relevant to their control
points. Rather than give their semantics in full, it suffices to identify which
transitions contain \(\mathbf{SplitT}\) control points. In \cref{fig:rest}, these
are the transitions from the state marked \(S\).

\begin{figure}
  \begin{subfigure}{0.5\textwidth}
    \begin{tikzpicture}
      [ initial text={}, initial distance=4em,
        accepting/.style=accepting by arrow,
        accepting distance=4em
      ]
      \node[state,initial]    (do)                             {do};
      \node[state,accepting]  (S) [right=of do]                {\(S\):test};

      \path[->] (do)   edge              node  {}  (S)
                (S)    edge [bend left]  node  {}  (do);
    \end{tikzpicture}
    \subcaption{Do-while}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \begin{tikzpicture}
      [ initial text={}, initial distance=4em,
        accepting/.style=accepting by arrow,
        accepting distance=4em
      ]
      \node[state,initial]    (init)                             {init};
      \node[state,accepting]  (S)    [right=of init]             {\(S\):test};
      \node[state]            (do)   [above=of S]                {do};
      \node[state]            (post) [left=of do]                {post};
      
      \path[->] (init)   edge              node  {}  (S)
                (S)      edge              node  {}  (do)
                (do)     edge              node  {}  (post)
                (post)   edge              node  {}  (S);
    \end{tikzpicture}
    \subcaption{For}
  \end{subfigure}
  \begin{subfigure}{\textwidth}
    \center
    \begin{tikzpicture}
      [ initial text={}, initial distance=4em, initial above,
        accepting/.style=accepting by arrow,
        accepting distance=4em
      ]
      \node[state,initial]    (switch)                           {\(S\):switch};
      \node[state]            (case1)    [below left=of switch]  {};
      \node[state]            (case2)    [right=of case1]        {};
      \node[state]            (case3)    [right=of case2]        {};
      \node[state]            (default)  [right=of case3]        {def};
      \node                   (after)    [right=of default]      {};

      \path[->] (switch)  edge              node  {}  (case1)
                          edge              node  {}  (case2)
                          edge              node  {}  (case3)
                          edge              node  {}  (default)
                (default) edge              node  {}  (after)
                (case1)   edge [bend right] node  {}  (after)
                (case2)   edge [bend right] node  {}  (after)
                (case3)   edge [bend right] node  {}  (after);

      \path[dotted,->] (case1) edge              node  {}  (case2)
                (case2) edge              node  {}  (case3)
                (case3) edge              node  {}  (default);
                         
    \end{tikzpicture}
    \subcaption{Switch}
  \end{subfigure}

  
  
  \caption{Remaining Branch Statements}
  \label{fig:rest}
\end{figure}

\paragraph*{Realizing IFC}

In order to implement an IFC policy, we need to specify the rules that it needs to enforce.
The positive here is that the rules are not dependent on one another (with the exception of
declassification rules), and default to permissiveness when no rule is given. We assume that
the user would supply a separate file consisting of a list of triples: the source, the sink,
and the type of rule. This is then translated into the policy.

The other implementation detail to consider are the label tags. These resemble
instruction tags, and that is exactly how they would be implemented: as a special instruction
tag on the appropriate instruction, which might be an existing instruction or a specially
added no-op. But importantly, in this case, these tags are mutable; in a policy that can be
expected to take advantage of their mutability, we will need an extra store to set the tag
fot leter.

It remains to generate those labels. For purposes of an IFC policy, we first generate the program's
control flow graph. Then, for each if, while, do-while, for, and switch statement, we identify the
immediate post-dominator in the graph, and wrap it in a label statement with a fresh identifier.
That identifier is also added as a field in the original conditional statement. The tags
associated with the labels are initialized at program state---in the case of IFC, these defaults
declare that there are no secrets to lowre when it is reached.

\end{document}
