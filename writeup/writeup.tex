\documentclass{llncs}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{xcolor, colortbl}
\usepackage{stmaryrd}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage[capitalize]{cleveref}
\usepackage{tikz}

\usetikzlibrary{automata,positioning,shapes.multipart,arrows.meta}

\title{Flexible Runtime Security Enforcement with Tagged C}
\author{Sean Anderson \and Allison Naaktgeboren \and Andrew Tolmach}
\institute{Portland State University}

\begin{document}

\input{macros.tex}
\input{tagrules.tex}
\input{semantics.tex}
\input{memorygraphics.tex}

\maketitle

\begin{abstract}
Today's computing infrastructure is built atop layers of legacy C code, often
insecure, poorly understood, and/or difficult to maintain.
These foundations may be shored up with dynamic security enforcement.
% and potentially introduce regressions.
Tagged C is a C variant with a built-in {\em tag-based reference monitor}.
It can express a variety of dynamic security policies and enforce them with
compiler and/or hardware support.

Tagged C expresses security policies at the level familiar to C developers: that
of the C source code rather than the ISA. It is comprehensive in supporting different
approaches to security as well as more or less restrictive policies. We demonstrate
this range by providing examples of {\em memory safety}, {\em compartmentalization},
and {\em secure information flow} (SIF) policies. We also give a semantics and reference
interpreter for Tagged C.
\end{abstract}

\section{Introduction}
Many essential technologies rely on new and old C code. 
Operating systems (Linux, Windows, OSX, BSD), databases (Oracle, sqlite3), the internet
(Apache, NGNIX, NetBSD, Cisco IOS), the Internet of Things (IoT), and the 
vembedded devices that run our homes and hospitals are built in and on C \cite{Munoz:PoweredbyC}. 
C is not a relic; more than a third of professional programmers report active developing
in C today \cite{stackoverflow22:dev-survey}. \apt{That sentence seems off topic of ``essential technologies.''}
The safety of these essential technologies
depends on the security of their underlying C codebases. Insecurity might take the form of
%(1)
undefined behavior such as memory errors (e.g. buffer overflows, heap leaks, double-free),
%(2)
logic errors (e.g. sql injection, input-sanitization flaws), or
%(3)
larger-scale architectural flaws (e.g. over-provisioning access rights).

\apt{The flow of the introduction was still very abrupt and
  unmotivated.  I've sketched a different structure, which could still
  be filled out more, esp. with relevant citations.}  Although static
analyses can detect and mitigate many C insecurities, the last line of
defense against undetected or unfixable vulnerabilities is runtime
enforcement of security policies using a reference
monitor茔轸妍令溴蝮镱凡盒灬铑轭缬趱澌深疳螋殂蹯狎灬蜱沆狍镦轭翦蝈篝轭痫扉汩弩汜忮箴邈殒殄狍苠眇棼轭骘蝽狒轱骒秣泔铙趄衢铘忉箦镱苠眇棼礤翎溽翎翎珞狒翎汨邃麸翳躅溴蜢轭溽翎麸汜蝌轭骘蝽狒轱扉脲豉疱痱秭孱犷沐秣铄蝮栝瓞矧箦沲蜷豉沆狍箝骈汜糸镱孽蜷铉屮邈豸轱瞵翳弩翎珞狎汨邈脲犷躔溽翦徙泔蜾轭麸箫礤箦镦蝓戾蠡殒蝓戾鲩镬狒轱轶孱泔躅翦蝈洮翳痱镧蜥驷殪篝镳螽葬珞汜篚痧矧痫扉汩弩轭沆蹁轭骈铄珧衢铄礤盹蝙筢驽豉箦沲蝈轭骘蝽狒轱骒秣磲钿狒矧徙沐篌泔铘蝻飕犷泔礅轭狒轱铙翳弪屣娈澡弩痫扉汩弩汜忮孱骘蜚邃彘翳弪轭箫骠麽蝈矧盹蝈痱镯轶轭珈鏖翳翳衢镦栳蜾麽蝈屮翦铙轱铙篚汨狍烈驮毗茔轸妍狎憝眙妪釉烈茔轸妍秋祆狃蹁楂渤犷猩信茔轸妍蔫狩犷钡龙弼邃铽倍龙弼邃铽钡猩信ㄐ蝻沐篌矧深翦蜢镢塍骘酗扉泫蓬骘蜚屙孱舂苕镲纛雉妍轴蜷犷趔镦猩信栳鲥犰箫忮孱汜祆邃姓托茔轸妍蔫狩犷贝蔫狩犷钡幽托茔轸妍娘鲥虮冬绎弩箪弪谋庚矧蔑蝈酋狎濑茔轸妍娘鲥虿褒麒殂栳忮孱翳箴邈殒殂盹糸鲠麸骘秕黠螂轶疳螋殂蹯狎禊骒屮殁戾轸篚痧矧趔狎忾趄狎箫骠麽蝈溴骈铄骒秣蝓戾秭弪灬蜱黠蜾箝邃翎珞鏖翳狎忾趄狎篝蝓泗躜瀹澡轶骒屮殁殪轸箬秕熹犰祜犷孱玳铄弪麸趱铄箦沲蜷豉孱骘蜚屙孱麸翳疳螋殂蹯狎铄邃镦翳簌篝屙蜥翳弪翳犷狃痨泔铙弪鲠糸鲥镱瀛箝瀛骈趔犰蝈篝蜷泗轱铙茚痿罪蹯忮顼镤麸屮疳钿镱麒翳轶骒屮殁殪轸轶躞彐蹯迈猩信翎珞犷蝓戾狎溴骈铄轭翦蝽镦轭溟鲩漉犰磲汨轭轭篝蝓泗轱铙犷捎镰戾鲥泔钽屦趔犷轭痱徙糸沐狎忉箦镱蝈鲥蝮孱玳铄弪轭翳忮栳鲩矧镦箴邈殒殂泔眇殪弪蟋麒殂磲脲翳屙溟骀殂蹯骘孱玳铄弪麸黩轸瀹惋蝈秭弪箫礤箦沲蜷豉痫扉汩弩汜镱禊忮屮痱弩箦轭翦蝽镦栝玷戾鲥泔溴驽狒躜弩翳狒狎铒痱弩弪鲥狒磲汨轭戾鲥飕篚汨狍骢钽糸镱狎珲礤铘蟋篝蝓泗躜邃豉疱蟋犷篝蝓泗躜邃泔铘蝻骒秣燥徜潋弩翳弩痱镡戾眢麇轭趄镤蹉苠眇棼箫躜沐戾鲥忑箴邈殒殂狒轱骝犴鬻矧汜祆邃苠眇棼葬珑邃谬麒殂犰祜黧孱玳铄弪麸溴筱蜷忮痫扉汩弩轭翦蝽镦驷黹扉狎铆戾鲥泔钽屦趔鏖翳翎珞狒翎汨邃麸骢钽糸镱蟋鲠蜷徕戾犷溽翎鲠祯弩犷蝓戾趄殓珏蝈狒苠眇棼泔铘蝻痫轭趔翳狒泔蝌弩痫钿麸箝珙殒殂犷屮邈豸轱弼孱趔篚汨狍骢钽糸镱汜祆蟋屮痱弩箝镱弼犰踽糸镱犷痫轭翦颦忉箦礤盹蝙徙沐篌弩深痱弼轱躞黠螂茔轸妍描栳氩焙葬玳铄麇秕綮轭邃篚汨骝犴鬻矧骘麸箫躜沐灬铉踽珏犷箬秣邃栾栝玷戾鲥痫扉汩弩泔蹯忮泔眇殪邃麸捎镰戾鲥痫扉汩弩犷孱骘蜚邃躞轭猩信扉脲栳蜾麽蝈深翳痱弩孱黠螂麇屮翦钿翳轶狃痱镝汨麸栳钿戾翳骢祆蝈犰灬铉踽珏怡玳鲩铉溴翎殪邃溴箝珙骘翳铄沐篌狎泔铘蝻痫轭趔犷箬秣轭栾翳妁狎轭翦珧狒邃轭麸莽澌钺黹箦磲铘殂螽领翳秕玷盹糸鲠翦怡猩信葬珑邃轶铒糸邃麸犷疳螋殂蹯狎孱骘蜚屙孱礤汨犷轶憩犷轭溴邃麇沲蝌孱綮轫痨屙孱轸躞轭盹溟骈邃轭翦蝠蝈翦蜥翳弪翳犷鲩泔眇殪狒轱町族鲠扉溽翦翳溴箝珙镦葬珑邃怡躞轭轸麸箴邈殒蜥铉镦轭翦蝈篝轭箦沲蜷豉痫扉汩弩轭沆蹁轭泔眇狎繇孱翎扉狒轱瞵礤盹蝙痱雉邈糸镱犷箦沲蝈轭骘蝽狒轱骒秣ド眇矧翎铘禊箦沲蜷豉痫扉泫汜忮盹溟骈邃鏖翳秕蝈泔眇殪狒轱躅戾篌轸轶镳糸黹邃狍溴筱蜷忮轭ボ泸彐箦愫镳糸镱犰簖ゥ葬珑邃莽铒鲥狃痱镝汨轶翳狒轸轶苠眇棼珏铄蜥飙瘐蝠矬妪筱桢礤骘箴邈殒轭箦沲蜷豉ゥ痫扉汩弩狒翳苠眇棼箫躜沐戾鲥忑躞轭翎绛忉箦蝈驽蝈钽盹铋麸虍ゥ澡轶篝戾镦盹铋麸狍箫汩狒弩礤翎溽翎翎鏖翳翳溽翎轭翳躅溴蜢轭簌篝屙ゥ澡蝻蹒栾豸屮邈豸轱轸躔溽翦翳弩翎珞徙泔蜾轭麸箦痱邃彐轭邃蝓戾蟋矧栳祠殒ゥ翳痱镧蜥黠蹯鲩镬狒蝓戾族狎盹糸鲠翦怡猩信ㄐ蝻珧犴磲忪深翦蜢镢塍骘酗扉泫蓬骘蜚屙孱舂ゥ茔轸妍犷捎屮翦铙轱翳狒轫痨屙孱趔篚汨蝈驽蝈钽盹铋麸轭栳蜾麽蝈ゥ阻殪秕筱桢礤轶珏铄蜥犷泔蹯忮轫痨屙孱翦轭箫骠麽蝈麇衢骘泔眇狒殁殪轸ゥ鏖翳猩信狍扉脲禊栳蜾麽蝈翎蜱弭猩信轶溟篝轭泗轹泔眇狎邃麸箝黹灬簌篝屙篚汨狍烈驮毗茔轸妍狎憝眙妪ゥ犷釉烈茔轸妍秋祆狃蹁楂渤轭翳狒轸翎珞狎鲥蝙灬蜱瀛豉痖汜祆翳箝镦黠蜾ゥ轭翳躅溴蜢轭捎廉澡轶磲脲猩信屮趄屙屐骒屮殁戾犷徕戾麸蝓眭祠轲戾痫扉汩弩狒镱沐ゥ韵南铒瞽蝈泔眇殪狒轱羁ゥ琉痨殂狒轱铙镦葬珑邃轭沆蹁溴骈铋铉躅溴骈铄忮栳鲩矧ㄕ麦轭鲲祧轭礤盹蝙ゥ箴邈殒轭溴翎殪邃箦沲蝈轭骘蝽狒轱骒秣痫扉汩弩犷孱骘蜚轭狎忾趄狎磲钿狒矧徙沐篌泔铘蝻蝓戾螽纤麸篝殪筢翳轶麒孱麇狎孱箬秣轭轸骑蝽犰禊葬珑邃轶溴骈铄狍鲠蜷犷箦磲铘殂翳狒轭篝蝓礤铘矧溟钺蝙屮邈豸轱鏖翳泔铘蝻痫轭趔留遽汨泔铘蝻痫轭衄躞弪溴骈铄箦镦翎蝓戾轶泔铙蹯翦麸痱镳徵狒翎珞犷痫翦铘獒祆汜躞屮邈豸轱麸驷殪篝镳深翳扉黹糸铉汜箦麒弪铒翎蝓戾狎溴骈铄洮翳箦磲铘殂狎箝黹灬麸翳矬镦矧溟钺蝙矛屮沐痿翳狒翳礤盹蝙盹溴轶鲥蝙泔钽蝈翦痫轭翦蝮犷轭翦珏蝮狎弩箦铘獒祆翳筢礤翳轭绌茚痿歪忮屮痨衢麒桢蝈矧骘蝼狎蝈娈族怩殪秕箦磲铘殂镱麸镦翳蔑眇缅螋箦磲铘殂蟋麒殂狎骘蝽犰辁邃狍疳螋镦翳蔑眇缅螋鲥蜷骈邃泔眇殪弪茔轸妍体蝻肮好镯鹈弪酏族痱秭殇蝈驽蝈钽轭翦蝠蝈翦犰箫忉箦镱翳狒镦蔑眇缅螋骘躞轭痱雉雉痖铉犷屮邈豸轭痫扉汩弩葬蝓戾狎黩轸翦溟蝈泗禊轭蔑狍轻祆轭骢钽糸镱螽莛狎徵蜥痂蔑铘蜷怩糸镱簖深篚眄狎麇镦驽翳骘祆秣轭泔铘蜷怩糸镱蠛茆彗轭轸屙辁妪荛翦澡溴箝珙镦泔眇蝈桢铙轹箦镦苠泔铘蝻痫轭趔狒麒殂翳灬铉踽珏轭翦蜴徙弩鏖翳翎绛忉箦痫扉泫荛翦葬珑邃痫扉汩弩轫痨屙孱糸铉ū泔眇狎繇孱翎扉狒轱瞵ú蝈犰轶糸悻疱蝽轶箝鲥礤盹蝙盹溴骝镯翳扉翦蜥趱蝈ㄐ稚┈犷ǔ渝沲蝈深骘蝽狒轱旗秣ㄓ善荛翦骢祆骘蝽犰箦磲铘殂溴骈铋糸镱骘葬珑邃矛骘蝽犰辁邃轭蔑瘳溴筱蜷忾铉栾翳泔铘蝻痫轭趔轭翦蜥泗鏖翳痱镧蜥眢荛翦葬珑邃轭翦蝠蝈翦颥轫痨屙孱翦轭蔑犷屮趄徙翦麸香犴苠钿轸屙辁妪墼夏虾蝈黠螂深翳铄箦泗轱瞵麇玳鲥栝玷戾鲥轭趄镤蹉糸镱镦礤翎溽翎翎珑轭绾栾轸黠螂蟋犷栾轸躞汜轫痱秭箦沲蜷豉澡孱轭茔蝈纣箦愫箦磲铘殂簖麇怛殄骒溟筱躞翳灬铉踽珏狍麒镬瀣忮骘蝈盹鲩铉轭麸痫扉汩弩轭茔蝈纣箦愫痫扉汩弩崎钺祆轭茔蝈纣箦愫弼犰踽糸镱簖麇溟筱躞翳溴珧邋麸麒殂翳溴箝珙礤弭秕顼犰镦骒屮殁殪轸犷狃痨殂徕殪轸麸蝈犰轶糸箦沲蜷豉泔钽弪铙荏邈糸镱湾翎溽翎葬珞犷酗扉汩弩怡砒犴痨妪蔑铙殇弪箦屙轭珈茚痿靠篝蜥殓梏骘蝼狎箦沲蜷豉蝈聃轵屙孱艉噜滹铒戾犭栝玷箦沲蜷豉鲠祯弩麸祜鳝箦沲蜷豉汨犷铄祗Ё深翳屮犴痨轭茔蝈纣骈绾屮饼狍篚礤翳狒荇痼臊轶栝玷箦沲蜷豉鲠祯犷荇痱轭糸痱轭趔麸祜鳝箦沲蜷豉汨犷铄飕箫翳轶泔溴轭溟蝈泗禊疱蜴矧眢戾犭鲩翳祜汜鲠蜷徕戾荇族铒屮痨衢栾麇黠蹯躞葬珑邃麸溴骈铄箦沲蜷豉痫扉泫翳狒黠蹯痱弼孱翳轶戾犭茚痿麒镬屮痨犷狒轱镦翳忉箝殇遽轶黹篌轭桢蝈鲠祯弩汜蝌翎珞翎珞狎汨邈脲狒泔铘蝻痫轭趔蝓戾狎麸忮轭篝犷糸狒邃忮祜鳜弭惝弭惝茚痿令翳轭翳狒秕铄邃骈蝮麸屮痨衢轭骘蝽犰禊栾秕麽铘翎汨邈腴铉麸黠螂犰镱翳扉铄镦噜族栳鲥赭翎珞犷袒翳鲠祯镦痼珏趔翎珑邃怡鲩螋蹂镦箴邈殒殂蝓戾镱婊翳翎轶痱镳徵狒邃翳蝻蹒翳狎轸桧弭殂怡珏铄蜥蝓戾犷轶汜蹒梏狒翳痱轭糸怡鲩螋蹂镦箴邈殒殂蝓戾镱痱轭糸Ё澡雉桢泔铘蝻痫轭趔狎磲轭禊溟篝蜥泗轱铙弩疱汩犰禊零沐篌犷馏箝珙曰疱蜩狃轸轶忮篝麸戾狯翳弩秕镦翳弩轭轸獒屮犴痨弩苊蝈纣骈绾屮饼磲痼遽汨镦翳蝈痫轭趔轭翳屮邈豸轱镦荇纨麸溴筱蜷痿轱镦翳痱镧蜥篝狒狒翳狒痫轭衄鏖翳翳轭瘐鲠祯犷犰翎珞趄遽翦簌礅镬殂犰禊体塄檐忮翳鲠祯疳篌邃麸荇痼臊犷塄荟暨败翳泔蝌弩痫钿轭翎绠茚痿吁怏泸轲趔箬秕熹忮忪蹂麸稞深遽汨篝狒瀣翳骈蝮泔祯眍箬秣翳徙糸鲥骢钽糸镱翳箦泔钿玳鲥翳簌礅镬殂鲠祯弩犷翎珞镦鲠蜷徕戾轭翳祜汜孱鲩蝻铐孱衄犷翳翳轵箬秣翳骒秣镦翳矬翎珞翳秕玷翎蝓戾螽茆彗轭骈珲蝈茆彗轭糸膪痖泗躜妪坼鲥蝙翦铒溴疳螋篝戾禁犰殓罱戾骠茴镤遨磲趄轼犴疱蝮犷蝈痨徙屙孱艚堞犷汨矧谨弩糨ㄣ镤濠茴镤毂荇鲲殇妯轭痼氅茺苘茴镤觳荇轭痼氆祷苘茴镤斐荇痱轭糸┗苘茴镤荇荦苘茴镤遨铒溴溟篝犷沐酱屙蜷玷艚镦泔溴铒螋栎黹浔茴镤遨磲趄轼犴疱蝮犷蝈痨徙屙孱艚堞铒溴溟篝犷沐蕉屙蜷玷艚镦泔溴铒螋璎潋狩翎忪灞茴镤遨犷汨矧筋矧翳塄孳堞茴镤遨犷汨矧筋矧翳塄茼狒梏酐茼狃篝荟躅溴荟暨避苘塄茼狒梏酐痼臊茼狃篝荟暨曹堞茴镤遨犷汨矧筋矧翳塄荟暨莒彐翎蝌秣莒镢犰纛犴濞姗堠苘塄荟暨莒彐翎蝌秣茚蜱纛犴濞荟暨艾芷维芰污痼胼┸卉茴镤遨磲趄轼犴疱蝮犷蝈痨徙屙孱艚堞铒溴溟篝犷沐酱靛憩忮祜鹘镦翎忪灞麇篝潋狩犷汨矧谨弩糨翎忪宀茴镤遨犷汨矧筋矧翳塄孳堞茴镤遨犷汨矧筋矧翳塄茼狒梏酐茼狃篝ㄩ旦荟暨盾苘塄茼狒梏酐痼臊茼狃篝荟暨曹堞茴镤遨犷汨矧筋矧翳塄荟暨莒彐翎蝌秣茚沣弩篝钺礤ㄜ鲷卟┸┈塄荟暨莒彐翎蝌秣茔镱篝糗苘塄荟暨莒彐翎蝌秣茆轭镳纛犴濞荟暨超荟暨穿堠苘塄荟暨莒彐翎蝌秣茚篌殓铘钺礤ㄜ鲷卟荟暨旦堠苘茴镤遨磲趄轼犴疱蝮犷蝈痨徙屙孱艚堞铒溴溟篝犷沐酱靛憩忮祜鹘镦翎忪宀麇篝潋狩犷汨矧谨弩糨翎忪宄茴镤遨犷汨矧筋矧翳塄茼狒栝酐痱轭糸堠堞茴镤遨犷汨矧筋矧翳塄茼狒梏酐猃茼狃篝荟暨奋堞茴镤遨犷汨矧筋矧翳塄荟暨莒彐翎蝌秣茚蜱纛犴濞荟暨冬芷污茼狒栝酐痱轭糸莠芰污彷┸苘茕蜥髹瞄蜚戾毂箫豸瑭黹浔沐铘弪┗茕蜥黹浔沐铘弪翎忪灞麇篝┗茕蜥髹瞄蜚戾觳箫豸瑭翎忪宀麇篝┗茕蜥髹瞄蜚戾斐箫豸瑭翎忪宄麇篝┗苠钿糸膪痖泗躜妪茔狃糸镱砒犴痨饼莒徕屐骈绾屮饼苠钿骈珲蝈茚痿阻轶荇溴筱蜷忮忮骘蝈荇痼臊靠澡轭轸獒翎镱荇塄荟暨避┈泔礤骝镯翳塄莒镢犰纛犴遘翎蝓戾犰祜汜祗骘玳鲥骢钽糸镱钺礤麒殂轶疳蜥礤翦麸翳蝓戾珏翳筢礤翎绠茚痿物狒犰镡鲩秕麸礤矧翳蝈徜弪麒荇珏趔犷轭轸獒鲠祯犷翎狒犰飚ㄉ钿邋洮箬秕熹轸箝钽轸汜铑雉忮徙沐篌邃忮骘蝈轸徙聃轵弩痱镳弪轭轸獒鲠祯蹇五邃犷屮痨犷狒轱狒戾狍衄犰翳秕玷翳轶轶眭滗轭翳麽翦蝮澡翎镱荇痼臊泔礤骝镯塄茚蜱纛犴遘┈麒殂轶疳蜥礤翦蜷邃怡翳翎镱翳狎珲礤铘鲠祯ㄜㄜ鲷甙堠犷翳钺礤镦怙翳翳骢钽糸镱犷翳狎珲礤铘五衄荇轶狍箝珙邃荇痼氆谍骑躜翎蝓戾狎轭鲲脲漉蜷铉翳轶篝狒屙孱艉塄茚沣弩篝钺礤堠麒孱蝈徜轭骝镯荇痼臊塄茔镱篝纛犴遘骘翳翎镱翳泔铙翎铘塄茆轭镳纛犴遘骘翳徜溟糸镱犷骈钺祆塄茚篌殓铘钺礤堠骘翳狍箝珙礤铘轭麸荇塄茆轭镳纛犴遘轶疳蜥礤翦蜷邃怡翳腴钿镦镳弪狒轱轭徜溟糸镱麸翳翎珞镱轸轭瘐趔伶翦翳骈钺篝屦翳屮邈豸轱轶轭翳骢钽糸镱荇痱轭糸麒弪轸泔铙蹯趔塄茚蜱纛犴遘箦泔钿糸礤澡簌篝屙汜痱弼孱翳痱镧蜥骝镯秕麴豸糸铉鲠祯溴蜷鲥骝镯荇痼臊怡轭篝犷糸狒轭翳弩翎蝓戾鏖翳骢钽糸镱翳狒轫痨屙孱苠箦沲蝈轭骘蝽狒轱骒秣骑翳翎蝓戾箦孱箫驷颥翳痫扉泫玳鲥轭茔蝈纣骈绾屮犴痨灞蝓戾簖滹弩翳趄殂氘婶溴骈铄赭翎珞塄荑殓柢犷塄莒秣堠骘栝玷箦沲蜷豉荇痼臊犷翳轭珞溴蜷鲥骝镯轸犷祜箦沲蜷豉ㄥ鲥蝙翳轭屐箦深翎蝓戾蟋翳狍箝珙礤铘镳弪狒矧航溴铒翦犷狍箝珙礤铘麸翳钺礤翎绛蝓戾秕麴豸茚痿冕麇泔铙轶翦铘禊躞痱轫邃鲠蜷徕戾骘秕麴豸ㄡ钿筢箫桢蝈┛噜冕箦Ё篝狒屙孱趔狎箫礤糸礤徕怛弼獒翦怡狍篚黹铉翳狒犷轭瘐翳狒滹弩瞌磲翥汜箦汜躞弩驷殪篝镳茚痿迈翳狒滹弩瞌栳痧孱桢蝈箫麒筢轸亠狎铒黩轸轭蝈驽蝈钽磲铛犰↓茆彗轭骈珲蝈茆彗轭黹铋疳珏爱弟翦赭殇翳茔镱篝趄蹯邂祜汶塄荟航莒秣堠莒镢犰趄蹯邂祜汶塄荟航莒秣堠茚沣弩篝蝓戾忪镢臌塄荟臾航荟糗茚篌殓铘蝓戾忪镢臌塄荟臾航荟暨曹茆轭镳趄蹯邂祜汶茔狍屣骠黠塄ㄜ鲷弑荟暨博堠ㄜㄜ祜鳜莒秣堠塄荟臾航莒秣堠塄荃钿弪扉铄\)}{\(\vt':=\high\)}}
  \end{minipage}
  \begin{minipage}{0.4\textwidth}
    \[\tau::=\high | \low\]
    \argtruleblock
        {\caseofthree{\((f,x,\vt)\)}
          {(\(\mathtt{printi},\underline{~},\high\))}{\(\fail\)}
          {(\(\mathtt{f},\mathtt{psk},\underline{~}\))}{\(\vt':=\high\)}
          {\(\underline{~}\)}{\(\vt':=\vt\)}}
  \end{minipage}

  \caption{Secure Information Flow (pt. 1)}
  \label{fig:example1rules}
\end{figure}

The interesting rules are \(\binoptname\) and \(\argtname\). \(\binoptname\)
combines two tags, setting the result of a binary operation \(\high\) if either of its arguments are.
\(\argtname\) is parameterized by the name of the function argument being processed.
It tags {\tt psk} \(\high\), and maintains the security level of all other arguments.
But if a \(\high\) value is being passed to a parameter of {\tt printi}, the rule will fail.
So, in this example, we will be unable to generate a tag
\(\vt_5\), and the tag processor will throw a failstop rather than allow execution to continue.

Example \ref{fig:ex2} adds two new wrinkles: we need to keep track of metadata associated with
addresses and with the program's control-flow state. If the variable {\tt mm} represents
mmapped memory \apt{I don't think that's what you mean. mmap is a linux system call. Say ``memory-mapped device register'' perhaps. In which case, make it {\tt volatile} again.} that can be seen publicly, we want to avoid storing the password there. And, by
branching on the password, we risk leaking information that could eventually compromise it even
if we never print it directly (an {\em implicit flow}.)
\apt{Again, describe the tag-based solution informally first.}

Global variables like {\tt mm} are always kept in memory, as are locals with reference types \apt{Not the normal use of this term. Just say: ``local arrays and structs.''} like arrays.
Other parameters and locals are placed in memory if they have their addresses taken.
Objects in memory have additional ``location tags'' that are notionally associated with the memory
itself, which we will denote by metavariable \(\lt\). The store maps their identifier
to their address\apt{???}, along with its own ``pointer tag'' which we will distinguish with the
metavariable \(\pt\). To track metadata about the overall system state, we also add
a special global tag called the PC Tag\apt{can we lower-case ``Tag'' everywhere?}, ranged over by \(\PCT\).

\begin{figure}
\begin{tikzpicture}[every text node part/.style={align=left}]
  \node[matrix, ampersand replacement=\&, anchor=west] (code)
       {
         \node {\tt int mm;}; // mmapped \\
         \node (l1) {\tt void g(int psk) \{}; \\
         \node (l2) {\tt   if(psk > 0)}; \\
         \node (l3) {\tt     mm = 1;}; \\
         \node {\tt \}}; \\
       };

  \node[matrix, ampersand replacement=\&, node distance=6em, right=of l1.north,draw,anchor=west] (table1)  
       {
         \node[anchor=north] {\(g @ \PCT_1\)}; \&
         \node[anchor=north] {\(\mathtt{mm} \mapsto p @ \pt_1 \) \\
           \(\mathtt{psk} \mapsto i @ \vt_2\) \\
           \(p:\fbox{\(\vundef @ \vt_1 @ \lt_1\)}\)
         }; \&
         \node[anchor=north] {\(\pt_1, \vt_1,\lt_1 \leftarrow \globaltname(mm)\) \\
           \(\pt_2, \vt_2 \leftarrow \argtname(\vt_0,\FN[g],\AN[psk])\) \\
           \(\PCT_1 \leftarrow \calltname(\PCT_0, \FN[g])\)}; \\
       };
       
 \node[matrix, ampersand replacement=\&, node distance=5em, below=of table1.west,draw,anchor=west] (table2)         
      {
        \node[anchor=north] {\(g @ \PCT_2\)}; \&
        \node[anchor=north] {\(\mathtt{mm} \mapsto p @ \pt_1\) \\
          \(\mathtt{psk} \mapsto i @ \vt_2\) \\
           \(p:\fbox{\(\vundef @ \vt_1 @ \lt_1\)}\)
        }; \&
        \node[anchor=north] {\(\vt_3 \leftarrow \accesstname(\vt_2)\), \(\vt_4 \leftarrow \constt\) \\
          \(\vt_5 \leftarrow \binoptname(>,\vt_3,\vt_4)\) \\ 
          \(\PCT_2 \leftarrow \splittname(\PCT_1, \vt_5)\)}; \\
      };

 \node[matrix, ampersand replacement=\&, node distance=6em, below=of l3,draw,anchor=west] (table3)         
      {
        \node[anchor=north] {\(g @ \PCT_2\)}; \&
        \node[anchor=north] {\(\mathtt{mm} \mapsto p @ \pt_1\) \\
          \(\mathtt{psk} @ \pt_2 \mapsto i @ \vt_2 @ \lt_2\) \\
           \(p:\fbox{\(\vundef @ \vt_1 @ \lt_1\)}\)
        }; \&
        \node[anchor=north] {\(\vt_6 \leftarrow \constt\) \\
          \(\vt_7 \leftarrow \assigntname(\PCT_2,\vt_1,\vt_6)\) \\
          \(\vt_8,\lt_3 \leftarrow \storetname(\PCT_2,\pt_1,\vt_7,\lt_1)\)}; \\
      };

  \draw[Circle-]
  (l1.south) -| (table1.west);

  \draw[Circle-]
  (l2.south) -| (table2.west);

  \draw[Circle-]
  (l3.south) |- (table3.west);  

\end{tikzpicture}
\caption{Implicit Flows and Memory}
\label{fig:ex2}
\end{figure}

Tagged C initializes the tags on {\tt mm} with the \(\globaltname\) rule. The PC Tag
at the point of call, \(\PCT_0\), is fed to \(\calltname\) to determine a new PC Tag
inside of {\tt g}. And the if-statement consults the \(\splittname\) rule to update the PC Tag
inside of its branch based on the value-tag of the expression {\tt psk < 0}. Once inside the
conditional, when the program assigns to {\tt mm}, it must consult both the
\(\assigntname\) rule as normal and the \(\storetname\) rule because it is storing
to memory.

Because ``don't print the password'' is so similar to ``don't leak the password,'' we can
implement the latter with the same tag type, duplicating most of the rules.\apt{This gives the bogus impression that we expect to write lots of function-specific rules with their own special-purpose tags, etc.} We just need to
deal with memory tags and the PC Tag. We will tag memory
locations \(\high\) by default, indicating that they are allowed to contain \(\high\)-tagged values,
but {\tt mm} will be tagged \(\low\). The most interesting rules are:

\begin{figure}
  \globaltruleblock{
    \(\vt:=\low\) \\
    \(\pt:=\low\) \\
    \caseoftwo{x}
              {\tt mm}{\(\lt:=\low\)}
              {\(\underline{~}\)}{\(\lt:=\high\)}}
  \truleblock{\(\splittname(\PCT,\vt)\)}{
    \caseoftwo{(\(\PCT,\vt\))}
              {(\(\low,\low\))}{\(\PCT':=\low\)}
              {\(\underline{~}\)}{\(\PCT':=\high\)}
  }
  \storetruleblock{
    \(\lt':=\lt\) \\
    \caseofthree{(\(\PCT,\vt,\lt\))}
                {(\(\underline{~},\underline{~},\high\))}{\(\vt':=\vt\)}
                {(\(\low,\low,\low\))}{\(\vt':=\vt\)}
                {\(\underline{~}\)}{\(\fail\)}
  }
\end{figure}

In this case, \(\splittname\) will set the PC Tag to \high, as it branches on a value derived from {\tt psk}.
Then, when it comes time to write to {\tt mm}, \(\storetname\) will fail rather than write to a low address
in a high context.

\section{The Tagged C Language: Syntax and Semantics}
\label{sec:language}

\begin{table}[t]
  \begin{tabular}{|l|l|l|l|}
    \hline
    Rule Name & Inputs & Outputs & Control Points \\
    \hline
    \(\accesstname\)    & \(\accesstargs\)       & \(\accesstres\)    & Variable Accesses \\
    \(\loadtname\)      & \(\loadtargs\)         & \(\loadtres\)      & Memory Loads \\
    \(\assigntname\)    & \(\assigntargs\)       & \(\assigntres\)    & Variable Assignments \\
    \(\storetname\)     & \(\storetargs\)        & \(\storetres\)     & Memory Stores \\
    \(\unoptname\)      & \(\unoptargs\)         & \(\unoptres\)      & Unary Operation \\
    \(\binoptname\)     & \(\binoptargs\)        & \(\binoptres\)     & Binary Operation \\
    \(\consttname\)     &                        & \(\consttres\)     & Applied to Constants/Literals \\
    \(\exprsplittname\) & \(\exprsplittargs\)    & \(\exprsplittres\) & Control-flow split points in expressions \\
    \(\exprjointname\)  & \(\exprjointargs\)     & \(\exprjointres\)  & Join points in expressions \\
    \(\splittname\)     & \(\splittargs\)        & \(\splittres\)     & Control-flow split points in statements\\
    \(\labeltname\)     & \(\labeltargs\)        & \(\labeltres\)     & Labels/arbitrary code points \\
    \(\calltname\)      & \(\calltargs\)         & \(\calltres\)      & Call \\
    \(\argtname\)       & \(\argtargs\)          & \(\argtres\)       & Call \\
    \(\rettname\)       & \(\rettargs\)          & \(\rettres\)       & Return \\
    \(\globaltname\)    & \(\globaltargs\)       & \(\globaltres\)    & Program initialization \\
    \(\localtname\)     & \(\localtargs\)        & \(\localtres\)     & Call \apt{clarify this is invoked per local that comes into scope. and what about local blocks?}\\
    \(\dealloctname\)   & \(\dealloctargs\)      & \(\dealloctres\)   & Return \apt{ditto} \\
    \(\extcalltname\)   & \(\extcalltargs\)      & \(\extcalltres\)   & Call to linked code \\
    \(\malloctname\)    & \(\malloctargs\)       & \(\malloctres\)    & Call to {\tt malloc} \\
    \(\freetname\)      & \(\freetargs\)         & \(\freetres\)      & Call to {\tt free} \\
    \(\fieldtname\)     & \(\fieldtargs\)        & \(\fieldtres\)     & Field Access \\
    \(\picasttname\)    & \(\picasttargs\)       & \(\picasttres\)    & Cast from pointer to scalar \\
    \(\ipcasttname\)    & \(\ipcasttargs\)       & \(\ipcasttres\)    & Cast from scalar to pointer \\
    \(\ppcasttname\)    & \(\ppcasttargs\)       & \(\ppcasttres\)    & Cast between pointers \\
    \(\iicasttname\)    & \(\iicasttargs\)       & \(\iicasttres\)    & Cast between scalars \\
    \hline
  \end{tabular}

  \caption{Full list of tag-rules and control points\apt{Ordering still seems sub-optimal. AccessT and AssignT are seldom interesting, so could move down the list. CallT, ArgT, RetT are quite important, so could move up.}}
  \label{fig:controlpoints}
\end{table}

\apt{Start boldly: ``Tagged C is (almost) full ordinary C.'' Then list exceptions, wherever they come from (CompCert or us). }


Tagged C uses the full syntax of CompCert C \cite{Leroy09:CompCert},
an elaboration\apt{that's a technical term in this context, which I don't think you mean} of the C standard into a formal operational semantics,
with minimal modification\apt{from what?}, with the exception of inline assembly.\apt{as I noted before, that's not part of the standard}
Our semantics (given in full in the appendix) are a small-step reduction
semantics which differ from CompCert C's in two key respects. First, Tagged C's semantics contain
{\em control points}: hooks within the
operational semantics at which the tag policy is consulted and either tags are updated, or the system
failstops. (Control points resemble ``advice points'' in aspect-oriented programming, but narrowly
focused on the manipulation of tags.\apt{This remark would be more useful in the intro.}) A control point consists of the name of a {\em tag rule}
and the bindings of its inputs and outputs. Take, for example, the expression step reduction
for binary operations, below. On the left, the ``tagless'' version of the rule reduces a
binary operation on two input values to a single value by applying the operation.
On the left, the Tagged C version adds tags to the operands and the result, with the result tag
derived from the \(\binoptname\) rule.

\begin{minipage}[t]{0.37\textwidth}
  \binopsteptagless
\end{minipage}
\begin{minipage}[t]{0.6\textwidth}
  \binopstep
\end{minipage}

The tag rule itself is instantiated as a partial function; if a policy leaves a tag rule
undefined on some inputs, then those inputs are considered to violate the policy, sending
execution into a special failstop state. The names and signatures of the tag rules,
and their corresponding control points, are listed in \Cref{fig:controlpoints}.\apt{It wouldn't hurt to
  talk briefly through these rules, especially when the connection between rule name and control point
  is not obvious. And make a point of
  saying: ``and this is all there are or ever will be (we hope)''}

\apt{This para, which I rewrote to be a bit more positive, could go much earlier in the paper.}
The choice of control points and their associations with tag rules, as well as the tag rules'
signatures, form the essence of Tagged C's design. 
We have validated our design on the three classes of policies explored in this paper,
and, outside of a few known limitation discussed in \ref{??}\apt{e.g. substructural memory safety},
we believe it is sufficiently expressive to describe most other flow-based policies, although
of course further experience may reveal unexpected deficiencies. 

The second major semantic distinction between Tagged C and CompCert C is that Tagged C has no
memory-undefined behavior. CompCert C models memory as a collection of blocks of offsets,
and treats all variables as having their own block. Tagged C instead follows Concrete C
\cite{} [Need something to cite!] in separating variables into public and private data.\apt{No, you will need to explain Concrete C in more detail}
Public data (all heap data, globals, arrays, structs, and address-taken locals) share a single flat address
space, where its behavior is implementation defined. \sna{Technically right?\apt{but not very informative. You should simply describe how your memory model works. then we
can add some language justifying why this is an interesting model in its own right.}}
Private data (non-address-taken locals and parameters) have a separate store.

%Without memory safety, programs
%that exhibit memory-undefined behavior will act as their compiled equivalents would, potentially
%corrupting memory; we expect that a memory safety policy will be a standard default, but that the
%strictness of the policy may need to be tuned for programs that use low-level idioms.

\paragraph*{Parts of a policy}

A policy consists of instantiations of the tag type
and each of the tag rules associated with control points in the semantics. Table \cref{figcontrolpoints}
identifies the full collection of control points, their tag rules, and the inputs and outputs of the tag rules.
The tag type \(\tau\) must be inhabited by a default tag.

\paragraph*{Identifiers}

Identifiers are a C source-level construct, and a policy designer might want to operate on them,
so we embed them in tags. These are called {\em name tags}. We give name tags to the
following constructions and identify them as follows:
\begin{itemize}
\item Function identifiers, \(\FN\)
\item Function arguments, \(\AN\)
\item Global variables, \(\GN\)
\item Labels, \(\LN\)
\item Types, \(\TN\)
\end{itemize}

\paragraph*{Combining Policies}

Multiple policies can be enforced in parallel. If policy \(A\) has tag type \(\tau_A\)
and policy \(B\) has \(\tau_B\), then policy \(A \times B\) should have tag type
\(\tau = \tau_A \times \tau_B\). Its tag rules should apply the rules of \(A\) to
the left projection of all inputs and the rules of \(B\) to the right projection
to generate the components of the new tag. If either side failstops, the entire
rule should failstop.

\apt{Need to describe the limits on this idea, namely when policies are not completely
  orthogonal. For example, a compartmentalization policy is likely to overlap a generic
  memory safety policy.}

This process can be applied to any number of different policies, allowing for instance
a combination of a baseline memory safety policy with several more targeted
information-flow policies.

\section{Example Policies}
\label{sec:policies}

The heart of Tagged C is in its security policies.\apt{Not a good lead}  Using the control points shown in \cref{sec:language},
we will walk through three example policies: PVI memory safety, compartmentalization, and
secure information flow.

\apt{Take a deep breath and remind yourself that the point of this paper is to explain and justify the
  control points and tag rules, NOT to explain these policies. Every section and every paragraph
  should be organized  with that in mind.}


\subsection{PVI Memory Safety}
\label{sec:PVI}

\apt{How about a quick informal summary of what this means intuitively? Then explain why a
  one-size-fits-all solution is not appropriate... In general, don't expect the reader to
be very familiar with the idea of UB's or with the difference between official and defacto C standards.}
Memory safety is defined relative to a {\em memory model}---a formal or informal description of
how a high-level language handles memory. The memory model associated with the C standard leaves
many behaviors undefined, including some that are used in practice \cite{Memarian16:DeFacto}.
Memarian et al. have proposed two alternatives that define useful subsets of these behaviors
\cite{Memarian19:ExploringCSemantics}. We choose their ``provenance via integer'' (PVI) memory model
as our example.

Variations of memory safety have been enforced in PIPE already, but usually\apt{??} using
an ad hoc memory model.\apt{Specific citations? How are they ``ad hoc?''}
PVI has the virtue of giving definition to many memory UBs in which a pointer is
cast to an integer, subjected to various arithmetic operations, and cast back to a pointer.
\apt{But Concrete C also gives this a definition!  Need to explain what PVI still \emph{prevents}.}
Memarian et al.'s second memory model, {\it PNVI} (provenance not via integer), is even more permissive.
We can also enforce it in Tagged C, though its security value is questionable, and we will
not describe it in this paper.\apt{Last two sentences seem to add nothing.}
For a policy to enforce PVI, it should not failstop on any program that is defined in PVI.\apt{Isn't that tautological?}
However, it should failstop if and when a program reaches UB.\apt{Somewhat confusing, because
  PVI turns some C standard UB's into defined behaviors.} For example, on many systems,
pointers are (at least) 4-byte aligned, so the low-order two bits can be ``stolen'' to contain
other data which is manipulated using bit-level shifting and masking operations. 
This idiom is often used when the programmer wants to associate a flag with the pointer, e.g. in
some garbage collection implementations.\cite{??} \apt{I don't think Cheney is particularly relevant.}
These pointer manipulations are probably UBs in standard C (the standard is not completely clear on this point),
but are explicitly defined in PVI.  
But violations such as buffer overflows in which a load, store, or free 
occurs outside of the proper range remain undefined in PVI and must failstop. In \cref{fig:overrun},
we see an example of such a program, and a possible memory layout in which
the overflow ends up overwriting the variable {\tt y}.\apt{It is odd that the example doesn't illustrate
  the sort of bit-twiddling that PVI is intended to support! Actually, the best thing to see is how the tag rule
instantiations would \emph{change} to accommodate different policies (PVI, PNVI, something stricter...) }

\begin{figure}
  \begin{tikzpicture}[every text node part/.style={align=left}]
    \node[matrix, ampersand replacement=\&, anchor=west] (code)
         {
           \node (l0) {\tt void overrun() \{}; \\
           \node (l1) {\tt   int[2] x; int y;}; \\
           \node (l3) {\tt   *(x+2) = 42;}; \\
           \node {\tt \}}; \\
         };

    \node[matrix, ampersand replacement=\&, column sep=-1em, node distance=4.5em, below=of l3.west,anchor=west] (table2)
         {
           \node[anchor=north] {\hspace{1em}}; \&
           \node[anchor=north] {\memory{\hspace{-2.5em} \(\mathtt{x}\mapsto 84 @ \pt_1\)}{\(\vundef\)}{\(\vt_1\)}{\(\lt_1\)}}; \&
           \node[anchor=north] {\memory{\(88\)}{\(\vundef\)}{\(\vt_1\)}{\(\lt_1\)}}; \&
           \node[anchor=north] {\memory{\hspace{-2.5em} \(\mathtt{y}\mapsto 92 @ \pt_2\)}{\(\vundef\)}{\(\vt_2\)}{\(\lt_2\)}};
           \\
         };

    \node[matrix, ampersand replacement=\&, node distance=1em, right=of table2.east,anchor=west,draw] (tableside)
         {
           \node[] {\(\PCT_1, \vt_1,\pt_1,\lt_1 \leftarrow \localtname(\PCT_0)\)}; \\
           \node[] {\(\PCT_2, \vt_2,\pt_2,\lt_2 \leftarrow \localtname(\PCT_1)\)}; \\
           \node[] {\(\vt_3 \leftarrow \constt\)}; \\
           \node[] {\(\pt_2 \leftarrow \binoptname(+,\pt_1,\vt_3)\)}; \\
           \node[] {\(\vt_4 \leftarrow \assigntname(\PCT_2,\vt_2)\)}; \\
           \node[] {\(\PCT_3,\vt_5,\lt_3 \leftarrow \storetname(\PCT_3,\pt_2,\vt_5,\lt_3)\)}; \\
         };
    
    \node[matrix, ampersand replacement=\&, column sep=-1em, node distance=4em, below=of table2.west,anchor=west] (table3)
         {
           \node[anchor=north] {\hspace{1em}}; \&
           \node[anchor=north] {\memory{\(84\)}{\(\vundef\)}{\(\vt_1\)}{\(\lt_1\)}}; \&
           \node[anchor=north] {\memory{\(88\)}{\(\vundef\)}{\(\vt_1\)}{\(\lt_1\)}}; \&
           \node[anchor=north] {\memory{\(92\)}{\(  42\)}{\(\vt_4  \)}{\(\lt_4\)}}; \\
         };
  \end{tikzpicture}
  \caption{Buffer Overflow in Action}
  \label{fig:overrun}
\end{figure}

%We now show separate location tags on each of the four bytes in each word. In the inputs and outputs
%of a tag rule, we write this \(\lts\), indicating that the rule consumes and produces multiple locations tags.

\Cref{fig:overrun} shows a possible initial state of memory on entry to {\tt overflow} and the state after
the assignment to {\tt *(x+2)}, assuming that the PC Tag is \(\PCT_0\) at the call.\apt{Where does the 84 come from?
  And this layout also assumes that {\tt y} is in memory---but why is that?}
The central tag rules are \(\binoptname\) and \(\storetname\): the former computes the tag
on the pointer that will be used to access {\tt x+2} in memory, and the latter decides if the
store will be allowed.\apt{But actually, the LocalT rules are also crucial here. Also: I thought
  you were going to refactor things so that LocalT keeps its signature from Fig. 2, and there
  is a separate StoreT invocation for locals that live in memory. I guess maybe not.}

We can prevent overwrites like this using a {\em memory safety} policy. In brief, whenever
an object is allocated, it is assigned a unique ``color,'' and its memory locations as well
as its pointer are tagged with that color. Pointers maintain their tags under arithmetic
operations, and loads and stores are legal if the pointer tag matches the target memory location tag.
\apt{Need citations for this idea. At least our S\&P paper. R\&D credit \url{https://dl.acm.org/doi/10.1145/1321631.1321673}.}
The default tag \(N\) indicates that there is currently no color.
The rules for the \(PVI\) memory safety policy are given in \cref{fig:pvi}. In this case, we will
have \(\pt_1 = \lt_1 = \tagz\) and \(\pt_2 = \lt_2 = \tagone\). When the program tries to write to {\tt x+2},
the \(\storetname\) rule compares \(\pt' = \tagz\) with \(\lt_2\), and failstops because they differ.
\apt{Inconsistency in these rules: do LoadT and StoreT take a single $lt$ or a vector of them?}

\begin{figure}
  \color{blue}
  \begin{align*}
    \tau ::= & \clr & \clr \in \mathbb{N} \\
    & \N \\
  \end{align*}
  
  \scriptsize
  \begin{minipage}[t]{0.3\textwidth}
    \vspace{-2.5em}
    \binoptruleblock{
      \caseofthree
          {\((\vt_1, \vt_2)\)}
          {\((\clr,\N)\)}{\(\vt' := \clr\)}
          {\((\N,\gentag)\)}{\(\vt' := \gentag\)}
          {\((\clr_1, \clr_2)\)}{\(\vt' := \N\)}
    }
    \unoptruleblock{\(\vt' := \vt\)}

  \end{minipage}
  \begin{minipage}[t]{0.25\textwidth}
    \vspace{-2.5em}
    \localtruleblock
        {\(\PCT' := \PCT+1\);
          \(\pt := \PCT\)\\
          \(\vt := \N\);
          \(\lt := \left[ \PCT \right]\)
        }
    \malloctruleblock
        {\(\PCT' := \PCT+1\);
          \(\pt := \PCT\) \\
          \(\vt := \N\);
          \(\lt := \left[ \PCT \right]\)
        }
  \end{minipage}
  \begin{minipage}[t]{0.3\textwidth}
    \vspace{-2.5em}
    \loadtruleblock{\(\mathbf{assert}  \forall \lt \in \overline{\lt} . \pt = \lt\) \\ \(\vt' := \vt\)}

    \storetruleblock{\(\mathbf{assert}  \forall \lt \in \lt . \pt = \lt\) \\
      \(\PCT' := \PCT\);
      \(\vt' := \vt_2\); 
      \(\lt' := \lt\)}
  \end{minipage}

  \caption{PVI Memory Safety Policy}
  \label{fig:pvi}
\end{figure}

The cast rules\apt{what cast rules?}, meanwhile, have no effect on the tag of the value being cast at all. So,
we can cast a pointer to a scalar value, perform any operation that is defined on that type
on it, and cast it back, and it will retain its pointer tag. As long as it ends up pointing
at the same object, loads and stores will be successful. Function pointers are an exception:
Tagged C's underlying control-flow protections prevent them from being tampered with.

\subsection{Compartmentalization}
\label{sec:comp}
% notes ended up below, in the coarse grained section
In a perfect world, all C programs would be memory safe. In reality, it is common
for a codebase to contain undefined behavior that will not be fixed. Developers intentionally use 
low-level idioms that are UB \cite{Memarian16:DeFacto}, or the cost and risk of regressions may make it
undesirable to fix bugs in older code \cite{Bessey10:Coverity}.\apt{Do you want to say that we may
  not want to turn on the failstop protections of the previous section because that would cause too
  much code to break?}

A compartmentalization policy can isolate potentially risky code, such as code with intentional
or unfixed UB, from safety-critical code, and enforce the principle of least privilege. 
Compartmentalization limits the possible damage from exploitation\apt{??} to the containing compartment.
And even in the absence of language-level errors, compartmentalization can usefully 
restrict how code in one compartment may interact with another.
Ideally, each component should have only the
{\em least privilege} necessary to complete its task.
This popular defense concept can be implemented at many levels. It is often built
into a system's fundamental design, like a web browser sandbox for untrusted javascript.
For our use case, we consider a compartmentalization scheme being added to the system
after development. A set of compartment identifiers are ranged over by \(C\),
and function and global identifiers are mapped to compartments by \(\mathit{comp}(id)\). 

\paragraph{Coarse-grained Protection}

% this is two tasks in the same process, all they want to do is pass scalars adn not stomp
% on each other
% then fine grained is libaries + your code, which usually need more
% than mere scalars. think libc. could foil rop gadgets? 
% mac - explicit list of allowed calls
% capability - says this is shared, protects with basic safety. anything 
%   else cannot be shared. unique colors to defeat forced pointer arthimetic. hybrid system
%   roughly the effect of containing things, but wihtout the issues of the MAC
%
The core of a compartmentalization policy is once again based on memory protection. In the simplest version, 
a function's stack frame and any heap-allocated regions are only accessible by functions within its
compartment. The system keeps track of the active compartment using the PC tag.

In the Tagged C semantics, calls and returns each take two steps: first to an intermediate call
or return state, and
then to the normal execution state, as shown in \cref{fig:functions}.
In the initial call step, \(\calltname\) uses the tag on the function pointer
(typically derived from \(\FN\)) to update the PC Tag. Then, in the step from the call
state, the function arguments are placed in the local store, tagged with
the results of \(\argtname\), and stack locals are allocated. Non-address-taken locals go in the
store as well, tagged with \(\constt\), while locals that must be stack-allocated have memory
allocated and tagged with the results of \(\localtname\). \apt{Is that really how you want to do that? (See previous note re Fig 4.)}
  On return, locals are deallocated, their location tags are 
updated by \(\dealloctname\), and \(\rettname\) updates both the PC Tag and the tag on the returned value,
with access to the original caller's PC Tag.

\begin{figure}
  \begin{tikzpicture}[]
    \node[state]                                      (f)                           {$f$};
    \node[state, inner sep = 0pt, minimum size = 0pt] (call) [above right=of f]     {$\mathcal{C}$};
    \node[state]                                      (g)    [below right=of call]  {$f'$};
    \node[state, inner sep = 0pt, minimum size = 0pt] (ret)  [below right=of f]     {$\mathcal{R}$};
    
    \path[->]
    (f)    edge [bend left] node [pos=0.5,above left] {\(\calltres \leftarrow \callt\)}       (call)
    (call) edge [bend left] node [pos=0.25,above right] {\(\argtres \leftarrow \argt\)}
    node [pos=0.75,above right] {\(\localtres \leftarrow \localt\)} (g)
    (g)    edge [bend left] node [pos=0.5,below right] {\(\dealloctres \leftarrow \dealloct\)}  (ret)
    (ret)  edge [bend left] node [pos=0.5,below left] {\(\rettres \leftarrow \rett\)}  (f);
  \end{tikzpicture}

  \caption{Structure of a function call and return, where $f$ calls $f'$.}
  \label{fig:functions}
\end{figure}

In our compartmentalization policy (\cref{fig:compartments}), we define a tag to be a compartment
identifier or the default \(\N\) tag. The PC Tag always carries the compartment of the
active function, kept up to date by the \(\calltname\) and \(\rettname\) rules.

\begin{figure}
  \begin{minipage}[t]{0.4\textwidth}
    \vspace{-3em}
    \[\color{blue} \tau ::= C | \N\]

    \calltruleblock{\(\PCT' := \mathit{comp}(f')\)}
  
    \rettruleblock{\(\PCT' := \PCT_{CLR};\vt':=\vt\)}
  \end{minipage}
  \begin{minipage}[t]{0.25\textwidth}
    \malloctruleblock{\(\PCT' := \PCT; \pt := \N;\) \\ \(\vt := \N; \lt := \PCT\)}
    \localtruleblock{\(\PCT' := \PCT; \pt := \N;\) \\ \(\vt := \N; \lt := \PCT\)}
  \end{minipage}
  \begin{minipage}[t]{0.25\textwidth}
    \loadtruleblock{\(\mathbf{assert}  \forall \lt \in \overline{\lt} . \PCT = \lt\) \\ \(\vt' := \vt\)}
    
    \storetruleblock{\(\mathbf{assert}  \forall \lt \in \overline{\lt} . \lt = \PCT\) \\
      \(\PCT' := \PCT; \vt' := \N; \lt' := \lt\)}
  \end{minipage}
    
  \caption{Compartmentalization Policy}
  \label{fig:compartments}
\end{figure}

\apt{Misc. complaints: Vectors on $\overline{lt}$ not explained. CLE and CLR not explained. Bracketed outputs in CallT and RetT left over from a previous version?
  Explain MallocT rule (or omit here). Everything in Fig. 7 should be in blue.}


The remainder of the policy works much like memory safety, except that coarse-grained
protection means that the ``color'' we assign to an allocation is the active compartment,
and during a load or store, we compare the location tags to the PC Tag, not the pointer.

\paragraph{Sharing Memory}

\apt{It is not clear what new thing this section teaches us about control points and rules. If there is anything,
be explicit about stating it; if not, perhaps the section does not pull its weight.}

The above policy works if our compartments only ever communicate by passing
non-pointer values. In practice, this is far too restrictive: many library functions 
take pointers and operate on memory shared with the caller. \apt{rest of this paragarph
  has nothing to do with sharing memory per se, and could go up in the intro to the whole
  compartmentalization section.} External libraries are
effectively required for most software to function yet represent a threat. Isolating 
external libraries from critical code prevents vulnerabilities in the library from 
compromising critical code and deprives potential attackers of ROP gadgets and other
tools if there is an exploit in the critical code.

To allow intentional sharing of memory across compartments, a more flexible policy is needed. 
For example, the hostname needs to conform to an expected pattern\apt{??? Need to introduce the example first!}, 
such as in an enterprise network, to differentiate between different classes of
computers (employee, server, contractor, etc). The standard library, 
in its own compartment, has helpful functions, 
provided the caller provides\apt{awk} the buffers from which to set or get the hostname. 

\apt{The role of this example is not clear. Does it, for exmaple, contain both shared and unshared allocations
  in the sense of the scheme below? If so, tie that into the explanation. At the very least, talk through where
you would expect to see failstopping occur.}

\begin{verbatim}
  void configure_enterprise(char* intended_name) {
    int ret = 0;
    char* curr_name = malloc(HOST_NAME_MAX + 1);
    ret = gethostname( &curr_name, HOST_NAME_MAX + 1 );
    if (! ret && !(strcmp(curr_name, intended_name))) {
      ret = sethostname(intended_name, strlen(intended_name));
      ....
    }
    ....
  }
\end{verbatim}

The literature contains two main approaches to shared memory:
{\em mandatory access control} (MAC) and {\em capabilities}.\apt{If you are going to say ``literature'' you need to provide citations!}
MAC explicitly
enumerates the access rights of each compartment, which can include giving two
compartments access to the same memory. Capability systems treat
pointers as unforgeable tokens of privilege, so that the act of passing one
implicitly grants the recipient access.

Tagged C can enforce either; here we will demonstrate a capability approach
in which we distinguish between memory objects that may be passed and those that must not be.
At the syntactic level we separate these by creating a variant identifier for {\tt malloc},
{\tt malloc\_share}. This identifier maps to the same address (i.e., it is still calling the same function)
but its name tag differs and can therefore be used to specialize the tag rule. The source
must have the malloc name changed for every allocation that might be shared.
The annotation could be performed manually, or perhaps automatically using some form
of escape analysis.\apt{This is not a pretty story, and should probably be told more apologetically
  (or at least with a pointer to the limitations section).}

The policy (\cref{fig:sharing}) works by gluing together compartmentalization and memory safety.
The PC Tag carries both the current compartment color, for tagging unshared allocations, and the next free color, for tagging shared allocations.
\(\malloctname\) uses the function tag to determine which color to attach to the pointer and allocated
region. During loads and stores, the location tag of the target address
determines whether access is checked via the identity of the active compartment (for unshared allocations) or
the validity of the pointer (for shared ones).

%\paragraph{Mandatory Access Control}

%Mandatory access control works by associating objects in memory with the compartments that
%are allowed to access them. 

%Mandatory access control requires the policy designer to identity every pair of object
%and compartment that it will be shared with. This may require too much analysis if
%objects are shared widely throughout the system. Conversely, it does not
%distinguish between accesses via a valid pointer and those that are the result of
%UB.

%If a compartment can obtain a shared pointer, we assume that it is allowed to access the associated
%memory. But the access must be performed using that pointer, ruling out other methods such as pointer
%forging.

\begin{figure}
  \begin{minipage}[t]{0.6\textwidth}
    \malloctruleblock
        {let \((C,\clr) := \PCT\) in \\
          \caseoftwo{\(f'\)}
                    {\(\mathtt{malloc}\)}{\(\PCT' := \PCT; \pt := C;\) \\ & & \(\vt := \N; \lt := C\)}
                    {\(\mathtt{malloc\_share}\)}{\(\PCT':= (C,\clr+1);\) \\ & & \(\pt := \clr; \vt := \N';\) \\ & & \(\lt := \clr\)}

        }
  \storetruleblock
        {let \((C,\clr) := \PCT\) in \\
          \(\mathbf{assert}  \exists \lt' . \forall \lt \in \lt . \lt = \lt'\) \\
          \caseoftwo{\(\lt'\)}
                    {\(C'\)}{\(\mathbf{assert}  C = C'\) \\
                      & &  \(\PCT' := \PCT; \vt' := \vt_2; \lt := C\)}
                    {\(\clr\)}{\(\mathbf{assert}  \pt = \clr\) \\
                      & & \(\PCT':= \PCT; \vt' := \vt_2; \lt := \clr\)}}

  \end{minipage}
  \begin{minipage}[t]{0.4\textwidth}
    \vspace{-5em}
    \[\color{blue}
    \tau ::= \N \mid C \mid \clr \mid (C,\clr)\]
    \loadtruleblock
        {let \((C,\clr) := \PCT\) in \\
          \(\mathbf{assert}  \exists \lt' . \forall \lt \in \lt . \lt = \lt'\) \\
          \caseoftwo{\(\lt'\)}
                    {\(C'\)}{\(\mathbf{assert}  C = C'\) \\
                      & &  \(\vt' := \vt\)}
                    {\(\clr\)}{\(\mathbf{assert}  \pt = \clr\) \\
                      & & \(\vt' := \vt\)}}
    \binoptruleblock{
      \caseofthree
          {\((\vt_1, \vt_2)\)}
          {\((\gentag,\N)\)}{\(\vt' := \gentag\)}
          {\((\N,\gentag)\)}{\(\vt' := \gentag\)}
          {\((\clr_1, \clr_2)\)}{\(\vt' := \N\)}
    }

  \end{minipage}

  
  \caption{Compartmentalization with Shared Capabilities}
  \label{fig:sharing}
\end{figure}

%\paragraph{Avoiding Confused Deputies}
%
%[TODO: need a solid example of this]
% compartments are not a silver bullet, incomplete barrier (software compartments, bsd capabilites)
% can pass around and get things written when unexpected
% can use a hardware policy to clamp down on that regardless of the compartmentalization method
% assuming you cant touch the (software) compartment mechaism 
%\subsection{PNVI Memory Safety}
%\label{sec:PNVI}

%[TODO: PNVI needs a lot more motivation, especially given that the security benefits are
%  likely marginal].

%In PNVI, by contrast, an integer cast to a pointer gains the provenance of the object it points
%to when the cast occurs. While PNVI supports a wider range of programs, it is inconsistent with important
%assumptions of the C memory model, in ways that may have serious security consequences.
%The difference between PVI and PNVI is illustrated in Figure \ref{fig:PVI-PNVI}.

%\begin{figure}
%  \includegraphics[width=.6\textwidth]{PVIvsPNVI.png}
%  \caption{Integer-pointer casts in PVI and PNVI}
%  \label{fig:PVI-PNVI}
%\end{figure}

%We will aim to prove that for any program, if it is run in both the PVI semantics
%and in Tagged C with our PVI policy, it either produces identical output, or it is both
%undefined in the PVI semantics and failstops in Tagged C. Likewise for PNVI, except that
%some UB in PNVI is non-deterministic, and we only require that it failstop in an execution
%that would {\it reach} the UB.

%In PNVI, the basic provenance model remains the same as PVI, so we can reuse most of the
%same rules. The primary difference is what happens when we cast a pointer to an integer.
%In PVI, tags are propagated as normal.
%To support PNVI, we need the {\it cast} expression to update the tags of a pointer
%being cast to an integer and vice versa. We add two special-case steps to reflect this.

%\judgmenttwo{\optional{\(\mem[p]_{|ty|} = \_@\vt_2 @ \overline{\lt}\)}}
%            {\(\trule{\picasttres}{\picastt}\)}
%            {\(\defestate{\cast{int}{\val{p}{\pt}}}{\tptr{ty}} \longrightarrow
%              \defestate{\val{p}{vt}}{int}\)}

%\judgmenttwo{\optional{\(\mem[p]_{|ty|} = \_@\vt_2 @ \overline{\lt}\)}}
%            {\(\trule{\ipcasttres}{\ipcastt}\)}
%            {\(\defestate{\cast{int}{\val{p}{\pt}}}{\tptr{ty}} \longrightarrow
%              \defestate{\val{p}{vt}}{int}\)}

%For casting an integer to a pointer, we don't need the optional ``peek'' at the memory that it points to.
%We simply clear the tag on the resulting integer. On the other hand, when casting back to a pointer,
%we need to check the color of the object that it points to.

%\begin{minipage}{0.34\textwidth}
%\[\begin{aligned}
%\truledef{\picastt}
%\settag{\PCT'}{\PCT}
%\settag{\vt}{N}
%\end{aligned}\]
%\end{minipage}
%\begin{minipage}{0.65\textwidth}
%\[\begin{aligned}
%\truledef{\ipcastt}
%\assert{\exists t . \forall \lt \in \overline{\lt} . \lt = t \land t \not = N}
%\settag{\PCT'}{\PCT}
%\settag{\pt}{t}
%\end{aligned}\]
%\end{minipage}

%\paragraph{Realizing the Integer-Pointer Cast}

\apt{read to here.}

\subsection{Secure Information Flow}
\label{sec:SIF}

Our final example policy will be a more realistic version of our first:
{\em secure information flow (SIF)}\cite{Denning77:SecureInformationFlow}, which is part of a larger family of policies
known as {\em information flow control} (IFC). \apt{In fact, one could argue that everything we do with metadata tags is really IFC.}
This family of policies deal entirely with enforcing
higher-level security concerns, regardless of whether the code that they protect contains
errors or undefined behaviors. We will give an example of a single policy in the family.
Our introductory example was an instance of {\em confidentiality}, so now we will discuss
{\em integrity}: preventing insecure input from influencing secure behavior.
In this code, a malformed user input is accidentally appended to an sql query without sanitization:

\begin{verbatim}
void sanitize(char* in, char* out);
void sql_query(char* query, char* res);

void get_data() {
  char[20] name;
  char[20] name_san;
  char[100] query = "select address where name =";
  char[100] res;

  scanf("%19", name);
  sanitize(name, name_san);
  strncat(query, name, strlen(name));
  
  sql_query(query, res);
  printf(res);
}
\end{verbatim}

This function sanitizes its input {\tt name}, then appends the result to an appropriate SQL
query, storing the query's result in {\tt buf}. But the programmer has accidentally
used the unsanitized string! This creates the opportunity for an SQL injection attack: a caller
to this function could (presumably at the behest of an outside user) call it with a
{\tt name} of ``Bobby; drop table;''.

The fact that the input can be sanitized also makes this an {\em intransitive} policy:
information may flow from {\tt scanf} to {\tt sanitize}, and from {\tt sanitize} to
{\tt sql\_query}, but not directly from {\tt scanf} to {\tt sql\_query}.

\begin{figure}

  \begin{minipage}{0.3\textwidth}
    \color{blue}
    \begin{align*}
      \tau ::= & \high \\
      & \low \\
      & \pctaint{f}{d}{Ls} & d \in \mathbb{N},  Ls \in \mathit{list}  id \\
    \end{align*}
  \end{minipage}
  \begin{minipage}{0.69\textwidth}
    \[|\gentag| \triangleq
    \begin{cases}
      \high & \textnormal{if } \gentag = \high \textnormal{ or } \gentag = \pctaint{f}{0}{\varepsilon} \\
      \low & \textnormal{otherwise} \\
    \end{cases}\]
    %
    \[\gentag_1 \sqcap \gentag_2 \triangleq
    \begin{cases}
      \high & \textnormal{if } |\gentag_1| = |\gentag_2| = \high \\
      \low & \textnormal{otherwise} \\
    \end{cases}\]
  \end{minipage}

  \begin{minipage}{0.54\textwidth}
    \storetruleblock
        {let \(\pctaint{f}{d}{Ls} := \PCT\) in \\
          \(\PCT' := \PCT\) \\
          \(\lt' := \lt\) \\
          \caseofthree{\(f\)}
                      {\(\mathtt{scanf}\)}{\(\vt':=\low\)}
                      {\(\mathtt{sanitize}\)}{\(\vt':=\high\)}
                      {\(\underline{\hspace{3em}}\)}
                      {\(\vt' := \PCT \sqcap \vt \sqcap \pt\)}}
  \end{minipage}
  \begin{minipage}{0.45\textwidth}
    \loadtruleblock
        {let \(\pctaint{f}{d}{Ls} := \PCT\) in \\
          \caseoftwo{\(f\)}
                    {\(\mathtt{sql\_query}\)}{\(\mathbf{assert}  \vt \sqcap \pt = \high\) \\ & & \(\vt' := \vt\)}
                    {\(\underline{\hspace{3em}}\)}{\(\vt' := \vt\)}}

    \binoptruleblock{\(\vt' := \vt_1 \sqcap \vt_2\)}
  \end{minipage}

\caption{SIF Policy: Tags and Selected Rules}
\label{fig:sif1}
\end{figure}

Since we care about a single source, we can once again use a pair of \(\high\)
and \(\low\) tags, although in this case we aim to prevent \(\low\)-integrity
data from flowing to \(\high\)-integrity locations.
We additionally need to carry significant information on the PC Tag,
so we define a third type of tag with the constructor {\sc \color{blue} pc},
which carries (1) the current function identifier, (2) a natural number to record
a count of tainted expression scopes, and (3) a stack of label identifiers to record
the join points of tainted statement scopes. We will discuss (2) and (3) in detail below.
Initially, the PC Tag is \(\pctaint{f}{0}{\varepsilon}\).

Selected tag rules for expressions are given in \cref{fig:sif1}. We define two operators on tags:
the ``join'' operator \(\sqcap\) takes the higher of two security levels, and the ``reduce''
operator \(| \cdot |\) converts a PC Tag into a security level, \(\high\) or \(\low\).
The function {\tt scanf} taints all of its writes by marking them \(\low\). This extends to
its return value in \(\rettname\) as well (not shown.) By the same token, all outputs of
{\tt sanitize} are tagged \(\low\), so that when it copies \(\high\)-tagged data into its
output buffer, we consider those data safe.

In this scenario, our policy aims to prevent {\tt sql\_query} from recieving tainted data.
For this reason, we failstop if {\tt sql\_query} would load a \(\low\) value.

\paragraph*{Implicit Flows}

\begin{figure}[t]
  \begin{subfigure}{0.4\textwidth}
\begin{verbatim}
int f(bool secret) {
    int public1, public2;

S:  if (secret) {
b1:     public1 = 1;
    } else {
b2:     public1 = 0;
    }

J:  public2 = 42;
    return public2;
}
\end{verbatim}
  \end{subfigure}
  \begin{subfigure}{0.6\textwidth}
    \begin{tikzpicture}
      [ initial text={}, initial distance=4em,
        accepting/.style=accepting by arrow,
        accepting distance=4em
      ]
      \node[state,initial]    (S)                        {$S$};
      \node[state]            (b_1) [above right=of S]   {$b_1$};
      \node[state]            (b_2) [below right=of S]   {$b_2$};
      \node[state,accepting]  (J)   [below right=of b_1] {$J$};

      \path[->] (S)   edge              node  {}  (b_1)
                      edge              node  {}  (b_2)
                (b_1) edge              node  {}  (J)
                (b_2) edge              node  {}  (J);
    \end{tikzpicture}
  \end{subfigure}
\caption{Leaking via if statements}
\label{fig:ifthenelse}  
\end{figure}

Things become trickier when we consider that the program's control-flow itself can be tainted.
This can occur in any conditional, including loops, conditional statements, and conditional expressions.
In general, anytime a ``split'' is conditioned on a tainted value, subsequent assignments must also be tainted.
An example can be seen in \cref{fig:ifthenelse}, where labels in the code indicate the split
point, branches, and {\em join point} \(J\).

A join point is the node in the program's control-flow graph where all possible routes
from the split to a return have re-converged; its its immediate post-dominator \cite{}.
[TODO: this is the Denning cited in Bay and Askarov] At this point, an observer can no
longer deduce which path execution took, except through the assignments that happened
in \(b_1\) or \(b_2\), which are already tainted. It is therefore safe to tag future
assignments \(\low\). In the example, {\tt public1} should be tagged \(\low\), while
{\tt public2} is tagged \(\high\).

This is where the other components of the PC Tag come into play. We perform a program
transformation introducing the labels of all join points explicitly, so that in
\cref{fig:ifthenelse}, {\tt J} is an explicit label in the code, if it wasn't already.
We introduce an internal form of each conditional statement
(if, switch, while, do-while, and for) that takes as an extra parameter the label of
that conditional's join point. As seen in \cref{fig:SIFconditionals}, the
\(\splittname\) tag rule takes this label as an optional parameter and, if
the conditional branches on a low value, pushes the join point to the stack.
Then the \(\labeltname\) rule checks if execution has reached a join point and
if it has, removes it from the stack. A PC Tag can only reduce to \(\high\)
if its stack is empty.

Branching expressions work similarly, except that the join point occurs at a different
internal expression form: the parenthetical expression. For example, the expression
{\tt 1 ? a : b} reduces to the parenthetical {\tt (a)}. The \(\exprjointname\) rule
applies when {\tt a} is fully reduced and the semantics throw away the parentheses.
Because expressions are nested, we only need to keep track of how deep execution has
gone since the first time it branched on a \(\low\) value, by incrementing and decrementing
the depth \(d\). \(\exprjointname\) also tags the result of the expression.

We assume a {\em termination-insensitive} setting \cite{Askarov08:TINILeaks}, in which
we allow an observer to glean information by the termination or non-termination of
the program. This is a necessary limitation of an enforcement mechanism that halts
execution. Having accepted this limitation, we may apply the same analysis to loops
as well as conditionals.

\begin{figure}
  \begin{minipage}{0.55\textwidth}
    \splittruleblock{
      \caseoftwo{\(\PCT, \vt\)}
                {\(\pctaint{f}{d}{Ls}, \low\)}{\(\PCT' := \pctaint{f}{e}{(L::Ls)}\)}
                {\(\underline{~}, \high\)}{\(\PCT' := \PCT\)}
    }
    \labeltruleblock{
      \caseoftwo{\(\PCT\)}
                {\(\pctaint{f}{d}{Ls}\)}{
                  let \({\color{blue} Ls'} = \mathit{pop\_all}  {\color{blue} \LN  Ls}\) in \\
                  & &      \(\PCT' := \pctaint{f}{d}{Ls'}\)
                }
                {\(\underline{~}\)}{\(\PCT' := \PCT\)}
    }
  \end{minipage}
  \begin{minipage}{0.35\textwidth}
    \exprsplittruleblock{
      \caseoftwo{\(\PCT, \vt\)}
                {\(\pctaint{f}{d}{Ls}, \low\)}{\(\PCT' := \pctaint{f}{(d+1)}{Ls}\)}
                {\(\underline{~}, \high\)}{\(\PCT' := \PCT\)}
    }

    \exprjointruleblock{
      \(\vt' := \vt \sqcap \PCT\) \\
      \caseoftwo{\(\PCT\)}
                {\(\pctaint{f}{(d+1)}{Ls}\)}{\(\PCT' := \pctaint{f}{d}{Ls}\)}
                {\(\underline{~}\)}{\(\PCT' := \PCT\)}
    }
  \end{minipage}
  
  \caption{SIF Conditionals}
  \label{fig:SIFconditionals}
\end{figure}

Of course, code does not generally come with labeled join points, and they must be associated
with their split points. We introduce additional forms of the if, while, do-while, for, and switch
statements which carry an additional label, and perform some preprocessing to associate these
with new labels in the source code. This preprocessing step generates the program's
control flow graph and, for each branch, identifies its immediate post-dominator. That
node is labeled with  a fresh identifier, and the same identifier is added to the original
conditional statement.

%\begin{figure}
%  \begin{subfigure}{0.49\textwidth}
%\begin{verbatim}
%int f(bool secret) {
%    int public1=1;
%    int public2;
%
%S:  while (secret) {
%b1:     public1 = 1;
%        secret = false;
%    }
%
%J:  public2 = 42;
%
%    return public2;
%}
%\end{verbatim}
%  \caption{Leaking via while statements}
%  \label{fig:while}
%  \end{subfigure}
%  \begin{subfigure}{0.5\textwidth}
%    \begin{tikzpicture}
%      [ initial text={}, initial distance=4em,
%        accepting/.style=accepting by arrow,
%        accepting distance=4em
%      ]
%      \node[state,initial]    (S)                        {$S$};
%      \node[state]            (b_1) [above right=of S]   {$b_1$};
%      \node[state,accepting]  (J)   [below right=of b_1] {$J$};

%      \path[->] (S)   edge               node  {}  (b_1)
%                      edge               node  {}  (J)
%                (b_1) edge [bend right] node  {}  (S);
%    \end{tikzpicture}
%  \end{subfigure}
%  
%\end{figure}

%\begin{figure}
%  \begin{subfigure}{0.25\textwidth}
%\begin{verbatim}
%int f(bool secret) {
%    int public1, public2;

%    while (secret) {
%        goto b1;
%    }

%b2: public1 = 1;
%    goto J;

%b1: public1 = 1;

%J:  public2 = 42;
%    return public2;
%}
%\end{verbatim}
%  \end{subfigure}
%  \begin{subfigure}{0.74\textwidth}
%    \begin{tikzpicture}
%      [ initial text={}, initial distance=3em,
%        accepting/.style=accepting by arrow,
%        accepting distance=3em
%      ]
%      \node[state,initial]    (S)                              {$S$};
%      \node[state]            (inside) [above right=of S]      {};
%      \node[state]            (b_2)    [below right=of inside] {$b_2$};
%      \node[state]            (b_1)    [right=of b_2]          {$b_1$};
%      \node[state,accepting]  (J)      [right=of b_1]          {$J$};

%      \path[->] (S)   edge              node  {}  (inside)
%                      edge              node  {}  (b_2)
%                (inside) edge [bend left] node {} (b_1)
%                (b_1) edge              node  {}  (J)
%                (b_2) edge [bend right] node  {}  (J);
%    \end{tikzpicture}
%  \end{subfigure}
  
%  \caption{Cheating with go-tos}
%  \label{fig:forbreak}
%\end{figure}
%\begin{figure}
%  \begin{subfigure}{0.3\textwidth}
%    \begin{tikzpicture}
%      [ initial text={}, initial distance=1em,
%        accepting/.style=accepting by arrow,
%        accepting distance=1em
%      ]
%      \node[state,initial]    (do)                             {do};
%      \node[state,accepting]  (S) [right=of do]                {\(S\):test};

%      \path[->] (do)   edge              node  {}  (S)
%                (S)    edge [bend left]  node  {}  (do);
%    \end{tikzpicture}
%    \subcaption{Do-while}
%  \end{subfigure}
%  \begin{subfigure}{0.3\textwidth}
%    \begin{tikzpicture}
%      [ initial text={}, initial distance=1em,
%        accepting/.style=accepting by arrow,
%        accepting distance=1em
%      ]
%      \node[state,initial]    (init)                             {init};
%      \node[state,accepting]  (S)    [right=of init]             {\(S\):test};
%      \node[state]            (do)   [above=of S]                {do};
%      \node[state]            (post) [left=of do]                {post};
      
%      \path[->] (init)   edge              node  {}  (S)
%                (S)      edge              node  {}  (do)
%                (do)     edge              node  {}  (post)
%                (post)   edge              node  {}  (S);
%    \end{tikzpicture}
%    \subcaption{For}
%  \end{subfigure}
%  \begin{subfigure}{0.3\textwidth}
%    \center
%    \begin{tikzpicture}
%      [ initial text={}, initial distance=1em, initial above,
%        accepting/.style=accepting by arrow,
%        accepting distance=1em, node distance=2em, inner sep=1pt
%      ]
%      \node[state,initial]    (switch)                           {\(S\):switch};
%      \node[state]            (case1)    [below left=of switch]  {};
%      \node[state]            (case2)    [right=of case1]        {};
%      \node[state]            (default)  [right=of case2]        {def};
%      \node                   (after)    [right=of default]      {};

%      \path[->] (switch)  edge              node  {}  (case1)
%                          edge              node  {}  (case2)
%                          edge              node  {}  (default)
%                (default) edge              node  {}  (after)
%                (case1)   edge [bend right] node  {}  (after)
%                (case2)   edge [bend right] node  {}  (after);

%      \path[dotted,->] (case1) edge              node  {}  (case2)
%                (case2) edge              node  {}  (default);
                         
%    \end{tikzpicture}
%    \subcaption{Switch}
%  \end{subfigure}
  
%  \caption{Remaining Branch Statements}
%  \label{fig:rest}
%\end{figure}


\section{Implementing Tagged C with PIPE}
\label{sec:optionals}

Chhak et al. \cite{Chhak21:Tagine} introduce a verified compiler from a toy
high-level language with tags
to a control-flow-graph-based intermediate representation of a PIPE-based
ISA. It is a proof-of-concept of compilation from a source language's tag policy to
realistic hardware. Everything in a PIPE system carries tags, including instructions. 
Instruction tags are statically determined at compile-time, so they can carry data about source-level
control points in the corresponding assembly. This means that PIPE can emulate any given Tagged C
policy by running two policies in parallel: a basic stack-and-function-pointer-safety policy to mimic Tagged C's
high-level control-flow, and the source-level policy as written.

Chhak et al.'s general strategy for mapping Tagged C's tag rules sometimes requires adding extra
instructions to the generated code. A Tagged-C control point
may require a tag from a location that is not read under a normal compilation scheme, or must update tags
in locations that would otherwise not be written. Such instructions are unnecessary overhead if the policy
doesn't meaningfully use the relevant tags.

To mitigate this, control points whose compilation would add potentially extraneous instructions
take optional parameters or return optional results. We will explain how the rule should be
implemented in the target if the options are used.
Optional inputs and outputs are marked with boxes. If a policy does not make use of the options, it will
be sound to compile without the extra instructions.

\section{Evaluation}
\label{sec:evaluation}

Tagged C aims to combine the flexibility of tag-based architectures with the abstraction
of a high-level language. How well have we achieved this aim?

[Here we list criteria and evaluate how we fulfilled them]

\begin{itemize}
\item Flexibility: we demonstrate three policies that can be used alone or in conjunction
\item Applicability: we support the full complement of C language features and give definition
  to many undefined C programs
\item Practical security: our example security policies are based on important security concepts
  from the literature
\end{itemize}

\subsection{Limitations}

By committing to a tag-based mechanism, we do restrict the space of policies that Tagged C
can enforce. In general, a reference monitor can enforce any policy that constitutes a
{\em safety property}---any policy whose violation can be demonstrated by a single finite
trace. This class includes such policies as ``no integer overflow'' and ``pointers are always in-bounds,''
which depend on the values of variables. Tag-based monitors cannot enforce any policy that
depends on the value of a variable rather than its tags.

Due to our approach to tagging memory uniformly at allocation time, Tagged C cannot easily
enforce substructural memory safety. Versions of memory safety that protect fields of a
struct from overflows within the same struct would be very useful, but currently enforcing
them will require manual initialization.

Beyond these, there is always the possibility that we have missed some control point
that would enable interesting security policies outside of the areas we have considered.
How hard would it be to add control points, or extend the ones that exist? That depends
whether the extension in question would impact compilation strategies. For instance,
we have avoided control points that allow updates to their operand tags, although
this could be useful in enforcing policies that attempt to maintain the uniqueness of tags,
because tag-based hardware is unlikely to support linear tags, so any such updates would
need the compiler to generate extra instructions.

\section{Related Work}

\paragraph{Reference Monitors}

The concept of a reference monitor was first introduced fifty years ago in \cite{Anderson72:PlanningStudy}:
a tamper-proof and verifiable subsystem that checks every security-relevant operation in a system to
ensure that it conforms to a security {\em policy} (a general specification of acceptable behavior;
see \cite{Goguen82:SecurityPolicies}.)

A reference monitor can be implemented at any level of a system. An {\em inline reference monitor}
is a purely compiler-based system that inserts checks at appropriate places in the code.
Alternatively, a reference monitor might be embedded in the operating system, or in an interpreted
language's runtime. A {\em hardware reference monitor} instead provides primitives at the ISA-level
that accelerate security and make it harder to subvert.

Programmable Interlocks for Policy Enforcement (PIPE) \cite{Dhawan14:PUMP} is a hardware extension
that uses {\em metadata tagging}. Each register and each word of memory is associated with
an additional array of bits called a tag. The policy is decomposed into a set of {\em tag rules}
that act in parallel with each executing instruction, using the tags on its operands to
decide whether the instruction is legal and, if so, determine which tags to place on its results.
PIPE tags are large relative to other tag-based hardware, giving it the flexibility
to implement complex policies with structured tags, and even run multiple policies at once.

Other hardware monitors include Arm MTE, [Binghamton], and CHERI.
Arm MTE aims to enforce a narrow form of memory safety using 4-bit tags, which distinguish adjacent objects
in memory from one another, preventing buffer overflows, but not necessarily other memory violations.
[TODO: read the Binghamton paper, figure out where they sit here.] 

CHERI is capability machine [TODO: cite OG CHERI]. In CHERI, capabilities
are ``fat pointers'' carrying extra bounds and permission information, and capability-protected
memory can only be accessed via a capability with the appropriate privilege. This is a natural
way to enforce spatial memory safety, and techniques have been demonstrated for enforcing
temporal safety \cite{NWF20:Cornucopia}, stack safety \cite{Skorstengaard19:stktokens},
and compartmentalization [TODO: figure out what to cite], with varying degrees of ease and
efficiency. But CHERI cannot easily enforce notions of security based on dataflow,
such as Secure Information Flow.

In this paper, we describe a programming language with an abstract reference monitor.
We realize it as an interpreter with the reference monitor built in, and envision
eventually compiling to PIPE-equipped hardware. An inlining compiler would also be plausible.
As a result of this choice, our abstract reference monitor uses a PIPE-esque notion of
tags.

\paragraph{Aspect Oriented Programming}

[TODO: do forward search from original AOP paper]

\section{Future Work}
\label{sec:futurework}

We have presented the language and a reference interpreter, built on top of the CompCert interpreter
\cite{Leroy09:CompCert}, and three example policies. There are several significant next-steps.

\paragraph{Compilation}

An interpreter is all well and good, but a compiler would be preferable for many reasons.
A compiled Tagged C could use the hardware acceleration of a PIPE target, and could more easily
support linked libraries, including linking against code written in other languages.
The ultimate goal would be a fully verified compiler, but that is a very long way off.

\paragraph{Language Proofs}

There are a couple of properties of the language semantics itself that we would like to prove.
Namely (1) that its behavior (prior to adding a policy) matches that of CompCert C and
(2) that the behavior of a given program is invariant under all policies up to truncation due
to failstop.

\paragraph{Policy Correctness Proofs}

For each example policy discussed in this paper, we sketched a formal specification for the
security property it ought to enforce. A natural continuation would be to prove the correctness
of each policy against these specifications.

\paragraph{Policy DSL}

Currently, policies are written in Gallina, the language embedded in Coq. This is fine for a
proof-of-concept, but not satisfactory for real use. We plan to develop a domain-specific policy
language to make it easier to write Tagged C policies.

\bibliographystyle{splncs04}
\bibliography{taggedc.bib}

\appendix

\section{Syntax}

Tagged C has the full complement of typical C expressions (\cref{fig:expr}). \(\val{v}{\vt}\),
\(\loc{p}{\pt}\), and \(\paren{\expr}{\type}\) are internal forms.
A constant \(c\) in the concrete syntax is transformed into \(\val{c}{\constt}\),
and in general \(\val{v}{\vt}\) is a fully-reduced right-hand value. \(\loc{p}{\pt}\)
is a fully-reduced left-hand value that represents the address of a variable.
\(\paren{\expr}{\type}\) is the result of a conditional or shortcutting
expression, with \(\ty\) being a type annotation in case the result needs to
be cast.

\begin{figure}
  \[\begin{aligned}
  \expr ::= & \val{v}{\vt} & \textnormal{Value} \\
  | & \var{x} & \textnormal{Variable} \\
  | & \field{\expr}{id} & \textnormal{Field} \\
  | & \valof{\expr} & \textnormal{Load from Object} \\
  | & \deref{\expr} & \textnormal{Dereference Pointer} \\
  | & \addrof{\expr} & \textnormal{Address of Object} \\
  | & \unop{\odot}{\expr} & \textnormal{Unary Operator} \\
  | & \binop{\oplus}{\expr_1}{\expr_2} & \textnormal{Binary Operator} \\
  | & \cast{\expr}{ty} & \textnormal{Cast} \\
  | & \condition{\expr_1}{\expr_2}{\expr_3} & \textnormal{Conditional} \\
  | & \sizeof{ty} & \textnormal{Size of Type} \\
  | & \alignof{ty} & \textnormal{Alignment of Type} \\
  | & \assign{\expr_1}{\expr_2} & \textnormal{Assignment} \\
  | & \assignop{\oplus}{\expr_1}{\expr_2} & \textnormal{Operator Assignment} \\
  | & \postinc{\oplus}{\expr} & \textnormal{Post-Increment/Decrement} \\
  | & \comma{\expr_1}{\expr_2} & \textnormal{Expression Sequence} \\
  | & \call{\expr_f}{\overline{\expr}_{args}} & \textnormal{Function Call} \\
  | & \loc{l}{\lt} & \textnormal{Memory Location} \\
  | & \paren{\expr}{ty}{\gentag} & \textnormal{Parenthetical with Optional Cast} \\
  \end{aligned}\]
  \caption{Expression Syntax}
  \label{fig:expr}
\end{figure}

Some common C expressions are derived forms. An array index expression,
\(\expr_1[\expr_2]\) expands to \(\deref{\binop{+}{\expr_1}{\expr_2}}.
The pre-increment  expression \(++\expr\) expands to
\(\assign{\expr}{\binop{+}{\expr}{1@\constt}}\), and likewise for pre-decrement.

Similarly, statements cover the full C standard. Conditional statements
carry optional labels as internal forms, so that an if statement in the
concrete syntax becomes \(\sifthenelse{\expr}{\stmt_1}{\stmt_2}{\bot}\).

\begin{figure}
  \begin{subfigure}[t]{0.3\textwidth}
    \[\begin{aligned}
    \stmt ::= & \sskip \\
    | & \sdo{\expr} \\
    | & \sseq{\stmt_1}{\stmt_2} \\
    | & \sifthenelse{\expr}{\stmt_1}{\stmt_2}{L} \\
    | & \swhile{\expr}{\stmt}{L} \\
    | & \sdowhile{\expr}{\stmt}{L} \\
    | & \sfor{\stmt_1}{\expr}{\stmt_2}{\stmt_3} \\
    | & \sbreak \\
    | & \scontinue \\
    | & \sreturn \\
    | & \sswitch{\expr}{\overline{(L,\stmt)}} \\
    | & \slabel{L}{\stmt} \\
    | & \sgoto{L} \\    
    \end{aligned}\]
  \end{subfigure}
  \begin{subfigure}[t]{0.69\textwidth}
  \end{subfigure}
  \caption{Tagged C Abstract Syntax}
  \label{fig:syntax}
\end{figure}

\section{States}

States can be of several kinds, denoted by their script prefix: a {\em general state} \(\mathcal{S}(\dots)\),
an {\em expression state} \(\mathcal{E}(\dots)\), a {\em call state} \(\mathcal{C}(\dots)\), or a
{\em return state} \(\mathcal{R}(\dots)\). Finally, the special state {\em failstop} (\(\mathcal{F}(\dots)\))
represents a tag failure, and carries the state that produced the failure.
[Allison: to whatever degree you've figured out what is useful here by publication-time, we can
  tune this to be more specific.]

In the below definition, memories are ranged over by \(\mem\), local environments by
\(\lenv\), and continuations by \(\cont\).

\[\begin{aligned}
S ::= & \sstate{\PCT}{\mem}{\stmt}{\cont} \\
| & \estate{\PCT}{\mem}{\expr}{\cont} \\
| & \cstate{f}{\PCT}{\mem}{\lenv}{f'}{\overline{\val{v}{\vt}}}{\cont} \\
| & \rstate{\PCT}{\mem}{\genv}{\lenv}{\val{v}{\vt}}{\cont} \\
| & \fstate{S} \\
\end{aligned}\]


States in general contain a memory, a local environment, and a continuation.

\subsection{Memories}

\subsection{Environments}

\subsection{Continuations}
\label{app:continuations}

A continuation acts like a stack of pending operations. The base of the stack is
\(\kemp\). \(\mathit{Kdo}\) indicates that a do statement is evaluating an expression.
\(\mathit{Kseq}\) with parameter \(\stmt\) indicates that, after the current statement
is done executing, \(\stmt\) is next. \(\mathit{Kif}\) means that execution is evaluating
the test expression of an if statement, and its parameters are the branches of the
if. Similarly, the test continuations for while, do-while, and for loops indicate that
the test expression is being evaluated. The associated loop continuations indicate that
execution is in the loop body. They continuations carry all of the information of the original
loop.

\[\begin{split}
\cont ::= & \kemp \\
| & \kdo{\cont} \\
| & \kseq{\stmt}{\cont} \\
| & \kif{\stmt_1}{\stmt_2}{L}{\cont} \\
| & \kwhiletest{\expr}{\stmt}{L}{\cont} \\
| & \kwhileloop{\expr}{\stmt}{L}{\cont} \\
| & \kdowhiletest{\expr}{\stmt}{L}{\cont} \\
| & \kdowhileloop{\expr}{\stmt}{L}{\cont} \\
| & \kfor{\expr}{\stmt_2}{\stmt_3}{L}{\cont} \\
| & \kforpost{\expr}{\stmt_2}{\stmt_3}{L}{\cont} \\
\end{split}\]


\section{Initial State}

Given a list \(xs\) of variable identifiers \(id\) and types
\(ty\), a program's initial memory is defined by iteratively allocating each one
in memory and updating the global environment with its base address, bound, type,
and a static identity tag. Let \(|ty|\) be a function from types to their sizes
in bytes. The memory is initialized \(\vundef@\vt@\overline{\lt}\)
for some \(\vt\) and \(\overline{\lt}\), unless given an initializer.
Let \(\mem_0\) and \(\genv_0\) be the initial (empty) memory and environment.
The parameter \(b\) marks the start of the global region.

%Since we don't need to initialize tags in memory dynamically, our rule for
%selecting these tags can cover the entire initialization of the memory with arbitrary
%granularity. We represent this as a list of tags of length \(|ty|\).

\[\mathit{globals}  xs  b =
\begin{cases}
  (\mem_0, \genv_0) & \textnormal{if } xs = \varepsilon \\
  (\mem[p \dots p+|ty| \mapsto \vundef@\vt@\overline{\lt}]_{|ty|}, & \textnormal{if } xs = (id,ty)::xs' \\
   \genv[id \mapsto (\mathit{p, p+|ty|,ty,\pt})]) & \textnormal{and } \trule{\globaltres}{\globalt} \\
  & \textnormal{where } (\mem,\genv) = \mathit{globals}  xs'  (b + |ty|) \\
\end{cases}\]

\section{Step Rules}
\label{app:rules}

\subsection{Sequencing rules}

\sequencing

\subsection{Conditional rules}

\conditionals

\subsection{Loop rules}

\loops

\subsection{Contexts}
\label{app:contexts}

Our expression semantics are contextual. A context \(\ctx[\expr]_k\) is a function from an
expression to an expression, with a ``kind'' flag \(k\) (left-hand or right-hand, \(\lh\) or \(\rh\)).

\[\begin{aligned}
\ctx{\expr}_\lh ::= \\
| & \expr & \\ % ctx_top
| & \deref{\ctx{\expr}_\rh} \\ % ctx_deref
| & \field{\ctx{\expr}_\rh}{id} \\ % ctx_field
\end{aligned}\]

\[\begin{aligned}
\ctx{\expr}_\rh ::= \\
| & \expr & \\ % ctx_top
| & \valof{\ctx{\expr}_\lh} \\ % ctx_rvalof
| & \addrof{\ctx{\expr}_\lh} \\ % ctx_addrof
| & \unop{\odot}{\ctx{\expr}_\rh} \\ % ctx_unop
| & \binop{\oplus}{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_binop_left
| & \binop{\oplus}{\expr_1}{\ctx{\expr_2}_\rh} \\ % ctx_binop_right
| & \cast{\ctx{\expr}_\rh}{\type} \\ % ctx_cast
| & \seqand{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_seqand
| & \seqor{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_seqor
| & \condition{\ctx{\expr_1}_\rh}{\expr_2}{\expr_3} \\ % ctx_condition
| & \assign{\ctx{\expr_1}_\lh}{\expr_2} \\ % ctx_assign_left
| & \assign{\expr_1}{\ctx{\expr_2}_\rh} \\ % ctx_assign_right
| & \assignop{\oplus}{\ctx{\expr_1}_\lh}{\expr_2} \\ % ctx_assignop_left
| & \assignop{\oplus}{\expr_1}{\ctx{\expr_2}_\rh} \\ % ctx_assignop_right
| & \postinc{\oplus}{\ctx{\expr}_\lh} \\ % ctx_postinc
| & \call{\ctx{\expr_1}_\rh}{\overline{\expr_2}} \\ % ctx_call_left
| & \call{\expr_1}{\ctx{\overline{\expr_2}}_\rh} \\ % ctx_call_right
% skipped builtins
| & \comma{\ctx{\expr_1}_\rh}{\expr_2} \\ % ctx_comma
| & \paren{\ctx{\expr}_\rh}{\type}{} \\ % ctx_paren
\end{aligned}\]

A left-hand reduction \(\expr \Rightarrow_\lh \expr'\)
relates an expression to an expression. A right-hand reduction
\((\PCT,\mem,\expr) \Rightarrow_\rh (\PCT',\mem',\expr')\)
relates a triple of PC Tag, memory, and expression to another such triple.
Given these reduction relations, we construct step rules for contexts in
expressions.

%triple of a memory, an expression, and a tag
%might reduces to another such triple as a left-hand, right-hand, or call reduction, written
%\((\mem, \expr, \PCT) \Rightarrow_k (\mem', \expr', \PCT')\),
%based on rules given below. These reductions are embedded in states as follows.

\judgmenttwo{\(\ctx{\expr}_\lh\)}
            {\(\expr \Rightarrow_\lh \expr'\)}
            {\(\defestate{\ctx{\expr}} \longrightarrow \defestate{\ctx{\expr'}}\)}

\judgmenttwo{\(\ctx{\expr}_\rh\)}
            {\((\PCT, \mem, \expr) \Rightarrow_\rh (\PCT', \mem', \expr')\)}
            {\(\defestate{\ctx{\expr}} \longrightarrow \estate{\PCT'}{\mem'}{\ctx{\expr'}}{\cont}\)}
            
All that remains is to give the expression reductions themselves.

\expressions

\subsection{Call and Return Rules}

In order to make a call, we need to reduce the function expression to an \(\floc{\_}\) value, an
abstract location corresponding to a particular function. Then we can make the call.

\callexprstep

When we make an internal call, we need to allocated space for locals and arguments using the helper function
\(\mathit{frame}\).

\[\mathit{frame}  xs  as  \mem =
\begin{cases}
  (\mem''[p \mapsto \vundef@\vt@\overline{\lt}]_{|ty|}, & \textnormal{if } xs = (id,ty)::xs' \\
  \lenv'[id \mapsto (\mathit{p, p+|ty|,ty,\pt})]) &
  \textnormal{where } (\mem',p) \leftarrow \mathit{stack\_alloc}  |ty|  \mem, \\
  & \trule{\localtres}{\localt}, \\
  & \textnormal{and } (\mem'',\lenv') = \mathit{frame}  xs'  as  m' \\ 
  \\
  (\mem''[p \mapsto v@\vt'@\overline{\lt}]_{|ty|}, & \textnormal{if } as = (id,ty,v @ \vt)::as' \textnormal{ and } xs = \varepsilon \\
  \lenv'[id \mapsto (\mathit{p, p+|ty|,ty,\pt})]) &
  \textnormal{where } (\mem',p) \leftarrow \mathit{stack\_alloc}  |ty|  \mem, \\
  & \trule{\argtres}{\argt}, \\
  & \textnormal{and } (\mem'',\lenv') = \mathit{frame}  xs'  as  m' \\
  \\
  (\mem, \lambda x . \bot) & \textnormal{if } xs = \varepsilon \textnormal{ and } as = \varepsilon \\
\end{cases}\]

\callstep

On the other hand, when we make an external call, we step directly to a return state with some value
being returned and an updated memory. [TODO: talk more about how the tag policy applies in external
  functions, what they can and can't do with tags.]

\extcallstep

Special external functions, such as malloc, just get their own rules.

\mallocstep

And finally, we have the return rules.

\returnstep
\retvalstep
\retnovalstep

%\section{Moved from Intro}

%\sna{I'm organizing our diss tracks into paragraphs that we can cut or move as needed}
%\paragraph*{Why Dynamic?}
  
%  Unfortunately, it is not always possible to fully secure C code before run-time.
%  Ideally, bugs would be quickly identified and then fixed promptly. 
%  That is not always possible for a variety of reasons: bugs may escape detection, 
%  require significant effort to diagnose, or be impractical to fix. 
%  There are many techniques for finding bugs, but there is a shared stumbling block: C is not 
%  well defined. We cannot always agree on when something is a bug in C, especially code using
%  Undefined Behaviors (UB) \cite{defactoC}. Confusion around expected behavior is no small problem. 
%  There are 191 undefined behaviors and 52 unspecified behaviors in the C99 
%  specification \cite{Csmith}. Sometimes these behaviors are benign and skillfully 
%  used by the developer, other times they are unintended and highly dangerous. 
%  Unfortunately the distinction between the two is easily lost. 
%  Discerning expert code review is considered best practice, although it is 
%  rarely perfectly successful \cite{} % https://dl.acm.org/doi/10.1007/978-3-642-36563-8_14 }
%  even if an expert is available at all. Even when there is both consensus 
%  and detection of a bug\apt{??} \amn{we can find it at and we can agree its a problem that should be fixed}, 
%  changing the code may not be possible because  
%  it is in proprietary 3rd party libraries and drivers, or because
%  regulations prohibit changes \cite{Bessey10:Coverity}.

%  \apt{last clause is mysterious} \amn {
%    for example FDA approval used to forbid patching because you'd have to go through recertification. 
%    So healthcare wouldn't patch. SNA pointed out the coverity paper comments on this as a reason for 
%    bugs not getting fixed}

%  \paragraph*{Why C-Level?}
%  Tag-based enforcement in general has a significant body of work at the assembly level, especially
%  PIPE (Programmable Interlocks for Policy Enforcement) \cite{}. However, even at the assembly-level
%  these systems need the compiler to be in the trusted computing base (TCB), as many policies require
%  knowledge of source-level constructs, even ones that do not depend on detailed knowledge of the program's
%  behavior [cite Nick and Andre; anyone else?]. Moving policy-definition to the source level therefore
%  does not expand the TCB and allows C developers to reason about policies in terms of the language that
%  they program in regularly.

%  \paragraph*{Notations}
%  Values are ranged over by \(v\), variable identifiers by \(x\), and function identifiers by \(f\).
%Tags use a number of metavariables: \(t\) ranges over all tags, while we will use
%\(\vt\) to refer to the tags associated with values, \(\pt\) for tags on pointer values
%and memory-location expressions, \(\lt\) for tags associated with memory locations themselves,
%\(\nt\) for ``name tags'' automatically derived from identifiers, \(\PCT\) for the
%global ``program counter tag'' or PC Tag.
%An {\it atom} is a pair of a value and a tag, \(\val{v}{\vt}\); the @ symbol should be read
%as a pair in general, and is used when the second object in the pair is a tag.
%Expressions are ranged over by \(\expr\), statements by \(\stmt\), and continuations by \(\cont\).
%The continuations are defined in \cref{app:continuations}, and step rules in \cref{app:rules}.

%A memory is an array of bytes, where each byte is part of an atom.
%Each byte is also associated with a ``location tag'' \(\lt\). When a contiguous region of \(s\) bytes
%starting at location \(l\) comprise an atom \(v@\vt\), and their locations tags comprise the list \(\lts\),
%we write \(\mem[l]_s = v@\vt @\lts\). Likewise, \(\mem[l \dots l + s \mapsto v@\vt @ \lts]_s\)
%denotes storing that many bytes. Visually, we will represent whole atoms in memory as condensed boxes,
%with their location tags separate.

\end{document}
